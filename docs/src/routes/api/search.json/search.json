[{"title":"Accordion","content":"  import { APISection, ComponentPreviewV2, AccordionDemo, AccordionDemoTransitions, AccordionDemoCustom, AccordionDemoHorizontalCards, Callout, AccordionDemoCheckoutSteps } from '$lib/components/index.js'   let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The Accordion component is a versatile UI element designed to organize content into collapsible sections, helping users focus on specific information without being overwhelmed by visual clutter.  Quick Start    import { Accordion } from \"bits-ui\";            Item 1 Title      This is the collapsible content for this section.           Item 2 Title      This is the collapsible content for this section. Key Features  Single or Multiple Mode**: Toggle between allowing one open section or multiple sections at once. Accessible by Default**: Built-in ARIA attributes and keyboard navigation support. Smooth Transitions**: Leverage CSS variables or Svelte transitions for animated open/close effects. Flexible State**: Use uncontrolled defaults or take full control with bound values.  Structure  The Accordion is a compound component made up of several parts:  Accordion.Root: Container that manages overall state Accordion.Item: Individual collapsible section Accordion.Header: Contains the visible heading Accordion.Trigger: The clickable element that toggles content visibility Accordion.Content: The collapsible body content  Reusable Components  To streamline usage in larger applications, create custom wrapper components for repeated patterns. Below is an example of a reusable MyAccordionItem and MyAccordion.  Item Wrapper  Combines Item, Header, Trigger, and Content into a single component:    import { Accordion, type WithoutChildrenOrChild } from \"bits-ui\";   type Props = WithoutChildrenOrChild & {   title: string;   content: string;  };   let { title, content, ...restProps }: Props = $props();        {item.title}       {content} Accordion Wrapper  Wraps Root and renders multiple MyAccordionItem components:    import { Accordion, type WithoutChildrenOrChild } from \"bits-ui\";  import MyAccordionItem from \"$lib/components/MyAccordionItem.svelte\";   type Item = {   value?: string;   title: string;   content: string;   disabled?: boolean;  };   let {   value = $bindable(),   ref = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   items: Item[];  } = $props();      {#each items as item, i (item.title + i)}     {/each}  Usage Example    import MyAccordion from \"$lib/components/MyAccordion.svelte\";  const items = [   { title: \"Item 1\", content: \"Content 1\" },   { title: \"Item 2\", content: \"Content 2\" },  ];       Use unique value props for each Item if you plan to control the state programatically.  Managing Value State  This section covers how to manage the value state of the Accordion.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { Accordion } from \"bits-ui\";  let myValue = $state([]);  const numberOfItemsOpen = $derived(myValue.length);    {   myValue = [\"item-1\", \"item-2\"];  }}  Open Items 1 and 2  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Accordion } from \"bits-ui\";  let myValue = $state(\"\");   function getValue() {   return myValue;  }   function setValue(newValue: string) {   myValue = newValue;  }        See the $2 documentation for more information.  Customization  Single vs. Multiple  Set the type prop to \"single\" to allow only one accordion item to be open at a time.      Set the type prop to \"multiple\" to allow multiple accordion items to be open at the same time.  Default Open Items  Set the value prop to pre-open items:  Disable Items  Disable specific items with the disabled prop:  Svelte Transitions  The Accordion component can be enhanced with Svelte's built-in transition effects or other animation libraries.  Using forceMount and child Snippets  To apply Svelte transitions to Accordion components, use the forceMount prop in combination with the child snippet. This approach gives you full control over the mounting behavior and animation of the Accordion.Content.    {#snippet child({ props, open })}   {#if open}         This is the accordion content that will transition in and out.       {/if}  {/snippet}   In this example:  The forceMount prop ensures the components are always in the DOM. The child snippet provides access to the open state and component props. Svelte's #if block controls when the content is visible. Transition directives (transition:fade and transition:fly) apply the animations.    {#snippet preview()}  {/snippet}  Best Practices  For cleaner code and better maintainability, consider creating custom reusable components that encapsulate this transition logic.    import { Accordion, type WithoutChildrenOrChild } from \"bits-ui\";  import type { Snippet } from \"svelte\";  import { fade } from \"svelte/transition\";   let {   ref = $bindable(null),   duration = 200,   children,   ...restProps  }: WithoutChildrenOrChild & {   duration?: number;   children: Snippet;  } = $props();     {#snippet child({ props, open })}   {#if open}         {@render children?.()}       {/if}  {/snippet}   You can then use the MyAccordionContent component alongside the other Accordion primitives throughout your application:           A Examples  The following examples demonstrate different ways to use the Accordion component.  Horizontal Cards  Use the Accordion component to create a horizontal card layout with collapsible sections.    {#snippet preview()}  {/snippet}  Checkout Steps  Use the Accordion component to create a multi-step checkout process.    {#snippet preview()}  {/snippet}    ","description":"Organizes content into collapsible sections, allowing users to focus on one or more sections at a time.","href":"/docs/components/accordion"},{"title":"Alert Dialog","content":"  import { APISection, ComponentPreviewV2, AlertDialogDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Key Features  Compound Component Structure**: Build flexible, customizable alert dialogs using sub-components. Accessibility**: ARIA-compliant with full keyboard navigation support. Portal Support**: Render content outside the normal DOM hierarchy for proper stacking. Managed Focus**: Automatically traps focus with customization options. Flexible State**: Supports both controlled and uncontrolled open states.  Structure  The Alert Dialog is built from sub-components, each with a specific purpose:  Root**: Manages state and provides context to child components. Trigger**: Toggles the dialog's open/closed state. Portal**: Renders its children in a portal, outside the normal DOM hierarchy. Overlay**: Displays a backdrop behind the dialog. Content**: Holds the dialog's main content. Title**: Displays the dialog's title. Description**: Displays a description or additional context for the dialog. Cancel**: Closes the dialog without action. Action**: Confirms the dialog's action.  Here's a simple example of an Alert Dialog:    import { AlertDialog } from \"bits-ui\";     Open Dialog            Confirm Action    Are you sure?    Cancel    Confirm Reusable Components  For consistency across your app, create a reusable Alert Dialog component. Here's an example:    import type { Snippet } from \"svelte\";  import { AlertDialog, type WithoutChild } from \"bits-ui\";   type Props = AlertDialog.RootProps & {   buttonText: string;   title: Snippet;   description: Snippet;   contentProps?: WithoutChild;   // ...other component props if you wish to pass them  };   let {   open = $bindable(false),   children,   buttonText,   contentProps,   title,   description,   ...restProps  }: Props = $props();        {buttonText}                   {@render title()}             {@render description()}        {@render children?.()}    Cancel    Confirm        You can then use the MyAlertDialog component in your application like so:    import MyAlertDialog from \"$lib/components/MyAlertDialog.svelte\";     {#snippet title()}   Delete your account  {/snippet}  {#snippet description()}   This action cannot be undone.  {/snippet}   Alternatively, you can define the snippets separately and pass them as props to the component:    import MyAlertDialog from \"$lib/components/MyAlertDialog.svelte\";   {#snippet title()}  Delete your account {/snippet} {#snippet description()}  This action cannot be undone. {/snippet}        Use string props for simplicity or snippets for dynamic content.  Managing Open State  This section covers how to manage the open state of the Alert Dialog.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { AlertDialog } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Dialog  Fully Controlled  Use a $2 for total control:    import { AlertDialog } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }        See the $2 documentation for more information.  Focus Management  Focus Trap  Focus is trapped within the dialog by default. To disable:        Disabling focus trap may reduce accessibility. Use with caution.  Open Focus  By default, when a dialog is opened, focus will be set to the AlertDialog.Cancel button if it exists, or the first focusable element within the AlertDialog.Content. This ensures that users navigating my keyboard end up somewhere within the Dialog that they can interact with.  You can override this behavior using the onOpenAutoFocus prop on the AlertDialog.Content component. It's highly recommended that you use this prop to focus something within the Dialog.  You'll first need to cancel the default behavior of focusing the first focusable element by cancelling the event passed to the onOpenAutoFocus callback. You can then focus whatever you wish.    import { AlertDialog } from \"bits-ui\";  let nameInput = $state();     Open AlertDialog   {    e.preventDefault();    nameInput?.focus();   }} Close Focus  By default, when a dialog is closed, focus will be set to the trigger element of the dialog. You can override this behavior using the onCloseAutoFocus prop on the AlertDialog.Content component.  You'll need to cancel the default behavior of focusing the trigger element by cancelling the event passed to the onCloseAutoFocus callback, and then focus whatever you wish.    import { AlertDialog } from \"bits-ui\";  let nameInput = $state();      Open AlertDialog   {    e.preventDefault();    nameInput?.focus();   }} Advanced Behaviors  The Alert Dialog component offers several advanced features to customize its behavior and enhance user experience. This section covers scroll locking, escape key handling, and interaction outside the dialog.  Scroll Lock  By default, when an Alert Dialog opens, scrolling the body is disabled. This provides a more native-like experience, focusing user attention on the dialog content.  Customizing Scroll Behavior  To allow body scrolling while the dialog is open, use the preventScroll prop on AlertDialog.Content:         Enabling body scroll may affect user focus and accessibility. Use this option judiciously.  Escape Key Handling  By default, pressing the Escape key closes an open Alert Dialog. Bits UI provides two methods to customize this behavior.  Method 1: escapeKeydownBehavior  The escapeKeydownBehavior prop allows you to customize the behavior taken by the component when the Escape key is pressed. It accepts one of the following values:  'close' (default): Closes the Alert Dialog immediately. 'ignore': Prevents the Alert Dialog from closing. 'defer-otherwise-close': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Alert Dialog will close immediately. 'defer-otherwise-ignore': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Alert Dialog will ignore the key press and not close.  To always prevent the Alert Dialog from closing on Escape key press, set the escapeKeydownBehavior prop to 'ignore' on Dialog.Content:  Method 2: onEscapeKeydown  For more granular control, override the default behavior using the onEscapeKeydown prop:   {   e.preventDefault();   // do something else instead  }}     This method allows you to implement custom logic when the Escape key is pressed.  Interaction Outside  By default, interacting outside the Alert Dialog content area does not close the dialog. Bits UI offers two ways to modify this behavior.  Method 1: interactOutsideBehavior  The interactOutsideBehavior prop allows you to customize the behavior taken by the component when an interaction (touch, mouse, or pointer event) occurs outside the content. It accepts one of the following values:  'ignore' (default): Prevents the Alert Dialog from closing. 'close': Closes the Alert Dialog immediately. 'defer-otherwise-close': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Alert Dialog will close immediately. 'defer-otherwise-ignore': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Alert Dialog will ignore the event and not close.  To make the Alert Dialog close when an interaction occurs outside the content, set the interactOutsideBehavior prop to 'close' on AlertDialog.Content:  Method 2: onInteractOutside  For custom handling of outside interactions, you can override the default behavior using the onInteractOutside prop:   {   e.preventDefault();   // do something else instead  }}     This approach allows you to implement specific behaviors when users interact outside the Alert Dialog content.  Best Practices  Scroll Lock**: Consider your use case carefully before disabling scroll lock. It may be necessary for dialogs with scrollable content or for specific UX requirements. Escape Keydown**: Overriding the default escape key behavior should be done thoughtfully. Users often expect the escape key to close modals. Outside Interactions**: Ignoring outside interactions can be useful for important dialogs or multi-step processes, but be cautious not to trap users unintentionally. Accessibility**: Always ensure that any customizations maintain or enhance the dialog's accessibility. User Expectations**: Try to balance custom behaviors with common UX patterns to avoid confusing users.  By leveraging these advanced features, you can create highly customized dialog experiences while maintaining usability and accessibility standards.  Nested Dialogs  Dialogs can be nested within each other to create more complex layouts. See the $2 component for more information on nested dialogs.  Svelte Transitions  See the $2 component for more information on Svelte Transitions with dialog components.  Working with Forms  Form Submission  When using the AlertDialog component, often you'll want to submit a form or perform an asynchronous action when the user clicks the Action button.  This can be done by waiting for the asynchronous action to complete, then programmatically closing the dialog.    import { AlertDialog } from \"bits-ui\";   function wait(ms: number) {   return new Promise((resolve) => setTimeout(resolve, ms));  }   let open = $state(false);               Confirm your action    Are you sure you want to do this?     {      wait(1000).then(() => (open = false));     }}     No, cancel (close dialog)     Yes (submit form) Inside a Form  If you're using an AlertDialog within a form, you'll need to ensure that the Portal is disabled or not included in the AlertDialog structure. This is because the Portal will render the dialog content outside of the form, which will prevent the form from being submitted correctly.  ","description":"A modal window that alerts users with important information and awaits their acknowledgment or action.","href":"/docs/components/alert-dialog"},{"title":"Aspect Ratio","content":"  import { APISection, ComponentPreviewV2, AspectRatioDemo } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Architecture  Root**: The root component which contains the aspect ratio logic  Structure  Here's an overview of how the Aspect Ratio component is structured in code:    import { AspectRatio } from \"bits-ui\";  Reusable Component  If you plan on using a lot of AspectRatio components throughout your application, you can create a reusable component that combines the AspectRatio.Root and whatever other elements you'd like to render within it. In the following example, we're creating a reusable MyAspectRatio component that takes in a src prop and renders an img element with the src prop.    import { AspectRatio, type WithoutChildrenOrChild } from \"bits-ui\";   let {   src,   alt,   ref = $bindable(null),   imageRef = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   src: string;   alt: string;   imageRef?: HTMLImageElement | null;  } = $props();        You can then use the MyAspectRatio component in your application like so:    import MyAspectRatio from \"$lib/components/MyAspectRatio.svelte\";  Custom Ratio  Use the ratio prop to set a custom aspect ratio for the image.       ","description":"Displays content while maintaining a specified aspect ratio, ensuring consistent visual proportions.","href":"/docs/components/aspect-ratio"},{"title":"Avatar","content":"  import { APISection, ComponentPreviewV2, AvatarDemo, AvatarDemoLinkPreview } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The Avatar component provides a consistent way to display user or entity images throughout your application. It handles image loading states gracefully and offers fallback options when images fail to load, ensuring your UI remains resilient.  Features  Smart Image Loading**: Automatically detects and handles image loading states Fallback System**: Displays alternatives when images are unavailable or slow to load Compound Structure**: Flexible primitives that can be composed and customized Customizable**: Choose to show the image immediately without a load check when you're certain the image will load.  Architecture  The Avatar component follows a compound component pattern with three key parts:  Avatar.Root**: Container that manages the state of the image and its fallback Avatar.Image**: Displays user or entity image Avatar.Fallback**: Shows when the image is loading or fails to load  Quick Start  To get started with the Avatar component, you can use the Avatar.Root, Avatar.Image, and Avatar.Fallback primitives to create a basic avatar component:    import { Avatar } from \"bits-ui\";       HB  Reusable Components  You can create your own reusable Avatar component to maintain consistent styling and behavior throughout your application:    import { Avatar, type WithoutChildrenOrChild } from \"bits-ui\";   let {   src,   alt,   fallback,   ref = $bindable(null),   imageRef = $bindable(null),   fallbackRef = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   src: string;   alt: string;   fallback: string;   imageRef?: HTMLImageElement | null;   fallbackRef?: HTMLElement | null;  } = $props();          {fallback}     Then use it throughout your application:    import UserAvatar from \"$lib/components/UserAvatar.svelte\";   const users = [   { handle: \"huntabyte\", initials: \"HJ\" },   { handle: \"pavelstianko\", initials: \"PS\" },   { handle: \"adriangonz97\", initials: \"AG\" },  ];   {#each users as user}   {/each}  Customization  Skip Loading Check  When you're confident that an image will load (such as local assets), you can bypass the loading check:    import { Avatar } from \"bits-ui\";   // local asset that's guaranteed to be available  import localAvatar from \"/avatar.png\";       HB  Examples  Clickable with Link Preview  This example demonstrates how to create a clickable avatar composed with a $2:    {#snippet preview()}  {/snippet}    ","description":"Represents a user or entity with a recognizable image or placeholder in UI elements.","href":"/docs/components/avatar"},{"title":"Button","content":"  import { APISection, ComponentPreviewV2, ButtonDemo } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Button } from \"bits-ui\";     ","description":"A component that if passed a `href` prop will render an anchor element instead of a button element.","href":"/docs/components/button"},{"title":"Calendar","content":"  import { APISection, ComponentPreviewV2, CalendarDemo, CalendarDemoSelects, CalendarDemoPresets, Callout } from '$lib/components'  let { schemas } = $props()     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Structure    import { Calendar } from \"bits-ui\";     {#snippet children({ months, weekdays })}                      {#each months as month}                      {#each weekdays as day}                 {day}               {/each}                      {#each month.weeks as weekDates}               {#each weekDates as date}                                    {/each}             {/each}            {/each}  {/snippet}  Placeholder  The placeholder prop for the Calendar.Root component determines what date our calendar should start with when the user hasn't selected a date yet. It also determines the current \"view\" of the calendar.  As the user navigates through the calendar, the placeholder will be updated to reflect the currently focused date in that view.  By default, the placeholder will be set to the current date, and be of type CalendarDate.  Managing Placeholder State  This section covers how to manage the placeholder state of the Calendar.  Two-Way Binding  Use bind:placeholder for simple, automatic state synchronization:    import { Calendar } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myPlaceholder = new CalendarDate(2024, 8, 3))}>  Set placeholder to August 3rd, 2024  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Calendar } from \"bits-ui\";  import type { DateValue } from \"@internationalized/date\";   let myPlaceholder = $state();   function getPlaceholder() {   return myPlaceholder;  }   function setPlaceholder(newPlaceholder: DateValue) {   myPlaceholder = newPlaceholder;  }        See the $2 documentation for more information.  Managing Value State  This section covers how to manage the value state of the Calendar.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { Calendar } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myValue = myValue.add({ days: 1 }))}> Add 1 day   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Calendar } from \"bits-ui\";  import type { DateValue } from \"@internationalized/date\";  let myValue = $state();   function getValue() {   return myValue;  }   function setValue(newValue: DateValue) {   myValue = newValue;  }        See the $2 documentation for more information.  Default Value  Often, you'll want to start the Calendar.Root component with a default value. Likely this value will come from a database in the format of an ISO 8601 string.  You can use the parseDate function from the @internationalized/date package to parse the string into a CalendarDate object.    import { Calendar } from \"bits-ui\";  import { parseDate } from \"@internationalized/date\";   // this came from a database/API call  const date = \"2024-08-03\";   let value = $state(parseDate(date));  Validation  Minimum Value  You can set a minimum value for the calendar by using the minValue prop on Calendar.Root. If a user selects a date that is less than the minimum value, the calendar will be marked as invalid.    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const yesterday = todayDate.subtract({ days: 1 });  Maximum Value  You can set a maximum value for the calendar by using the maxValue prop on Calendar.Root. If a user selects a date that is greater than the maximum value, the calendar will be marked as invalid.    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const tomorrow = todayDate.add({ days: 1 });  Unavailable Dates  You can specify specific dates that are unavailable for selection by using the isDateUnavailable prop. This prop accepts a function that returns a boolean value indicating whether a date is unavailable or not.    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone, isNotNull } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const tomorrow = todayDate.add({ days: 1 });   function isDateUnavailable(date: DateValue) {   return date.day === 1;  }  Disabled Dates  You can specify specific dates that are disabled for selection by using the isDateDisabled prop.    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone, isNotNull } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const tomorrow = todayDate.add({ days: 1 });   function isDateDisabled(date: DateValue) {   return date.day === 1;  }  Appearance & Behavior  Fixed Weeks  You can use the fixedWeeks prop to ensure that the calendar renders a fixed number of weeks, regardless of the number of days in the month. This is useful to keep the calendar visually consistent when the number of days in the month changes.  Multiple Months  You can use the numberOfMonths prop to render multiple months at once.  Paged Navigation  By default, when the calendar has more than one month, the previous and next buttons will shift the calendar forward or backward by one month. However, you can change this behavior by setting the pagedNavigation prop to true, which will shift the calendar forward or backward by the number of months being displayed.  Localization  The calendar will automatically format the content of the calendar according to the locale prop, which defaults to 'en-US', but can be changed to any locale supported by the $2 API.  Week Starts On  The calendar will automatically format the content of the calendar according to the locale, which will determine what day of the week is the first day of the week.  You can also override this by setting the weekStartsOn prop, where 0 is Sunday and 6 is Saturday to force a consistent first day of the week across all locales.  Multiple Selection  You can set the type prop to 'multiple' to allow users to select multiple dates at once.  Custom Composition  Month Selector  The Calendar component includes a PrevButton and NextButton component to allow users to navigate between months. This is useful, but sometimes you may want to allow the user to select a specific month from a list of months, rather than having to navigate one at a time.  To achieve this, you can use the placeholder prop to set the month of the the calendar view programmatically.    import { Calendar } from \"bits-ui\";  import { CalendarDate } from \"@internationalized/date\";   let placeholder = $state(new CalendarDate(2024, 8, 3));     {   placeholder = placeholder.set({ month: 8 });  }}  Set month to August        Updating the placeholder will update the calendar view to reflect the new month.  Examples  Month and Year Selects  This example demonstrates how to use the placeholder prop to set the month and year of the calendar view programmatically.    {#snippet preview()}  {/snippet}  Preset Dates  This example demonstrates how to programatically set the value of the calendar to a specific date when a user presses a button.    {#snippet preview()}  {/snippet}    ","description":"Displays dates and days of the week, facilitating date-related interactions.","href":"/docs/components/calendar"},{"title":"Checkbox","content":"  import { APISection, ComponentPreviewV2, CheckboxDemo, CheckboxDemoCustom, CheckboxDemoGroup, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The Checkbox component provides a flexible and accessible way to create checkbox inputs in your Svelte applications. It supports three states: checked, unchecked, and indeterminate, allowing for complex form interactions and data representations.  Key Features  Tri-State Support**: Handles checked, unchecked, and indeterminate states, providing versatility in form design. Accessibility**: Built with WAI-ARIA guidelines in mind, ensuring keyboard navigation and screen reader support. Flexible State Management**: Supports both controlled and uncontrolled state, allowing for full control over the checkbox's checked state.  Architecture  The Checkbox component is composed of the following parts:  Root**: The main component that manages the state and behavior of the checkbox.  Structure  Here's an overview of how the Checkbox component is structured in code:    import { Checkbox } from \"bits-ui\";     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {:else}    ❌   {/if}  {/snippet}  Reusable Components  It's recommended to use the Checkbox primitive to create your own custom checkbox component that can be used throughout your application. In the example below, we're using the Checkbox and $2 components to create a custom checkbox component.    import { Checkbox, Label, useId, type WithoutChildrenOrChild } from \"bits-ui\";   let {   id = useId(),   checked = $bindable(false),   ref = $bindable(null),   labelRef = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   labelText: string;   labelRef?: HTMLLabelElement | null;  } = $props();     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {:else}    ❌   {/if}  {/snippet}    {labelText}   You can then use the MyCheckbox component in your application like so:    import MyCheckbox from \"$lib/components/MyCheckbox.svelte\";  Managing Checked State  This section covers how to manage the checked state of the Checkbox.  Two-Way Binding  Use bind:checked for simple, automatic state synchronization:    import { Checkbox } from \"bits-ui\";  let myChecked = $state(false);    (myChecked = false)}> uncheck   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Checkbox } from \"bits-ui\";  let myChecked = $state(false);   function getChecked() {   return myChecked;  }   function setChecked(newChecked: boolean) {   myChecked = newChecked;  }  Managing Indeterminate State  This section covers how to manage the indeterminate state of the Checkbox.  Two-Way Binding  Use bind:indeterminate for simple, automatic state synchronization:    import MyCheckbox from \"$lib/components/MyCheckbox.svelte\";  let myIndeterminate = $state(true);    (myIndeterminate = false)}> clear indeterminate   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Checkbox } from \"bits-ui\";  let myIndeterminate = $state(true);   function getIndeterminate() {   return myIndeterminate;  }   function setIndeterminate(newIndeterminate: boolean) {   myIndeterminate = newIndeterminate;  }  Disabled State  You can disable the checkbox by setting the disabled prop to true.  HTML Forms  If you set the name prop, a hidden checkbox input will be rendered to submit the value of the checkbox with a form.  By default, the checkbox will be submitted with default checkbox value of 'on' if the checked prop is true.  Custom Input Value  If you'd prefer to submit a different value, you can use the value prop to set the value of the hidden input.  For example, if you wanted to submit a string value, you could do the following:  Required  If you want to make the checkbox required, you can use the required prop.       This will apply the required attribute to the hidden input element, ensuring that proper form submission is enforced.  Checkbox Groups  You can use the Checkbox.Group component to create a checkbox group.    import { Checkbox } from \"bits-ui\";     Notifications           {#snippet preview()}  {/snippet}  Managing Value State  This section covers how to manage the value state of a Checkbox Group.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { Checkbox } from \"bits-ui\";  let myValue = $state([]);    {   myValue = [\"item-1\", \"item-2\"];  }}  Open Items 1 and 2     Items Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Checkbox } from \"bits-ui\";  let myValue = $state([]);   function getValue() {   return myValue;  }   function setValue(newValue: string[]) {   myValue = newValue;  }  HTML Forms  To render hidden ` elements for the various checkboxes within a group, pass a name to Checkbox.Group`. All descendent checkboxes will then render hidden inputs with the same name.       When a Checkbox.Group component is used, its descendent Checkbox.Root components will use certain properties from the group, such as the name, required, and disabled.  ","description":"Allow users to switch between checked, unchecked, and indeterminate states.","href":"/docs/components/checkbox"},{"title":"Collapsible","content":"  import { APISection, ComponentPreviewV2, CollapsibleDemo, CollapsibleDemoTransitions, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The Collapsible component enables you to create expandable and collapsible content sections. It provides an efficient way to manage space and organize information in user interfaces, enabling users to show or hide content as needed.  Key Features  Accessibility**: ARIA attributes for screen reader compatibility and keyboard navigation. Transition Support**: CSS variables and data attributes for smooth transitions between states. Flexible State Management**: Supports controlled and uncontrolled state, take control if needed. Compound Component Structure**: Provides a set of sub-components that work together to create a fully-featured collapsible.  Architecture  The Collapsible component is composed of a few sub-components, each with a specific role:  Root**: The parent container that manages the state and context for the collapsible functionality. Trigger**: The interactive element (e.g., button) that toggles the expanded/collapsed state of the content. Content**: The container for the content that will be shown or hidden based on the collapsible state.  Structure  Here's an overview of how the Collapsible component is structured in code:    import { Collapsible } from \"bits-ui\";  Reusable Components  It's recommended to use the Collapsible primitives to create your own custom collapsible component that can be used throughout your application.    import { Collapsible, type WithoutChild } from \"bits-ui\";   type Props = WithoutChild & {   buttonText: string;  };   let {   open = $bindable(false),   ref = $bindable(null),   buttonText,   children,   ...restProps  }: Props = $props();     {buttonText}     {@render children?.()}     You can then use the MyCollapsible component in your application like so:    import MyCollapsible from \"$lib/components/MyCollapsible.svelte\";   Here is my collapsible content.  Managing Open State  This section covers how to manage the open state of the Collapsible.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { Collapsible } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Collapsible  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Collapsible } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Svelte Transitions  The Collapsible component can be enhanced with Svelte's built-in transition effects or other animation libraries.  Using forceMount and child Snippets  To apply Svelte transitions to Collapsible components, use the forceMount prop in combination with the child snippet. This approach gives you full control over the mounting behavior and animation of the Collapsible.Content.    import { Collapsible } from \"bits-ui\";  import { fade } from \"svelte/transition\";     Open     {#snippet child({ props, open })}    {#if open}                    {/if}   {/snippet}     In this example:  The forceMount prop ensures the content is always in the DOM. The child snippet provides access to the open state and component props. Svelte's #if block controls when the content is visible. Transition directive (transition:fade) apply the animations.  Best Practices  For cleaner code and better maintainability, consider creating custom reusable components that encapsulate this transition logic.    import { Collapsible, type WithoutChildrenOrChild } from \"bits-ui\";  import { fade } from \"svelte/transition\";  import type { Snippet } from \"svelte\";   let {   ref = $bindable(null),   duration = 200,   children,   ...restProps  }: WithoutChildrenOrChild & {   duration?: number;   children?: Snippet;  } = $props();     {#snippet child({ props, open })}   {#if open}         {@render children?.()}       {/if}  {/snippet}   You can then use the MyCollapsibleContent component alongside the other Collapsible primitives throughout your application:    import { Collapsible } from \"bits-ui\";  import { MyCollapsibleContent } from \"$lib/components\";     Open          ","description":"Conceals or reveals content sections, enhancing space utilization and organization.","href":"/docs/components/collapsible"},{"title":"Combobox","content":"  import { APISection, ComponentPreviewV2, ComboboxDemo, ComboboxDemoTransition, ComboboxDemoAutoScrollDelay, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The Combobox component combines the functionality of an input field with a dropdown list of selectable options. It provides users with the ability to search, filter, and select from a predefined set of choices.  Key Features  Keyboard Navigation**: Full support for keyboard interactions, allowing users to navigate and select options without using a mouse. Customizable Rendering**: Flexible architecture for rendering options, including support for grouped items. Accessibility**: Built with ARIA attributes and keyboard interactions to ensure screen reader compatibility and accessibility standards. Portal Support**: Ability to render the dropdown content in a portal, preventing layout issues in complex UI structures.  Architecture  The Combobox component is composed of several sub-components, each with a specific role:  Root**: The main container component that manages the state and context for the combobox. Input**: The input field that allows users to enter search queries. Trigger**: The button or element that opens the dropdown list. Portal**: Responsible for portalling the dropdown content to the body or a custom target. Group**: A container for grouped items, used to group related items. GroupHeading**: A heading for a group of items, providing a descriptive label for the group. Item**: An individual item within the list. Separator**: A visual separator between items. Content**: The dropdown container that displays the items. It uses $2 to position the content relative to the trigger. ContentStatic**: An alternative to the Content component, that enables you to opt-out of Floating UI and position the content yourself. Viewport**: The visible area of the dropdown content, used to determine the size and scroll behavior. ScrollUpButton**: A button that scrolls the content up when the content is larger than the viewport. ScrollDownButton**: A button that scrolls the content down when the content is larger than the viewport. Arrow**: An arrow element that points to the trigger when using the Combobox.Content component.  Structure  Here's an overview of how the Combobox component is structured in code:    import { Combobox } from \"bits-ui\";  Reusable Components  It's recommended to use the Combobox primitives to build your own custom combobox component that can be reused throughout your application.    import { Combobox, type WithoutChildrenOrChild, mergeProps } from \"bits-ui\";   type Props = Combobox.RootProps & {   inputProps?: WithoutChildrenOrChild;   contentProps?: WithoutChildrenOrChild;  };   let {   items = [],   value = $bindable(),   open = $bindable(false),   inputProps,   contentProps,   type,   ...restProps  }: Props = $props();   let searchValue = $state(\"\");   const filteredItems = $derived.by(() => {   if (searchValue === \"\") return items;   return items.filter((item) => item.label.toLowerCase().includes(searchValue.toLowerCase()));  });   function handleInput(e: Event & { currentTarget: HTMLInputElement }) {   searchValue = e.currentTarget.value;  }   function handleOpenChange(newOpen: boolean) {   if (!newOpen) searchValue = \"\";  }   const mergedRootProps = $derived(mergeProps(restProps, { onOpenChange: handleOpenChange }));  const mergedInputProps = $derived(mergeProps(inputProps, { oninput: handleInput }));        Open         {#each filteredItems as item, i (i + item.value)}           {#snippet children({ selected })}       {item.label}       {selected ? \"✅\" : \"\"}      {/snippet}         {:else}      No results found     {/each}          import { CustomCombobox } from \"$lib/components\";   const items = [   { value: \"mango\", label: \"Mango\" },   { value: \"watermelon\", label: \"Watermelon\" },   { value: \"apple\", label: \"Apple\" },   // ...  ];  Managing Value State  This section covers how to manage the value state of the Combobox.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { Combobox } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"A\")}> Select A   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Combobox } from \"bits-ui\";  let myValue = $state(\"\");   function getValue() {   return myValue;  }   function setValue(newValue: string) {   myValue = newValue;  }  Managing Open State  This section covers how to manage the open state of the Combobox.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { Combobox } from \"bits-ui\";  let myOpen = $state(false);    (myOpen = true)}> Open   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Combobox } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Opt-out of Floating UI  When you use the Combobox.Content component, Bits UI uses $2 to position the content relative to the trigger, similar to other popover-like components.  You can opt-out of this behavior by instead using the Combobox.ContentStatic component.                                                              When using this component, you'll need to handle the positioning of the content yourself. Keep in mind that using Combobox.Portal alongside Combobox.ContentStatic may result in some unexpected positioning behavior, feel free to not use the portal or work around it.  Custom Anchor  By default, the Combobox.Content is anchored to the Combobox.Input component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the Combobox.Content component.    import { Combobox } from \"bits-ui\";   let customAnchor = $state(null!);  What is the Viewport?  The Combobox.Viewport component is used to determine the size of the content in order to determine whether or not the scroll up and down buttons should be rendered.  If you wish to set a minimum/maximum height for the select content, you should apply it to the Combobox.Viewport component.  Scroll Up/Down Buttons  The Combobox.ScrollUpButton and Combobox.ScrollDownButton components are used to render the scroll up and down buttons when the select content is larger than the viewport.  You must use the Combobox.Viewport component when using the scroll buttons.  Custom Scroll Delay  The initial and subsequent scroll delays can be controlled using the delay prop on the buttons.  For example, we can use the $2 easing function from Svelte to create a smooth scrolling effect that speeds up over time.    {#snippet preview()}  {/snippet}  Native Scrolling/Overflow  If you don't want to use the $2 and prefer to use the standard scrollbar/overflow behavior, you can omit the Combobox.Scroll[Up|Down]Button components and the Combobox.Viewport component.  You'll need to set a height on the Combobox.Content component and appropriate overflow styles to enable scrolling.  Scroll Lock  To prevent the user from scrolling outside of the Combobox.Content component when open, you can set the preventScroll prop to true.  Highlighted Items  The Combobox component follows the $2 for highlighting items. This means that the Combobox.Input retains focus the entire time, even when navigating with the keyboard, and items are highlighted as the user navigates them.  Styling Highlighted Items  You can use the data-highlighted attribute on the Combobox.Item component to style the item differently when it is highlighted.  onHighlight / onUnhighlight  To trigger side effects when an item is highlighted or unhighlighted, you can use the onHighlight and onUnhighlight props.   console.log('I am highlighted!')} onUnhighlight={() => console.log('I am unhighlighted!')} />  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Combobox.Content component to use Svelte Transitions or another animation library that requires more control.    import { Combobox } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ wrapperProps, props, open })}   {#if open}                           {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Enables users to pick from a list of options displayed in a dropdown.","href":"/docs/components/combobox"},{"title":"Command","content":"  import { APISection, ComponentPreviewV2, CommandDemo, CommandDemoDialog, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The Command component, also known as a command menu, is designed to provide users with a quick and efficient way to search, filter, and select items within an application. It combines the functionality of a search input with a dynamic, filterable list of commands or options, making it ideal for applications that require fast navigation or action execution.  Key Features  Dynamic Filtering**: As users type in the input field, the list of commands or items is instantly filtered and sorted based on an (overridable) scoring algorithm. Keyboard Navigation**: Full support for keyboard interactions, allowing users to quickly navigate and select items without using a mouse. Grouped Commands**: Ability to organize commands into logical groups, enhancing readability and organization. Empty and Loading States**: Built-in components to handle scenarios where no results are found or when results are being loaded. Accessibility**: Designed with ARIA attributes and keyboard interactions to ensure screen reader compatibility and accessibility standards.  Architecture  The Command component is composed of several sub-components, each with a specific role:  Root**: The main container that manages the overall state and context of the command menu. Input**: The text input field where users can type to search or filter commands. List**: The container for the list of commands or items. Viewport**: The visible area of the command list, which applies CSS variables to handle dynamic resizing/animations based on the height of the list. Empty**: A component to display when no results are found. Loading**: A component to display while results are being fetched or processed. Group**: A container for a group of items within the command menu. GroupHeading**: A header element to provide an accessible label for a group of items. GroupItems**: A container for the items within a group. Item**: Individual selectable command or item. LinkItem**: A variant of Command.Item specifically for link-based actions. Separator**: A visual separator to divide different sections of the command list.  Structure  Here's an overview of how the Command component is structured in code:    import { Command } from \"bits-ui\";  Managing Value State  Bits UI offers several approaches to manage and synchronize the Command's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { Command } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"A\")}> Select A   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., via clicking on an item) Allows external control (e.g., selecting an item via a separate button)  2. Change Handler  To perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute side effects when the value changes.    import { Command } from \"bits-ui\";    {   // do something with the new value   console.log(value);  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's state, use a $2 to manage the value state externally. You pass a getter function and a setter function to the bind:value directive, giving you full control over how the value is updated/retrieved.    import { Command } from \"bits-ui\";  let myValue = $state(\"\");    myValue, (newValue) => (myValue = newValue)}> When to Use  Implementing complex value change logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  In a Modal  You can combine the Command component with the Dialog component to display the command menu within a modal.      {#snippet preview()}  {/snippet}  Filtering  Custom Filter  By default, the Command component uses a scoring algorithm to determine how the items should be sorted/filtered. You can provide a custom filter function to override this behavior.  The function should return a number between 0 and 1, with 1 being a perfect match, and 0 being no match, resulting in the item being hidden entirely.  The following example shows how you might implement a strict substring match filter:    import { Command } from \"bits-ui\";   function customFilter(   commandValue: string,   search: string,   commandKeywords?: string[]  ): number {   return commandValue.includes(search) ? 1 : 0;  }  Extend Default Filter  By default, the Command component uses the computeCommandScore function to determine the score of each item and filters/sorts them accordingly. This function is exported for you to use and extend as needed.    import { Command, computeCommandScore } from \"bits-ui\";   function customFilter(   commandValue: string,   search: string,   commandKeywords?: string[]  ): number {   const score = computeCommandScore(commandValue, search, commandKeywords);    // Add custom logic here   return score;  }  Disable Filtering  You can disable filtering by setting the shouldFilter prop to false.       This is useful when you have a lot of custom logic, need to fetch items asynchronously, or just want to handle filtering yourself. You'll be responsible for iterating over the items and determining which ones should be shown.  Item Selection  You can use the onSelect prop to handle the selection of items.   console.log(\"selected something!\")} />  Links  If you want one of the items to get all the benefits of a link (prefetching, etc.), you should use the Command.LinkItem component instead of the Command.Item component. The only difference is that the Command.LinkItem component will render an a element instead of a div element.  Imperative API  For more advanced use cases, such as custom keybindings, the Command.Root component exposes several methods for programmatic control.  Access these by binding to the component:    import { Command } from \"bits-ui\";  let command: typeof Command.Root;  Methods  getValidItems()  Returns an array of valid (non-disabled, visible) command items. Useful for checking bounds before operations.  const items = command.getValidItems(); console.log(items.length); // number of selectable items  updateSelectedToIndex(index: number)  Sets selection to item at specified index. No-op if index is invalid.  // select third item (if it exists) command.updateSelectedToIndex(2);  // with bounds check const items = command.getValidItems(); if (index   import { Command } from \"bits-ui\";   let command: typeof Command.Root;   function jumpToLastItem() {   if (!command) return;   const items = command.getValidItems();   if (!items.length) return;   command.updateSelectedToIndex(items.length - 1);  }    {   if (e.key === \"o\") {    jumpToLastItem();   }  }} />  Common Mistakes  Duplicate values  The value of each Command.Item must be unique. If you have two items with the same value, the component will not be able to determine which one to select, causing unexpected behavior when navigating with the keyboard or hovering with the mouse.  If the text content of two items are the same for one reason or another, you should use the value prop to set a unique value for each item. When a value is set, the text content is used for display purposes only. The value prop is used for filtering and selection.  A common pattern is to postfix the value with something unique, like an ID or a number so that filtering will still match the value.  My Item My Item  ","description":"A command menu component that can be used to search, filter, and select items.","href":"/docs/components/command"},{"title":"Context Menu","content":"  import { APISection, ComponentPreviewV2, ContextMenuDemo, ContextMenuDemoTransition, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { ContextMenu } from \"bits-ui\";                                           {#snippet children({ checked })}      {checked ? \"✅\" : \"\"}     {/snippet}                         {#snippet children({ checked })}       {checked ? \"✅\" : \"\"}      {/snippet} Reusable Components  If you're planning to use Context Menu in multiple places, you can create a reusable component that wraps the Context Menu component.  This example shows you how to create a Context Menu component that accepts a few custom props that make it more capable.    import type { Snippet } from \"svelte\";  import { ContextMenu, type WithoutChild } from \"bits-ui\";  type Props = ContextMenu.Props & {   trigger: Snippet;   items: string[];   contentProps?: WithoutChild;   // other component props if needed  };  let {   open = $bindable(false),   children,   trigger,   items,   contentProps,   ...restProps  }: Props = $props();        {@render trigger()}                Select an Office     {#each items as item}             {item}           {/each}            You can then use the CustomContextMenu component like this:    import CustomContextMenu from \"./CustomContextMenu.svelte\";     {#snippet triggerArea()}       Right-click me     {/snippet}   Alternatively, you can define the snippet(s) separately and pass them as props to the component:    import CustomContextMenu from \"./CustomContextMenu.svelte\";   {#snippet triggerArea()}     Right-click me   {/snippet}  Managing Open State  This section covers how to manage the open state of the menu.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { ContextMenu } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Context Menu  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { ContextMenu } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newopen;  }  Radio Groups  You can combine the ContextMenu.RadioGroup and ContextMenu.RadioItem components to create a radio group within a menu.    import { ContextMenu } from \"bits-ui\";   const values = [\"one\", \"two\", \"three\"];  let value = $state(\"one\");     {#each values as value}       {#snippet children({ checked })}     {#if checked}      ✅     {/if}     {value}    {/snippet}     {/each}   See the $2 and $2 APIs for more information.  Checkbox Items  You can use the ContextMenu.CheckboxItem component to create a menuitemcheckbox element to add checkbox functionality to menu items.    import { ContextMenu } from \"bits-ui\";   let notifications = $state(true);     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {/if}   Notifications  {/snippet}   See the $2 for more information.  Checkbox Groups  You can use the ContextMenu.CheckboxGroup component around a set of ContextMenu.CheckboxItem components to create a checkbox group within a menu, where the value prop is an array of the selected values.    import { ContextMenu } from \"bits-ui\";   let colors = $state([]);     Favorite color     {#snippet children({ checked })}    {#if checked}     ✅    {/if}    Red   {/snippet}       {#snippet children({ checked })}    {#if checked}     ✅    {/if}    Blue   {/snippet}       {#snippet children({ checked })}    {#if checked}     ✅    {/if}    Green   {/snippet}     The value state does not persist between menu open/close cycles. To persist the state, you must store it in a $state variable and pass it to the value prop.  Nested Menus  You can create nested menus using the ContextMenu.Sub component to create complex menu structures.    import { ContextMenu } from \"bits-ui\";     Item 1  Item 2     Open Sub Menu       Sub Item 1    Sub Item 2 Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the ContextMenu.Content component to use Svelte Transitions or another animation library that requires more control.    import { ContextMenu } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ wrapperProps, props, open })}   {#if open}               Item 1      Item 2            {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Displays options or actions relevant to a specific context or selected item, triggered by a right-click.","href":"/docs/components/context-menu"},{"title":"Date Field","content":"  import { CalendarDateTime, CalendarDate, now, getLocalTimeZone, parseDate, today } from \"@internationalized/date\";  import { APISection, ComponentPreviewV2, DateFieldDemo, DateFieldDemoCustom, DemoContainer, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Overview  The DateField component is an alternative to the native `` element. It provides a more flexible and customizable way to select dates within a designated field.  Structure    import { DateField } from \"bits-ui\";     Check-in date     {#snippet children({ segments })}    {#each segments as { part, value }}           {value}         {/each}   {/snippet} Reusable Components  It's recommended to use the DateField primitives to build your own custom date field component that can be used throughout your application.  The following example shows how you might create a reusable MyDateField component that can be used throughout your application. For style inspiration, reference the featured demo at the top of this page.    import { DateField, type WithoutChildrenOrChild } from \"bits-ui\";   let {   value = $bindable(),   placeholder = $bindable(),   name,   ...restProps  }: WithoutChildrenOrChild & {   labelText: string;   name?: string;  } = $props();     {labelText}     {#snippet children({ segments })}    {#each segments as { part, value }}           {value}         {/each}   {/snippet}       {#snippet preview()}  {/snippet}    We'll be using this newly created MyDateField component in the following demos and examples to prevent repeating the same code, so be sure to reference it as you go through the documentation.  Segments  A segment of the DateField represents a not only a specific part of the date, such as the day, month, year, hour, but can also reference a \"literal\" which is typically a separator between the different parts of the date, and varies based on the locale.  Notice that in the MyDateField component we created, we're styling the DateField.Segment components differently based on whether they are a \"literal\" or not.  Placeholder  The placeholder prop for the DateField.Root component isn't what is displayed when the field is empty, but rather what date our field should start with when the user attempts to cycle through the segments. The placeholder can also be used to set a granularity for the date field, which will determine which type of DateValue object is used for the value.  By default, the placeholder will be set to the current date, and be of type CalendarDate. However, if we wanted this date field to also allow for selecting a time, we could set the placeholder to a CalendarDateTime object.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { CalendarDateTime } from \"@internationalized/date\";          If we're collecting a date from the user where we want the timezone as well, we can use a ZonedDateTime object instead.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { now, getLocalTimeZone } from \"@internationalized/date\";            If you're creating a date field for something like a birthday, ensure your placeholder is set in a leap year to ensure users born on a leap year will be able to select the correct date.  Managing Placeholder State  This section covers how to manage the placeholder state of the Date Field.  Two-Way Binding  Use bind:placeholder for simple, automatic state synchronization:    import { DateField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myPlaceholder = new CalendarDate(2024, 8, 3))}>  Set placeholder to August 3rd, 2024  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DateField } from \"bits-ui\";  import type { DateValue } from \"@internationalized/date\";  let myPlaceholder = $state();   function getPlaceholder() {   return myPlaceholder;  }   function setPlaceholder(newPlaceholder: DateValue) {   myPlaceholder = newPlaceholder;  }  Managing Value State  This section covers how to manage the value state of the Date Field.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { DateField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myValue = myValue.add({ days: 1 }))}> Add 1 day   Fully Controlled  For complete control over the component's state, use a $2 to manage the value state externally.    import { DateField } from \"bits-ui\";  import type { DateValue } from \"@internationalized/date\";  let myValue = $state();   function getValue() {   return myValue;  }   function setValue(newValue: DateValue | undefined) {   myValue = newValue;  }  Default Value  Often, you'll want to start the DateField.Root component with a default value. Likely this value will come from a database in the format of an ISO 8601 string. You can use the parseDate function from the @internationalized/date package to parse the string into a CalendarDate object.    import { DateField } from \"bits-ui\";  import { parseDate } from \"@internationalized/date\";   // this came from a database/API call  const date = \"2024-08-03\";   let value = $state(parseDate(date));             Now our input is populated with the default value. In addition to the parseDate function, you can also use parseDateTime or parseZonedDateTime to parse the string into a CalendarDateTime or ZonedDateTime object respectively.  Validation  Minimum Value  You can set a minimum value for the DateField.Root component by using the minValue prop. If a user selects a date that is less than the minimum value, the date field will be marked as invalid.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { today, getLocalTimeZone } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const yesterday = todayDate.subtract({ days: 1 });          In the example above, we're setting the minimum value to today, and the default value to yesterday. This causes the date field to be marked as invalid, and we can style it accordingly. If you adjust the date to be greater than the minimum value, the invalid state will be cleared.  Maximum Value  You can set a maximum value for the DateField.Root component by using the maxValue prop. If a user selects a date that is greater than the maximum value, the date field will be marked as invalid.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { today, getLocalTimeZone } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const tomorrow = todayDate.add({ days: 1 });          In the example above, we're setting the maximum value to today, and the default value to tomorrow. This causes the date field to be marked as invalid, and we can style it accordingly. If you adjust the date to be less than the maximum value, the invalid state will be cleared.  Custom Validation  You can use the validate prop to provide a custom validation function for the date field. This function should return a string or array of strings as validation errors if the date is invalid, or undefined/nothing if the date is valid.  The strings are then passed to the onInvalid callback, which you can use to display an error message to the user.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { CalendarDate, type DateValue } from \"@internationalized/date\";   const value = new CalendarDate(2024, 8, 2);   function validate(date: DateValue) {   return date.day === 1 ? \"Date cannot be the first day of the month\" : undefined;  }   function onInvalid(reason: \"min\" | \"max\" | \"custom\", msg?: string | string[]) {   if (reason === \"custom\") {    if (typeof msg === \"string\") {     // do something with the error message     console.log(msg);     return;    } else if (Array.isArray(msg)) {     // do something with the error messages     console.log(msg);     return;    }    console.log(\"The date is invalid\");   } else if (reason === \"min\") {    // let the user know that the date is too early.    console.log(\"The date is too early.\");   } else if (reason === \"max\") {    // let the user know that the date is too late.    console.log(\"The date is too late.\");   }  }        date.day === 1 ? \"Date cannot be the first day of the month\" : undefined} value={new CalendarDate(2024, 8, 2)} onInvalid={(reason, msg) => {   if (reason === \"custom\") {    if (typeof msg === \"string\") {     // do something with the error message     console.log(msg);     return;    } else if (Array.isArray(msg)) {     // do something with the error messages     console.log(msg);     return;    }    console.log(\"The date is invalid\");   } else if (reason === \"min\") {    // let the user know that the date is too early.    console.log(\"The date is too early.\");   } else if (reason === \"max\") {    // let the user know that the date is too late.    console.log(\"The date is too late.\");   }  }} />   Try selecting a date that is the first day of the month to see the date field marked as invalid.  Granularity  The granularity prop sets the granularity of the date field, which determines which segments are rendered in the date field. The granularity can be set to either 'day', 'hour', 'minute', or 'second'.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { CalendarDateTime } from \"@internationalized/date\";   const value = new CalendarDateTime(2024, 8, 2, 12, 30);          In the example above, we're setting the granularity to 'second', which means that the date field will include an additional segment for the seconds.  Localization  You can use the locale prop to set the locale of the date field. This will affect the formatting of the date field's segments and placeholders.    import MyDateField from \"$lib/components/MyDateField.svelte\";          ","description":"Enables users to input a date within a designated field.","href":"/docs/components/date-field"},{"title":"Date Picker","content":"  import { APISection, ComponentPreviewV2, DatePickerDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Structure    import { DatePicker } from \"bits-ui\";          {#snippet children({ segments })}    {#each segments as { part, value }}           {value}         {/each}       {/snippet}           {#snippet children({ months, weekdays })}                                 {#each months as month}                              {#each weekdays as day}                     {day}                   {/each}                              {#each month.weeks as weekDates}                   {#each weekDates as date}                                            {/each}                 {/each}                  {/each}    {/snippet} Managing Placeholder State  This section covers how to manage the placeholder state of the component.  Two-Way Binding  Use bind:placeholder for simple, automatic state synchronization:    import { DatePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state();    {   myPlaceholder = new CalendarDateTime(2024, 8, 3, 12, 30);  }}  Set placeholder to August 3rd, 2024  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DatePicker } from \"bits-ui\";  import type { DateValue } from \"@internationalized/date\";  let myPlaceholder = $state();   function getPlaceholder() {   return myPlaceholder;  }   function setPlaceholder(newPlaceholder: DateValue) {   myPlaceholder = newPlaceholder;  }  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { DatePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myValue = myValue.add({ days: 1 }))}> Add 1 day   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DatePicker } from \"bits-ui\";  import type { DateValue } from \"@internationalized/date\";  let myValue = $state();   function getValue() {   return myValue;  }   function setValue(newValue: DateValue) {   myValue = newValue;  }  Managing Open State  This section covers how to manage the open state of the component.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { DatePicker } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open DatePicker  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DatePicker } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Customization  The DatePicker component is made up of three other Bits UI components: $2, $2, and $2.  You can check out the documentation for each of these components to learn more about their customization options, each of which can be used to customize the DatePicker component.  ","description":"Facilitates the selection of dates through an input and calendar-based interface.","href":"/docs/components/date-picker"},{"title":"Date Range Field","content":"  import { APISection, ComponentPreviewV2, DateRangeFieldDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Overview  The DateRangeField component combines two $2 components to create a date range field. Check out the $2 component documentation for information on how to customize this component.  Structure    import { DateRangeField } from \"$lib\";     Check-in date  {#each [\"start\", \"end\"] as const as type}       {#snippet children({ segments })}     {#each segments as { part, value }}             {value}           {/each}    {/snippet}     {/each}  Managing Placeholder State  This section covers how to manage the placeholder state of the component.  Two-Way Binding  Use bind:placeholder for simple, automatic state synchronization:    import { DateRangeField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DateRangeField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));   function getPlaceholder() {   return myPlaceholder;  }   function setPlaceholder(newPlaceholder: CalendarDateTime) {   myPlaceholder = newPlaceholder;  }  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { DateRangeField, type DateRange } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state({   start: new CalendarDateTime(2024, 8, 3, 12, 30),   end: new CalendarDateTime(2024, 8, 4, 12, 30),  });    {   value = {    start: value.start.add({ days: 1 }),    end: value.end.add({ days: 1 }),   };  }}  Add 1 day  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DateRangeField } from \"bits-ui\";  let myValue = $state({   start: undefined,   end: undefined,  });   function getValue() {   return myValue;  }   function setValue(newValue: DateRange) {   myValue = newValue;  }        ","description":"Allows users to input a range of dates within a designated field.","href":"/docs/components/date-range-field"},{"title":"Date Range Picker","content":"  import { APISection, ComponentPreviewV2, DateRangePickerDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Structure    import { DateRangePicker } from \"bits-ui\";       {#each [\"start\", \"end\"] as const as type}       {#snippet children({ segments })}     {#each segments as { part, value }}             {value}           {/each}    {/snippet}     {/each}           {#snippet children({ months, weekdays })}                                 {#each months as month}                              {#each weekdays as day}                     {day}                   {/each}                              {#each month.weeks as weekDates}                   {#each weekDates as date}                                    {date.day}                                 {/each}                 {/each}                  {/each}    {/snippet} Managing Placeholder State  This section covers how to manage the placeholder state of the component.  Two-Way Binding  Use bind:placeholder for simple, automatic state synchronization:    import { DateRangePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DateRangePicker } from \"bits-ui\";  import type { DateValue } from \"@internationalized/date\";  let myPlaceholder = $state();   function getPlaceholder() {   return myPlaceholder;  }   function setPlaceholder(newPlaceholder: DateValue) {   myPlaceholder = newPlaceholder;  }  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { DateRangePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state({   start: new CalendarDateTime(2024, 8, 3, 12, 30),   end: new CalendarDateTime(2024, 8, 4, 12, 30),  });    {   value = {    start: value.start.add({ days: 1 }),    end: value.end.add({ days: 1 }),   };  }}  Add 1 day  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DateRangePicker, type DateRange } from \"bits-ui\";  let myValue = $state();   function getValue() {   return myValue;  }   function setValue(newValue: DateRange) {   myValue = newValue;  }  Managing Open State  This section covers how to manage the open state of the component.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { DateRangePicker } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open DateRangePicker  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DateRangePicker } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Customization  The DateRangePicker component is made up of three other Bits UI components: $2, $2, and $2.  You can check out the documentation for each of these components to learn more about their customization options, each of which can be used to customize the DateRangePicker component.  ","description":"Facilitates the selection of date ranges through an input and calendar-based interface.","href":"/docs/components/date-range-picker"},{"title":"Dialog","content":"  import { APISection, ComponentPreviewV2, DialogDemo, DialogDemoCustom, DialogDemoNested, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The Dialog component in Bits UI provides a flexible and accessible way to create modal dialogs in your Svelte applications. It follows a compound component pattern, allowing for fine-grained control over the dialog's structure and behavior while maintaining accessibility and ease of use.  Key Features  Compound Component Structure**: Offers a set of sub-components that work together to create a fully-featured dialog. Accessibility**: Built with WAI-ARIA guidelines in mind, ensuring keyboard navigation and screen reader support. Customizable**: Each sub-component can be styled and configured independently. Portal Support**: Content can be rendered in a portal, ensuring proper stacking context. Managed Focus**: Automatically manages focus, with the option to take control if needed. Flexible State Management**: Supports both controlled and uncontrolled state, allowing for full control over the dialog's open state.  Architecture  The Dialog component is composed of several sub-components, each with a specific role:  Root**: The main container component that manages the state of the dialog. Provides context for all child components. Trigger**: A button that toggles the dialog's open state. Portal**: Renders its children in a portal, outside the normal DOM hierarchy. Overlay**: A backdrop that sits behind the dialog content. Content**: The main container for the dialog's content. Title**: Renders the dialog's title. Description**: Renders a description or additional context for the dialog. Close**: A button that closes the dialog.  Structure  Here's an overview of how the Dialog component is structured in code:    import { Dialog } from \"bits-ui\";  Reusable Components  Bits UI provides a comprehensive set of Dialog components that serve as building blocks for creating customized, reusable Dialog implementations. This approach offers flexibility in design while maintaining consistency and accessibility across your application.  Building a Reusable Dialog  The following example demonstrates how to create a versatile, reusable Dialog component using Bits UI building blocks. This implementation showcases the flexibility of the component API by combining props and snippets.    import type { Snippet } from \"svelte\";  import { Dialog, type WithoutChild } from \"bits-ui\";   type Props = Dialog.RootProps & {   buttonText: string;   title: Snippet;   description: Snippet;   contentProps?: WithoutChild;   // ...other component props if you wish to pass them  };   let {   open = $bindable(false),   children,   buttonText,   contentProps,   title,   description,   ...restProps  }: Props = $props();        {buttonText}                   {@render title()}             {@render description()}        {@render children?.()}    Close Dialog Usage with Inline Snippets    import MyDialog from \"$lib/components/MyDialog.svelte\";     {#snippet title()}   Account settings  {/snippet}   {#snippet description()}   Manage your account settings and preferences.  {/snippet}  Usage with Separate Snippets    import MyDialog from \"$lib/components/MyDialog.svelte\";   {#snippet title()}  Account settings {/snippet}  {#snippet description()}  Manage your account settings and preferences. {/snippet}  Best Practices  Prop Flexibility**: Design your component to accept props for any nested components for maximum flexibility Styling Options**: Use tools like clsx to merge class overrides Binding Props**: Use bind: and expose $bindable props to provide consumers with full control Type Safety**: Use the exported types from Bits UI to type your component props  Managing Open State  This section covers how to manage the open state of the component.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { Dialog } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Dialog  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Dialog } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Focus Management  Proper focus management is crucial for accessibility and user experience in modal dialogs. Bits UI's Dialog component provides several features to help you manage focus effectively.  Focus Trap  By default, the Dialog implements a focus trap, adhering to the WAI-ARIA design pattern for modal dialogs. This ensures that keyboard focus remains within the Dialog while it's open, preventing users from interacting with the rest of the page.  Disabling the Focus Trap  While not recommended, you can disable the focus trap if absolutely necessary:         Disabling the focus trap may compromise accessibility. Only do this if you have a specific reason and implement an alternative focus management strategy.  Open Focus  When a Dialog opens, focus is automatically set to the first focusable element within Dialog.Content. This ensures keyboard users can immediately interact with the Dialog contents.  Customizing Initial Focus  To specify which element receives focus when the Dialog opens, use the onOpenAutoFocus prop on Dialog.Content:    import { Dialog } from \"bits-ui\";  let nameInput = $state();     Open Dialog   {    e.preventDefault();    nameInput?.focus();   }}          Always ensure that something within the Dialog receives focus when it opens. This is crucial for maintaining keyboard navigation context and makes your users happy.  Close Focus  When a Dialog closes, focus returns to the element that triggered its opening (typically the Dialog.Trigger).  Customizing Close Focus  To change which element receives focus when the Dialog closes, use the onCloseAutoFocus prop on Dialog.Content:    import { Dialog } from \"bits-ui\";  let nameInput = $state();      Open Dialog   {    e.preventDefault();    nameInput?.focus();   }} Best Practices  Always maintain a clear focus management strategy for your Dialogs. Ensure that focus is predictable and logical for keyboard users. Test your focus management with keyboard navigation to verify its effectiveness.  Advanced Behaviors  Bits UI's Dialog component offers several advanced features to customize its behavior and enhance user experience. This section covers scroll locking, escape key handling, and interaction outside the dialog.  Scroll Lock  By default, when a Dialog opens, scrolling the body is disabled. This provides a more native-like experience, focusing user attention on the dialog content.  Customizing Scroll Behavior  To allow body scrolling while the dialog is open, use the preventScroll prop on Dialog.Content:         Enabling body scroll may affect user focus and accessibility. Use this option judiciously.  Escape Key Handling  By default, pressing the Escape key closes an open Dialog. Bits UI provides two methods to customize this behavior.  Method 1: escapeKeydownBehavior  The escapeKeydownBehavior prop allows you to customize the behavior taken by the component when the Escape key is pressed. It accepts one of the following values:  'close' (default): Closes the Dialog immediately. 'ignore': Prevents the Dialog from closing. 'defer-otherwise-close': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Dialog will close immediately. 'defer-otherwise-ignore': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Dialog will ignore the key press and not close.  To always prevent the Dialog from closing on Escape key press, set the escapeKeydownBehavior prop to 'ignore' on Dialog.Content:  Method 2: onEscapeKeydown  For more granular control, override the default behavior using the onEscapeKeydown prop:   {   e.preventDefault();   // do something else instead  }}     This method allows you to implement custom logic when the Escape key is pressed.  Interaction Outside  By default, interacting outside the Dialog content area closes the Dialog. Bits UI offers two ways to modify this behavior.  Method 1: interactOutsideBehavior  The interactOutsideBehavior prop allows you to customize the behavior taken by the component when an interaction (touch, mouse, or pointer event) occurs outside the content. It accepts one of the following values:  'close' (default): Closes the Dialog immediately. 'ignore': Prevents the Dialog from closing. 'defer-otherwise-close': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Dialog will close immediately. 'defer-otherwise-ignore': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Dialog will ignore the event and not close.  To always prevent the Dialog from closing when an interaction occurs outside the content, set the interactOutsideBehavior prop to 'ignore' on Dialog.Content:  Method 2: onInteractOutside  For custom handling of outside interactions, you can override the default behavior using the onInteractOutside prop:   {   e.preventDefault();   // do something else instead  }}     This approach allows you to implement specific behaviors when users interact outside the Dialog content.  Best Practices  Scroll Lock**: Consider your use case carefully before disabling scroll lock. It may be necessary for dialogs with scrollable content or for specific UX requirements. Escape Keydown**: Overriding the default escape key behavior should be done thoughtfully. Users often expect the escape key to close modals. Outside Interactions**: Ignoring outside interactions can be useful for important dialogs or multi-step processes, but be cautious not to trap users unintentionally. Accessibility**: Always ensure that any customizations maintain or enhance the dialog's accessibility. User Expectations**: Try to balance custom behaviors with common UX patterns to avoid confusing users.  By leveraging these advanced features, you can create highly customized dialog experiences while maintaining usability and accessibility standards.  Nested Dialogs  Dialogs can be nested within each other to create more complex user interfaces:    import MyDialog from \"$lib/components/MyDialog.svelte\";     {#snippet title()}   First Dialog  {/snippet}  {#snippet description()}   This is the first dialog.  {/snippet}     {#snippet title()}    Second Dialog   {/snippet}   {#snippet description()}    This is the second dialog.   {/snippet} Svelte Transitions  The Dialog component can be enhanced with Svelte's built-in transition effects or other animation libraries.  Using forceMount and child Snippets  To apply Svelte transitions to Dialog components, use the forceMount prop in combination with the child snippet. This approach gives you full control over the mounting behavior and animation of Dialog.Content and Dialog.Overlay.    import { Dialog } from \"bits-ui\";  import { fly, fade } from \"svelte/transition\";          {#snippet child({ props, open })}    {#if open}                    {/if}   {/snippet}       {#snippet child({ props, open })}    {#if open}                    {/if}   {/snippet}     In this example:  The forceMount prop ensures the components are always in the DOM. The child snippet provides access to the open state and component props. Svelte's #if block controls when the content is visible. Transition directives (transition:fade and transition:fly) apply the animations.  Best Practices  For cleaner code and better maintainability, consider creating custom reusable components that encapsulate this transition logic.    import { Dialog, type WithoutChildrenOrChild } from \"bits-ui\";  import { fade } from \"svelte/transition\";  import type { Snippet } from \"svelte\";   let {   ref = $bindable(null),   duration = 200,   children,   ...restProps  }: WithoutChildrenOrChild & {   duration?: number;   children?: Snippet;  } = $props();     {#snippet child({ props, open })}   {#if open}         {@render children?.()}       {/if}  {/snippet}   You can then use the MyDialogOverlay component alongside the other Dialog primitives throughout your application:    import { Dialog } from \"bits-ui\";  import { MyDialogOverlay } from \"$lib/components\";     Open Working with Forms  Form Submission  When using the Dialog component, often you'll want to submit a form or perform an asynchronous action and then close the dialog.  This can be done by waiting for the asynchronous action to complete, then programmatically closing the dialog.    import { Dialog } from \"bits-ui\";   function wait(ms: number) {   return new Promise((resolve) => setTimeout(resolve, ms));  }   let open = $state(false);               Confirm your action    Are you sure you want to do this?     {      wait(1000).then(() => (open = false));     }}     Submit form Inside a Form  If you're using a Dialog within a form, you'll need to ensure that the Portal is disabled or not included in the Dialog structure. This is because the Portal will render the dialog content outside of the form, which will prevent the form from being submitted correctly.  ","description":"A modal window presenting content or seeking user input without navigating away from the current context.","href":"/docs/components/dialog"},{"title":"Dropdown Menu","content":"  import { APISection, ComponentPreviewV2, DropdownMenuDemo, DropdownMenuDemoTransition, Callout } from '$lib/components'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { DropdownMenu } from \"bits-ui\";  Reusable Components  If you're planning to use Dropdown Menu in multiple places, you can create a reusable component that wraps the Dropdown Menu component.  This example shows you how to create a Dropdown Menu component that accepts a few custom props that make it more capable.    import type { Snippet } from \"svelte\";  import { DropdownMenu, type WithoutChild } from \"bits-ui\";   type Props = DropdownMenu.Props & {   buttonText: string;   items: string[];   contentProps?: WithoutChild;   // other component props if needed  };   let {   open = $bindable(false),   children,   buttonText,   items,   contentProps,   ...restProps  }: Props = $props();        {buttonText}                {#each items as item}             {item}           {/each}            You can then use the MyDropdownMenu component like this:    import MyDropdownMenu from \"./MyDropdownMenu.svelte\";  Managing Open State  This section covers how to manage the open state of the menu.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { DropdownMenu } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Context Menu  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { DropdownMenu } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Groups  To group related menu items, you can use the DropdownMenu.Group component along with either a DropdownMenu.GroupHeading or an aria-label attribute on the DropdownMenu.Group component.    File  New  Open  Save  Save As     New  Open  Save  Save As  Group Heading  The DropdownMenu.GroupHeading component must be a child of either a DropdownMenu.Group or DropdownMenu.RadioGroup component. If used on its own, an error will be thrown during development.    File         Favorite color Radio Groups  You can combine the DropdownMenu.RadioGroup and DropdownMenu.RadioItem components to create a radio group within a menu.    import { DropdownMenu } from \"bits-ui\";   const values = [\"one\", \"two\", \"three\"];  let value = $state(\"one\");     Favorite number  {#each values as value}       {#snippet children({ checked })}     {#if checked}      ✅     {/if}     {value}    {/snippet}     {/each}   The value state does not persist between menu open/close cycles. To persist the state, you must store it in a $state variable and pass it to the value prop.  Checkbox Items  You can use the DropdownMenu.CheckboxItem component to create a menuitemcheckbox element to add checkbox functionality to menu items.    import { DropdownMenu } from \"bits-ui\";   let notifications = $state(true);     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {/if}   Notifications  {/snippet}   The checked state does not persist between menu open/close cycles. To persist the state, you must store it in a $state variable and pass it to the checked prop.  Checkbox Groups  You can use the DropdownMenu.CheckboxGroup component around a set of DropdownMenu.CheckboxItem components to create a checkbox group within a menu, where the value prop is an array of the selected values.    import { DropdownMenu } from \"bits-ui\";   let colors = $state([]);     Favorite color     {#snippet children({ checked })}    {#if checked}     ✅    {/if}    Red   {/snippet}       {#snippet children({ checked })}    {#if checked}     ✅    {/if}    Blue   {/snippet}       {#snippet children({ checked })}    {#if checked}     ✅    {/if}    Green   {/snippet}     The value state does not persist between menu open/close cycles. To persist the state, you must store it in a $state variable and pass it to the value prop.  Nested Menus  You can create nested menus using the DropdownMenu.Sub component to create complex menu structures.    import { DropdownMenu } from \"bits-ui\";     Item 1  Item 2     Open Sub Menu       Sub Item 1    Sub Item 2         -->  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the DropdownMenu.Content component to use Svelte Transitions or another animation library that requires more control.    import { DropdownMenu } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ wrapperProps, props, open })}   {#if open}               Item 1      Item 2            {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}  Custom Anchor  By default, the DropdownMenu.Content is anchored to the DropdownMenu.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the DropdownMenu.Content component.    import { DropdownMenu } from \"bits-ui\";  let customAnchor = $state(null!);                 ","description":"Displays a menu of items that users can select from when triggered.","href":"/docs/components/dropdown-menu"},{"title":"Label","content":"  import { APISection, ComponentPreviewV2, LabelDemo } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Label } from \"bits-ui\";     ","description":"Identifies or describes associated UI elements.","href":"/docs/components/label"},{"title":"Link Preview","content":"  import { APISection, ComponentPreviewV2, LinkPreviewDemo, LinkPreviewDemoTransition, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  A component that lets users preview a link before they decide to follow it. This is useful for providing non-essential context or additional information about a link without having to navigate away from the current page.    This component is only intended to be used with a mouse or other pointing device. It doesn't respond to touch events, and the preview content cannot be accessed via the keyboard. On touch devices, the link will be followed immediately. As it is not accessible to all users, the preview should not contain vital information.  Structure    import { LinkPreview } from \"bits-ui\";  Managing Open State  This section covers how to manage the open state of the component.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { LinkPreview } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Link Preview  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { LinkPreview } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Opt-out of Floating UI  When you use the LinkPreview.Content component, Bits UI uses $2 to position the content relative to the trigger, similar to other popover-like components.  You can opt-out of this behavior by instead using the LinkPreview.ContentStatic component. This component does not use Floating UI and leaves positioning the content entirely up to you.                The LinkPreview.Arrow component is designed to be used with Floating UI and LinkPreview.Content, so you may experience unexpected behavior if you attempt to use it with LinkPreview.ContentStatic.  Custom Anchor  By default, the LinkPreview.Content is anchored to the LinkPreview.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the LinkPreview.Content component.    import { LinkPreview } from \"bits-ui\";  let customAnchor = $state(null!);  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the LinkPreview.Content component to use Svelte Transitions or another animation library that requires more control.    import { LinkPreview } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ wrapperProps, props, open })}   {#if open}                           {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Displays a summarized preview of a linked content's details or information.","href":"/docs/components/link-preview"},{"title":"Menubar","content":"  import { APISection, ComponentPreviewV2, MenubarDemo } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Menubar } from \"bits-ui\";                                                       {#snippet children({ checked })}       {checked ? \"✅\" : \"\"}      {/snippet}                              {#snippet children({ checked })}        {checked ? \"✅\" : \"\"}       {/snippet} Reusable Components  If you're planning to use Menubar in multiple places, you can create reusable components that wrap the different parts of the Menubar.  In the following example, we're creating a reusable MyMenubarMenu component that contains the trigger, content, and items of a menu.    import { Menubar, type WithoutChildrenOrChild } from \"bits-ui\";   type Props = WithoutChildrenOrChild & {   triggerText: string;   items: { label: string; value: string; onSelect?: () => void }[];   contentProps?: WithoutChildrenOrChild;   // other component props if needed  };   let { triggerText, items, contentProps, ...restProps }: Props = $props();        {triggerText}           {#each items as item}           {item.label}         {/each}        Now, we can use the MyMenubarMenu component within a Menubar.Root component to render out the various menus.    import { Menubar } from \"bits-ui\";  import MyMenubarMenu from \"./MyMenubarMenu.svelte\";   const sales = [   { label: \"Michael Scott\", value: \"michael\" },   { label: \"Dwight Schrute\", value: \"dwight\" },   { label: \"Jim Halpert\", value: \"jim\" },   { label: \"Stanley Hudson\", value: \"stanley\" },   { label: \"Phyllis Vance\", value: \"phyllis\" },   { label: \"Pam Beesly\", value: \"pam\" },   { label: \"Andy Bernard\", value: \"andy\" },  ];   const hr = [   { label: \"Toby Flenderson\", value: \"toby\" },   { label: \"Holly Flax\", value: \"holly\" },   { label: \"Jan Levinson\", value: \"jan\" },  ];   const accounting = [   { label: \"Angela Martin\", value: \"angela\" },   { label: \"Kevin Malone\", value: \"kevin\" },   { label: \"Oscar Martinez\", value: \"oscar\" },  ];   const menubarMenus = [   { title: \"Sales\", items: sales },   { title: \"HR\", items: hr },   { title: \"Accounting\", items: accounting },  ];     {#each menubarMenus as { title, items }}     {/each}  Managing Value State  This section covers how to manage the value state of the menubar.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { Menubar } from \"bits-ui\";  let activeValue = $state(\"\");    (activeValue = \"menu-1\")}>Open Menubar Menu  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Menubar } from \"bits-ui\";  let activeValue = $state(\"\");   function getValue() {   return activeValue;  }   function setValue(newValue: string) {   activeValue = newValue;  }  Radio Groups  You can combine the Menubar.RadioGroup and Menubar.RadioItem components to create a radio group within a menu.    import { Menubar } from \"bits-ui\";   const values = [\"one\", \"two\", \"three\"];  let value = $state(\"one\");     {#each values as value}       {#snippet children({ checked })}     {#if checked}      ✅     {/if}     {value}    {/snippet}     {/each}  Checkbox Items  You can use the Menubar.CheckboxItem component to create a menuitemcheckbox element to add checkbox functionality to menu items.    import { Menubar } from \"bits-ui\";   let notifications = $state(true);     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {/if}   Notifications  {/snippet}  Checkbox Groups  You can use the Menubar.CheckboxGroup component around a set of Menubar.CheckboxItem components to create a checkbox group within a menu, where the value prop is an array of the selected values.    import { Menubar } from \"bits-ui\";   let colors = $state([]);     Favorite color     {#snippet children({ checked })}    {#if checked}     ✅    {/if}    Red   {/snippet}       {#snippet children({ checked })}    {#if checked}     ✅    {/if}    Blue   {/snippet}       {#snippet children({ checked })}    {#if checked}     ✅    {/if}    Green   {/snippet}     The value state does not persist between menu open/close cycles. To persist the state, you must store it in a $state variable and pass it to the value prop.  Nested Menus  You can create nested menus using the Menubar.Sub component to create complex menu structures.    import { Menubar } from \"bits-ui\";     Item 1  Item 2     Open Sub Menu       Sub Item 1    Sub Item 2 Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Menubar.Content component to use Svelte Transitions or another animation library that requires more control.    import { Menubar } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ wrapperProps, props, open })}   {#if open}               Item 1      Item 2            {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.  ","description":"Organizes and presents a collection of menu options or actions within a horizontal bar.","href":"/docs/components/menubar"},{"title":"Meter","content":"  import { APISection, ComponentPreviewV2, MeterDemo, DemoCodeContainer, MeterDemoCustom } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}    While often visually similar, meters and $2 bars serve distinct purposes:  Meter:  Displays a static measurement within a known range (0-100) Value can fluctuate up/down based on real-time measurements Examples: CPU usage, battery level, sound volume Use when showing current state relative to capacity  Progress bar:  Shows completion status of a task Value only increases as task progresses Examples: File upload, installation status, form completion Use when tracking advancement toward completion  If a progress bar better fits your requirements, check out the $2 component.  Structure    import { Meter } from \"bits-ui\";  Reusable Components  It's recommended to use the Meter primitive to create your own custom meter component that can be used throughout your application. In the example below, we're using the Meter primitive to create a more comprehensive meter component.    import { Meter, useId } from \"bits-ui\";  import type { ComponentProps } from \"svelte\";   let {   max = 100,   value = 0,   min = 0,   label,   valueLabel,  }: ComponentProps & {   label: string;   valueLabel: string;  } = $props();   const labelId = useId();      {label}   {valueLabel}    You can then use the MyMeter component in your application like so:    import MyMeter from \"$lib/components/MyMeter.svelte\";   let value = $state(3000);  const max = 4000;     Of course, you'd want to apply your own styles and other customizations to the MyMeter component to fit your application's design.  Accessibility  If a visual label is used, the ID of the label element should be pass via the aria-labelledby prop to Meter.Root. If no visual label is used, the aria-label prop should be used to provide a text description of the progress bar.  Assistive technologies often present aria-valuenow as a percentage. If conveying the value of the meter only in terms of a percentage would not be user friendly, the aria-valuetext property should be set to a string that makes the meter value understandable. For example, a battery meter value might be conveyed as aria-valuetext=\"50% (6 hours) remaining\". $2]  ","description":"Display real-time measurements within a defined range.","href":"/docs/components/meter"},{"title":"Navigation Menu","content":"  import { APISection, ComponentPreviewV2, NavigationMenuDemo, Callout, NavigationMenuDemoForceMount, NavigationMenuDemoNoViewport, NavigationMenuDemoNoHover } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { NavigationMenu } from \"bits-ui\";  Usage  Vertical  You can create a vertical menu by using the orientation prop.  Flexible Layouts  Use the Viewport component when you need extra control over where Content is rendered. This can be useful when your design requires an adjusted DOM structure or if you need flexibility to achieve advanced animations. Tab focus will be managed automatically.           Item one    Item one content          Item two    Item two content With Indicator  You can use the optional Indicator component to highlight the currently active Trigger, which is useful when you want to provide an animated visual cue such as an arrow or highlight to accompany the Viewport.           Item one    Item one content          Item two    Item two content Submenus  You can create a submenu by nesting your navigation menu and using the Navigation.Sub component in place of NavigationMenu.Root.           Item one                              Subitem one        Subitem one content                                {#snippet preview()}  {/snippet}   -->  Submenus with Viewport  You can use the NavigationMenu.Viewport component inside of a NavigationMenu.Sub to create a viewport dedicated to that submenu.           Item one         Item one content              Item two         Item two content No Viewport  The NavigationMenu.Viewport component provides a way to transition between NavigationMenu.Content without the need for a full close/open animation between them, however, this is completely optional and you don't need to use it.    {#snippet preview()}  {/snippet}  Advanced Animation  We expose --bits-navigation-menu-viewport-[width|height] and data-motion['from-start'|'to-start'|'from-end'|'to-end'] to allow you to animate the NavigationMenu.Viewport size and NavigationMenu.Content position based on the enter/exit direction.  Combining these with position: absolute; allows you to create smooth overlapping animation effects when moving between items.           Item one         Item one content              Item two         Item two content               /* app.css */ .NavigationMenuContent {  position: absolute;  top: 0;  left: 0;  animation-duration: 250ms;  animation-timing-function: ease; } .NavigationMenuContent[data-motion=\"from-start\"] {  animation-name: enter-from-left; } .NavigationMenuContent[data-motion=\"from-end\"] {  animation-name: enter-from-right; } .NavigationMenuContent[data-motion=\"to-start\"] {  animation-name: exit-to-left; } .NavigationMenuContent[data-motion=\"to-end\"] {  animation-name: exit-to-right; }  .NavigationMenuViewport {  position: relative;  width: var(--bits-navigation-menu-viewport-width);  height: var(--bits-navigation-menu-viewport-height);  transition:   width,   height,   250ms ease; }  @keyframes enter-from-right {  from {   opacity: 0;   transform: translateX(200px);  }  to {   opacity: 1;   transform: translateX(0);  } }  @keyframes enter-from-left {  from {   opacity: 0;   transform: translateX(-200px);  }  to {   opacity: 1;   transform: translateX(0);  } }  @keyframes exit-to-right {  from {   opacity: 1;   transform: translateX(0);  }  to {   opacity: 0;   transform: translateX(200px);  } }  @keyframes exit-to-left {  from {   opacity: 1;   transform: translateX(0);  }  to {   opacity: 0;   transform: translateX(-200px);  } }  Force Mounting  You may wish for the links in the Navigation Menu to persist in the DOM, regardless of whether the menu is open or not. This is particularly useful for SEO purposes. You can achieve this by using the forceMount prop on the NavigationMenu.Content and NavigationMenu.Viewport components.    Note: Using forceMount requires you to manage the visibility of the elements yourself, using the data-state attributes on the NavigationMenu.Content and NavigationMenu.Viewport components.         {#snippet preview()}  {/snippet}  Open on Hover  By default, the NavigationMenu.Item will open its NavigationMenu.Content when the NavigationMenu.Trigger is hovered. You can disable this by passing openOnHover={false} to the NavigationMenu.Item.    Unlike the default behavior, when openOnHover is false, the menu will not close when the pointer moves outside of the NavigationMenu.Content and will instead require the user to interact outside of the menu or press escape to close it.      Item one  Item one content     {#snippet preview()}  {/snippet}    ","description":"A list of links that allow users to navigate between pages of a website.","href":"/docs/components/navigation-menu"},{"title":"Pagination","content":"  import { APISection, ComponentPreviewV2, PaginationDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Pagination } from \"bits-ui\";       {#each pages as page (page.key)}     {/each} Managing Page State  This section covers how to manage the page state of the component.  Two-Way Binding  Use bind:page for simple, automatic state synchronization:    import { Pagination } from \"bits-ui\";  let myPage = $state(1);    (myPage = 2)}> Go to page 2   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Pagination } from \"bits-ui\";  let myPage = $state(1);   function getPage() {   return myPage;  }   function setPage(newPage: number) {   myPage = newPage;  }  Ellipsis  The pages snippet prop consists of two types of items: 'page' and 'ellipsis'. The 'page' type represents an actual page number, while the 'ellipsis' type represents a placeholder for rendering an ellipsis between pages.  ","description":"Facilitates navigation between pages.","href":"/docs/components/pagination"},{"title":"PIN Input","content":"  import { APISection, ComponentPreviewV2, PinInputDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The PIN Input component provides a customizable solution for One-Time Password (OTP), Two-Factor Authentication (2FA), or Multi-Factor Authentication (MFA) input fields. Due to the lack of a native HTML element for these purposes, developers often resort to either basic input fields or custom implementations. This component offers a robust, accessible, and flexible alternative.    This component is derived from and would not have been possible without the work done by $2 with $2.  Key Features  Invisible Input Technique**: Utilizes an invisible input element for seamless integration with form submissions and browser autofill functionality. Customizable Appearance**: Allows for custom designs while maintaining core functionality. Accessibility**: Ensures keyboard navigation and screen reader compatibility. Flexible Configuration**: Supports various PIN lengths and input types (numeric, alphanumeric).  Architecture  Root Container: A relatively positioned root element that encapsulates the entire component. Invisible Input: A hidden input field that manages the actual value and interacts with the browser's built-in features. Visual Cells: Customizable elements representing each character of the PIN, rendered as siblings to the invisible input.  This structure allows for a seamless user experience while providing developers with full control over the visual representation.  Structure    import { PinInput } from \"bits-ui\";     {#snippet children({ cells })}   {#each cells as cell}       {/each}  {/snippet}  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { PinInput } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"123456\")}> Set value to 123456   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { PinInput } from \"bits-ui\";  let myValue = $state(\"\");   function getValue() {   return myValue;  }   function setValue(newValue: string) {   myValue = newValue;  }  Paste Transformation  The pasteTransformer prop allows you to sanitize/transform pasted text. This can be useful for cleaning up pasted text, like removing hyphens or other characters that should not make it into the input. This function should return the sanitized text, which will be used as the new value of the input.    import { PinInput } from \"bits-ui\";    text.replace(/-/g, \"\")}> HTML Forms  The PinInput.Root component is designed to work seamlessly with HTML forms. Simply pass the name prop to the PinInput.Root component and the input will be submitted with the form.  Submit On Complete  To submit the form when the input is complete, you can use the onComplete prop.    import { PinInput } from \"bits-ui\";  let form = $state(null!);      form.submit()}> Patterns  You can use the pattern prop to restrict the characters that can be entered or pasted into the input.   Client-side validation cannot replace server-side validation. Use this in addition to server-side validation for an improved user experience.   Bits UI exports a few common patterns that you can import and use in your application.  REGEXP_ONLY_DIGITS - Only allow digits to be entered. REGEXP_ONLY_CHARS - Only allow characters to be entered. REGEXP_ONLY_DIGITS_AND_CHARS - Only allow digits and characters to be entered.    import { PinInput, REGEXP_ONLY_DIGITS } from \"bits-ui\";        ","description":"Allows users to input a sequence of one-character alphanumeric inputs.","href":"/docs/components/pin-input"},{"title":"Popover","content":"  import { APISection, ComponentPreviewV2, PopoverDemo, PopoverDemoTransition, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Popover } from \"bits-ui\";  Managing Open State  This section covers how to manage the open state of the component.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { Popover } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Popover  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Popover } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Managing Focus  Focus Trap  By default, when a Popover is opened, focus will be trapped within that Popover. You can disable this behavior by setting the trapFocus prop to false on the Popover.Content component.  Open Focus  By default, when a Popover is opened, focus will be set to the first focusable element with the Popover.Content. This ensures that users navigating my keyboard end up somewhere within the Popover that they can interact with.  You can override this behavior using the onOpenAutoFocus prop on the Popover.Content component. It's highly recommended that you use this prop to focus something within the Popover's content.  You'll first need to cancel the default behavior of focusing the first focusable element by cancelling the event passed to the onOpenAutoFocus callback. You can then focus whatever you wish.    import { Popover } from \"bits-ui\";  let nameInput = $state();     Open Popover   {    e.preventDefault();    nameInput?.focus();   }} Close Focus  By default, when a Popover is closed, focus will be set to the trigger element of the Popover. You can override this behavior using the onCloseAutoFocus prop on the Popover.Content component.  You'll need to cancel the default behavior of focusing the trigger element by cancelling the event passed to the onCloseAutoFocus callback, and then focus whatever you wish.    import { Popover } from \"bits-ui\";  let nameInput = $state();      Open Popover   {    e.preventDefault();    nameInput?.focus();   }} Scroll Lock  By default, when a Popover is opened, users can still scroll the body and interact with content outside of the Popover. If you wish to lock the body scroll and prevent users from interacting with content outside of the Popover, you can set the preventScroll prop to true on the Popover.Content component.  Escape Keydown  By default, when a Popover is open, pressing the Escape key will close the dialog. Bits UI provides a couple ways to override this behavior.  escapeKeydownBehavior  You can set the escapeKeydownBehavior prop to 'ignore' on the Popover.Content component to prevent the dialog from closing when the Escape key is pressed.  onEscapeKeydown  You can also override the default behavior by cancelling the event passed to the onEscapeKeydown callback on the Popover.Content component.   e.preventDefault()}> Interact Outside  By default, when a Popover is open, pointer down events outside the content will close the popover. Bits UI provides a couple ways to override this behavior.  interactOutsideBehavior  You can set the interactOutsideBehavior prop to 'ignore' on the Popover.Content component to prevent the dialog from closing when the user interacts outside the content.  onInteractOutside  You can also override the default behavior by cancelling the event passed to the onInteractOutside callback on the Popover.Content component.   e.preventDefault()}> Custom Anchor  By default, the Popover.Content is anchored to the Popover.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the Popover.Content component.    import { Popover } from \"bits-ui\";  let customAnchor = $state(null!);  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Popover.Content component to use Svelte Transitions or another animation library that requires more control.    import { Popover } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ wrapperProps, props, open })}   {#if open}                           {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Display supplementary content or information when users interact with specific elements.","href":"/docs/components/popover"},{"title":"Progress","content":"  import { APISection, ComponentPreviewV2, ProgressDemo, ProgressDemoCustom } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}    While often visually similar, progress bars and $2 serve distinct purposes:  Progress:  Shows completion status of a task Value only increases as task progresses Examples: File upload, installation status, form completion Use when tracking advancement toward completion  Meter:  Displays a static measurement within a known range (0-100) Value can fluctuate up/down based on real-time measurements Examples: CPU usage, battery level, sound volume Use when showing current state relative to capacity  If a meter better fits your requirements, check out the $2 component.  Structure    import { Progress } from \"bits-ui\";  Reusable Components  It's recommended to use the Progress primitive to create your own custom meter component that can be used throughout your application. In the example below, we're using the Progress primitive to create a more comprehensive meter component.    import { Progress, useId } from \"bits-ui\";  import type { ComponentProps } from \"svelte\";   let {   max = 100,   value = 0,   min = 0,   label,   valueLabel,  }: ComponentProps & {   label: string;   valueLabel: string;  } = $props();   const labelId = useId();      {label}   {valueLabel}    You can then use the MyProgress component in your application like so:    import MyProgress from \"$lib/components/MyProgress.svelte\";   let value = $state(50);     Of course, you'd want to apply your own styles and other customizations to the MyProgress component to fit your application's design.  Accessibility  If a visual label is used, the ID of the label element should be pass via the aria-labelledby prop to Progress.Root. If no visual label is used, the aria-label prop should be used to provide a text description of the progress bar.  ","description":"Visualizes the progress or completion status of a task or process.","href":"/docs/components/progress"},{"title":"Radio Group","content":"  import { APISection, ComponentPreviewV2, RadioGroupDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { RadioGroup } from \"bits-ui\";        {#snippet children({ checked })}    {#if checked}     ✅    {/if}   {/snippet} Reusable Components  It's recommended to use the RadioGroup primitives to create your own custom components that can be used throughout your application.  In the example below, we're creating a custom MyRadioGroup component that takes in an array of items and renders a radio group with those items along with a $2 component for each item.    import { RadioGroup, Label, type WithoutChildrenOrChild, useId } from \"bits-ui\";   type Item = {   value: string;   label: string;   disabled?: boolean;  };   type Props = WithoutChildrenOrChild & {   items: Item[];  };   let { value = $bindable(\"\"), ref = $bindable(null), items, ...restProps }: Props = $props();     {#each items as item}   {@const id = useId()}            {#snippet children({ checked })}      {#if checked}       ✅      {/if}     {/snippet}        {item.label}     {/each}   You can then use the MyRadioGroup component in your application like so:    import MyRadioGroup from \"$lib/components/MyRadioGroup.svelte\";   const myItems = [   { value: \"apple\", label: \"Apple\" },   { value: \"banana\", label: \"Banana\" },   { value: \"coconut\", label: \"Coconut\", disabled: true },  ];  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { RadioGroup } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"A\")}> Select A   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { RadioGroup } from \"bits-ui\";  let myValue = $state(\"\");   function getValue() {   return myValue;  }   function setValue(newValue: string) {   myValue = newValue;  }  HTML Forms  If you set the name prop on the RadioGroup.Root component, a hidden input element will be rendered to submit the value of the radio group to a form.  Required  To make the hidden input element required you can set the required prop on the RadioGroup.Root component.  Disabling Items  You can disable a radio group item by setting the disabled prop to true.  Apple  Orientation  The orientation prop is used to determine the orientation of the radio group, which influences how keyboard navigation will work.  When the orientation is set to 'vertical', the radio group will navigate through the items using the ArrowUp and ArrowDown keys. When the orientation is set to 'horizontal', the radio group will navigate through the items using the ArrowLeft and ArrowRight keys.            ","description":"Allows users to select a single option from a list of mutually exclusive choices.","href":"/docs/components/radio-group"},{"title":"Range Calendar","content":"  import { APISection, ComponentPreviewV2, RangeCalendarDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Structure    import { RangeCalendar } from \"bits-ui\";     {#snippet children({ months, weekdays })}                     {#each months as month}                      {#each weekdays as day}                 {day}               {/each}                      {#each month.weeks as weekDates}               {#each weekDates as date}                                    {/each}             {/each}            {/each}  {/snippet}   ","description":"Presents a calendar view tailored for selecting date ranges.","href":"/docs/components/range-calendar"},{"title":"Scroll Area","content":"  import { APISection, ComponentPreviewV2, ScrollAreaDemo, ScrollAreaDemoCustom } from '$lib/components'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { ScrollArea } from \"bits-ui\";  Reusable Components  If you're planning to use the Scroll Area throughout your application, it's recommended to create a reusable component to reduce the amount of code you need to write each time.  This example shows you how to create a Scroll Area component that accepts a few custom props that make it more capable.    import { ScrollArea, type WithoutChild } from \"bits-ui\";   type Props = WithoutChild & {   orientation: \"vertical\" | \"horizontal\" | \"both\";   viewportClasses?: string;  };   let {   ref = $bindable(null),   orientation = \"vertical\",   viewportClasses,   children,   ...restProps  }: Props = $props();   {#snippet Scrollbar({ orientation }: { orientation: \"vertical\" | \"horizontal\" })}        {/snippet}       {@render children?.()}    {#if orientation === \"vertical\" || orientation === \"both\"}   {@render Scrollbar({ orientation: \"vertical\" })}  {/if}  {#if orientation === \"horizontal\" || orientation === \"both\"}   {@render Scrollbar({ orientation: \"horizontal\" })}  {/if}     We'll use this custom component in the following examples to demonstrate how to customize the behavior of the Scroll Area.  Scroll Area Types  Hover  The hover type is the default type of the scroll area, demonstrated in the featured example above. It only shows scrollbars when the user hovers over the scroll area and the content is larger than the viewport.  Scroll  The scroll type displays the scrollbars when the user scrolls the content. This is similar to the behavior of MacOS.  Auto  The auto type behaves similarly to your typical browser scrollbars. When the content is larger than the viewport, the scrollbars will appear and remain visible at all times.  Always  The always type behaves as if you set overflow: scroll on the scroll area. Scrollbars will always be visible, even when the content is smaller than the viewport. We've also set the orientation prop on the MyScrollArea to 'both' to ensure both scrollbars are rendered.  Customizing the Hide Delay  You can customize the hide delay of the scrollbars using the scrollHideDelay prop.         ","description":"Provides a consistent scroll area across platforms.","href":"/docs/components/scroll-area"},{"title":"Select","content":"  import { APISection, ComponentPreviewV2, SelectDemo, SelectDemoCustomAnchor, SelectDemoMultiple, SelectDemoTransition, SelectDemoAutoScrollDelay, Callout } from '$lib/components'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The Select component provides users with a selectable list of options. It's designed to offer an enhanced selection experience with features like typeahead search, keyboard navigation, and customizable grouping. This component is particularly useful for scenarios where users need to choose from a predefined set of options, offering more functionality than a standard select element.  Key Features  Typeahead Search**: Users can quickly find options by typing Keyboard Navigation**: Full support for keyboard interactions, allowing users to navigate through options using arrow keys, enter to select, and more. Grouped Options**: Ability to organize options into logical groups, enhancing readability and organization of large option sets. Scroll Management**: Includes scroll up/down buttons for easy navigation in long lists. Accessibility**: Built-in ARIA attributes and keyboard support ensure compatibility with screen readers and adherence to accessibility standards. Portal Support**: Option to render the select content in a portal, preventing layout issues in complex UI structures.  Architecture  The Select component is composed of several sub-components, each with a specific role:  Root**: The main container component that manages the state and context for the combobox. Trigger**: The button or element that opens the dropdown list. Portal**: Responsible for portalling the dropdown content to the body or a custom target. Group**: A container for grouped items, used to group related items. GroupHeading**: A heading for a group of items, providing a descriptive label for the group. Item**: An individual item within the list. Separator**: A visual separator between items. Content**: The dropdown container that displays the items. It uses $2 to position the content relative to the trigger. ContentStatic** (Optional): An alternative to the Content component, that enables you to opt-out of Floating UI and position the content yourself. Viewport**: The visible area of the dropdown content, used to determine the size and scroll behavior. ScrollUpButton**: A button that scrolls the content up when the content is larger than the viewport. ScrollDownButton**: A button that scrolls the content down when the content is larger than the viewport. Arrow**: An arrow element that points to the trigger when using the Combobox.Content component.  Structure  Here's an overview of how the Select component is structured in code:    import { Select } from \"bits-ui\";  Reusable Components  As you can see from the structure above, there are a number of pieces that make up the Select component. These pieces are provided to give you maximum flexibility and customization options, but can be a burden to write out everywhere you need to use a select in your application.  To ease this burden, it's recommended to create your own reusable select component that wraps the primitives and provides a more convenient API for your use cases.  Here's an example of how you might create a reusable MySelect component that receives a list of options and renders each of them as an item.    import { Select, type WithoutChildren } from \"bits-ui\";   type Props = WithoutChildren & {   placeholder?: string;   items: { value: string; label: string; disabled?: boolean }[];   contentProps?: WithoutChildren;   // any other specific component props if needed  };   let { value = $bindable(), items, contentProps, placeholder, ...restProps }: Props = $props();   const selectedLabel = $derived(items.find((item) => item.value === value)?.label);         {selectedLabel ? selectedLabel : placeholder}           up         {#each items as { value, label, disabled } (value)}             {#snippet children({ selected })}        {selected ? \"✅\" : \"\"}        {label}       {/snippet}           {/each}        down        You can then use the MySelect component throughout your application like so:    import MySelect from \"$lib/components/MySelect.svelte\";   const items = [   { value: \"apple\", label: \"Apple\" },   { value: \"banana\", label: \"Banana\" },   { value: \"cherry\", label: \"Cherry\" },  ];   let fruit = $state(\"apple\");  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { Select } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"A\")}> Select A   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Select } from \"bits-ui\";  let myValue = $state(\"\");   function getValue() {   return myValue;  }   function setValue(newValue: string) {   myValue = newValue;  }  Managing Open State  This section covers how to manage the open state of the component.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { Select } from \"bits-ui\";  let myOpen = $state(false);    (myOpen = true)}> Open   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Select } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Multiple Selection  The type prop can be set to 'multiple' to allow multiple items to be selected at a time.    import { Select } from \"bits-ui\";   let value = $state([]);          {#snippet preview()}  {/snippet}  Opt-out of Floating UI  When you use the Select.Content component, Bits UI uses $2 to position the content relative to the trigger, similar to other popover-like components.  You can opt-out of this behavior by instead using the Select.ContentStatic component.                                                             When using this component, you'll need to handle the positioning of the content yourself. Keep in mind that using Select.Portal alongside Select.ContentStatic may result in some unexpected positioning behavior, feel free to not use the portal or work around it.  Custom Anchor  By default, the Select.Content is anchored to the Select.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the Select.Content component.    import { Select } from \"bits-ui\";   let customAnchor = $state(null!);  What is the Viewport?  The Select.Viewport component is used to determine the size of the content in order to determine whether or not the scroll up and down buttons should be rendered.  If you wish to set a minimum/maximum height for the select content, you should apply it to the Select.Viewport component.  Scroll Up/Down Buttons  The Select.ScrollUpButton and Select.ScrollDownButton components are used to render the scroll up and down buttons when the select content is larger than the viewport.  You must use the Select.Viewport component when using the scroll buttons.  Custom Scroll Delay  The initial and subsequent scroll delays can be controlled using the delay prop on the buttons.  For example, we can use the $2 easing function from Svelte to create a smooth scrolling effect that speeds up over time.    {#snippet preview()}  {/snippet}  Native Scrolling/Overflow  If you don't want to use the $2 and prefer to use the standard scrollbar/overflow behavior, you can omit the Select.Scroll[Up|Down]Button components and the Select.Viewport component.  You'll need to set a height on the Select.Content component and appropriate overflow styles to enable scrolling.  Scroll Lock  By default, when a user opens the select, scrolling outside the content will not be disabled. You can override this behavior by setting the preventScroll prop to true.  Highlighted Items  The Select component follows the $2 for highlighting items. This means that the Select.Trigger retains focus the entire time, even when navigating with the keyboard, and items are highlighted as the user navigates them.  Styling Highlighted Items  You can use the data-highlighted attribute on the Select.Item component to style the item differently when it is highlighted.  onHighlight / onUnhighlight  To trigger side effects when an item is highlighted or unhighlighted, you can use the onHighlight and onUnhighlight props.   console.log('I am highlighted!')} onUnhighlight={() => console.log('I am unhighlighted!')} />  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Select.Content component to use Svelte Transitions or another animation library that requires more control.    import { Select } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ wrapperProps, props, open })}   {#if open}                           {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Enables users to choose from a list of options presented in a dropdown.","href":"/docs/components/select"},{"title":"Separator","content":"  import { APISection, ComponentPreviewV2, SeparatorDemo } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Separator } from \"bits-ui\";     ","description":"Visually separates content or UI elements for clarity and organization.","href":"/docs/components/separator"},{"title":"Slider","content":"  import { APISection, ComponentPreviewV2, SliderDemo, SliderDemoMultiple, SliderDemoTicks, SliderDemoCustomSteps, SliderDemoTickLabels, SliderDemoThumbLabels, SliderDemoVertical } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Slider } from \"bits-ui\";  Reusable Components  Bits UI provides primitives that enable you to build your own custom slider component that can be reused throughout your application.  Here's an example of how you might create a reusable MySlider component.    import type { ComponentProps } from \"svelte\";  import { Slider } from \"bits-ui\";   type Props = WithoutChildren>;   let { value = $bindable(), ref = $bindable(null), ...restProps }: Props = $props();      {#snippet children({ thumbs, ticks })}      {#each thumbs as index}       {/each}    {#each ticks as index}       {/each}  {/snippet}   You can then use the MySlider component in your application like so:    import MySlider from \"$lib/components/MySlider.svelte\";   let multiValue = $state([5, 10]);  let singleValue = $state(50);  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { Slider } from \"bits-ui\";  let myValue = $state(0);    (myValue = 20)}> Set value to 20   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Slider } from \"bits-ui\";  let myValue = $state(0);   function getValue() {   return myValue;  }   function setValue(newValue: number) {   myValue = newValue;  }  Value Commit  You can use the onValueCommit prop to be notified when the user finishes dragging the thumb and the value changes. This is different than the onValueChange callback because it waits until the user stops dragging before calling the callback, where the onValueChange callback is called as the user dragging.   {   console.log(\"user is done sliding!\", v);  }} />  RTL Support  You can use the dir prop to change the reading direction of the slider, which defaults to \"ltr\".  Auto Sort  By default, the slider will sort the values from smallest to largest, so if you drag a smaller thumb to a larger value, the value of that thumb will be updated to the larger value.  You can disable this behavior by setting the autoSort prop to false.  HTML Forms  Since there is a near endless number of possible values that a user can select, the slider does not render a hidden input element by default.  You'll need to determine how you want to submit the value(s) of the slider with a form.  Here's an example of how you might do that:    import MySlider from \"$lib/components/MySlider.svelte\";   let expectedIncome = $state([50, 100]);  let desiredIncome = $state(50);               Submit  Examples  Multiple Thumbs and Ticks  If the value prop has more than one value, the slider will render multiple thumbs. You can also use the tickItems and thumbItems snippet props to render ticks and thumbs at specific intervals.    import { Slider } from \"bits-ui\";   // we have two numbers in the array, so the slider will render two thumbs  let value = $state([5, 7]);     {#snippet children({ tickItems, thumbItems })}       {#each thumbItems as { index } (index)}       {/each}    {#each tickItems as { index } (index)}       {/each}  {/snippet}   To determine the number of ticks that will be rendered, you can simply divide the max value by the step value.    {#snippet preview()}  {/snippet}  Single Type  Set the type prop to \"single\" to allow only one slider handle.      {#snippet preview()}  {/snippet}  Multiple Type  Set the type prop to \"multiple\" to allow multiple slider handles.      {#snippet preview()}  {/snippet}  Vertical Orientation  You can use the orientation prop to change the orientation of the slider, which defaults to \"horizontal\".         {#snippet preview()}  {/snippet}  Tick Labels  You can use the tickItems snippet prop in combination with the Slider.TickLabel to render labels at specific intervals.    {#snippet children({ tickItems })}   {#each tickItems as { value, index } (index)}             {value}       {/each}  {/snippet}     {#snippet preview()}  {/snippet}  Discrete Steps  Instead of passing a single value to the step prop, you can pass an array of discrete values that the slider will snap to.         {#snippet preview()}  {/snippet}  Thumb Labels  Use the Slider.ThumbLabel component to render a label that is positioned relative to the thumb.  You can manually specify the index like so:        Min    Max   or use the thumbItems snippet prop to render a label for each thumb:      {#snippet children({ thumbItems })}   {#each thumbItems as { index, value } (index)}             {index === 0 ? \"Min\" : \"Max\"}:{value}       {/each}  {/snippet}     {#snippet preview()}  {/snippet}    ","description":"Allows users to select a value from a continuous range by sliding a handle.","href":"/docs/components/slider"},{"title":"Switch","content":"  import { APISection, ComponentPreviewV2, SwitchDemo, SwitchDemoCustom, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Overview  The Switch component provides an intuitive and accessible toggle control, allowing users to switch between two states, typically \"on\" and \"off\". This component is commonly used for enabling or disabling features, toggling settings, or representing boolean values in forms. The Switch offers a more visual and interactive alternative to traditional checkboxes for binary choices.  Key Features  Accessibility**: Built with WAI-ARIA guidelines in mind, ensuring keyboard navigation and screen reader support. State Management**: Internally manages the on/off state, with options for controlled and uncontrolled usage. Style-able**: Data attributes allow for smooth transitions between states and custom styles. HTML Forms**: Can render a hidden input element for form submissions.  Architecture  The Switch component is composed of two main parts:  Root**: The main container component that manages the state and behavior of the switch. Thumb**: The \"movable\" part of the switch that indicates the current state.  Structure  Here's an overview of how the Switch component is structured in code:    import { Switch } from \"bits-ui\";  Reusable Components  It's recommended to use the Switch primitives to create your own custom switch component that can be used throughout your application.  In the example below, we're using the Checkbox and $2 components to create a custom switch component.    import { Switch, Label, useId, type WithoutChildrenOrChild } from \"bits-ui\";   let {   id = useId(),   checked = $bindable(false),   ref = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   labelText: string;  } = $props();       {labelText}  You can then use the MySwitch component in your application like so:    import MySwitch from \"$lib/components/MySwitch.svelte\";   let notifications = $state(true);  Managing Checked State  This section covers how to manage the checked state of the component.  Two-Way Binding  Use bind:checked for simple, automatic state synchronization:    import { Switch } from \"bits-ui\";  let myChecked = $state(true);    (myChecked = false)}> uncheck   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Switch } from \"bits-ui\";  let myChecked = $state(false);   function getChecked() {   return myChecked;  }   function setChecked(newChecked: boolean) {   myChecked = newChecked;  }  Disabled State  You can disable the switch by setting the disabled prop to true.  HTML Forms  If you pass the name prop to Switch.Root, a hidden input element will be rendered to submit the value of the switch to a form.  By default, the input will be submitted with the default checkbox value of 'on' if the switch is checked.  Custom Input Value  If you'd prefer to submit a different value, you can use the value prop to set the value of the hidden input.  For example, if you wanted to submit a string value, you could do the following:  Required  If you want to make the switch required, you can use the required prop.       This will apply the required attribute to the hidden input element, ensuring that proper form submission is enforced.  ","description":"A toggle control enabling users to switch between \"on\" and \"off\" states.","href":"/docs/components/switch"},{"title":"Tabs","content":"  import { APISection, ComponentPreviewV2, TabsDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Tabs } from \"bits-ui\";  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { Tabs } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"tab-1\")}> Activate tab 1   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Tabs } from \"bits-ui\";  let myValue = $state(\"\");   function getValue() {   return myValue;  }   function setValue(newValue: string) {   myValue = newValue;  }  Orientation  The orientation prop is used to determine the orientation of the Tabs component, which influences how keyboard navigation will work.  When the orientation is set to 'horizontal', the ArrowLeft and ArrowRight keys will move the focus to the previous and next tab, respectively. When the orientation is set to 'vertical', the ArrowUp and ArrowDown keys will move the focus to the previous and next tab, respectively.  Activation Mode  By default, the Tabs component will automatically activate the tab associated with a trigger when that trigger is focused. This behavior can be disabled by setting the activationMode prop to 'manual'.  When set to 'manual', the user will need to activate the tab by pressing the trigger.       ","description":"Organizes content into distinct sections, allowing users to switch between them.","href":"/docs/components/tabs"},{"title":"Time Field","content":"  import { CalendarDateTime, CalendarDate, now, getLocalTimeZone, parseDateTime, today, Time } from \"@internationalized/date\";  import { APISection, ComponentPreviewV2, TimeFieldDemo, TimeFieldDemoCustom, DemoContainer, Callout } from '$lib/components/index.js'  import { toast } from 'svelte-sonner';  let { schemas } = $props()     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Overview  The TimeField component is an alternative to the native `` element. It provides a more flexible and customizable way to select times within a designated field.  Structure    import { TimeField } from \"bits-ui\";     Check-in time     {#snippet children({ segments })}    {#each segments as { part, value }}           {value}         {/each}   {/snippet} Reusable Components  It's recommended to use the TimeField primitives to build your own custom time field component that can be used throughout your application.  The following example shows how you might create a reusable MyTimeField component that can be used throughout your application. For style inspiration, reference the featured demo at the top of this page.    import type { TimeValue } from \"bits-ui\";  import type { Time } from \"@internationalized/date\";   type T = unknown;     import { TimeField, type WithoutChildrenOrChild } from \"bits-ui\";   let {   value = $bindable(),   placeholder = $bindable(),   labelText = \"Select a time\",   ...restProps  }: WithoutChildrenOrChild> & {   name?: string;   labelText?: string;  } = $props();     {labelText}     {#snippet children({ segments })}    {#each segments as { part, value }}           {value}         {/each}   {/snippet}       {#snippet preview()}  {/snippet}    We'll be using this newly created MyTimeField component in the following demos and examples to prevent repeating the same code, so be sure to reference it as you go through the documentation.  Segments  A segment of the TimeField represents a not only a specific part of the time, such as the hour, minute, second, dayPeriod, or timeZoneName, but can also reference a \"literal\" which is typically a separator between the different parts of the time, and varies based on the locale.  Notice that in the MyTimeField component we created, we're styling the TimeField.Segment components differently based on whether they are a \"literal\" or not.  Placeholder  The placeholder prop for the TimeField.Root component isn't what is displayed when the field is empty, but rather what time our field should start with when the user attempts to cycle through the segments.  By default, the placeholder will be set to 12:00 AM or 00:00 depending on the hour cycle.    import MyTimeField from \"$lib/components/MyTimeField.svelte\";  import { Time } from \"@internationalized/date\";          If we're collecting a time from the user where we want the timezone to be displayed as well, we can use a ZonedDateTime object instead.    import MyTimeField from \"$lib/components/MyTimeField.svelte\";  import { now, getLocalTimeZone } from \"@internationalized/date\";  Managing Placeholder State  This section covers how to manage the placeholder state of the Time Field.  Two-Way Binding  Use bind:placeholder for simple, automatic state synchronization:    import { TimeField } from \"bits-ui\";  import { Time } from \"@internationalized/date\";  let myPlaceholder = $state(new Time(12, 30));    (myPlaceholder = new Time(12, 30))}> Set placeholder to 12:30 PM   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { TimeField, type TimeValue } from \"bits-ui\";  let myPlaceholder = $state();   function getPlaceholder() {   return myPlaceholder;  }   function setPlaceholder(newPlaceholder: TimeValue) {   myPlaceholder = newPlaceholder;  }  Managing Value State  This section covers how to manage the value state of the Time Field. The value can be a Time, CalendarDateTime, or ZonedDateTime object, and the type in the value/onValueChange prop will be inferred based on the type of the value prop.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { TimeField } from \"bits-ui\";  import { Time } from \"@internationalized/date\";  let myValue = $state(new Time(12, 30));    (myValue = myValue.add({ hours: 1 }))}> Add 1 hour   Fully Controlled  For complete control over the component's state, use a $2 to manage the value state externally.    import { TimeField, type TimeValue } from \"bits-ui\";  let myValue = $state();   function getValue() {   return myValue;  }   function setValue(newValue: TimeValue | undefined) {   myValue = newValue;  }  Default Value  Often, you'll want to start the TimeField.Root component with a default value. Likely this value will come from a database in the format of an ISO 8601 string. You can use the parseDateTime function from the @internationalized/date package to parse the string into a CalendarDateTime object.    import { TimeField } from \"bits-ui\";  import { parseDateTime } from \"@internationalized/date\";   // this came from a database/API call  const date = \"2024-08-03T15:15\";   let value = $state(parseDateTime(date));             Now our input is populated with the default value. In addition to the parseDateTime function, you can also use parseZonedDateTime to parse the string into a ZonedDateTime object if you're working with a timezone.  Validation  Minimum Value  You can set a minimum value for the TimeField.Root component by using the minValue prop. If a user selects a time that is less than the minimum value, the time field will be marked as invalid.    import MyTimeField from \"$lib/components/MyTimeField.svelte\";  import { Time } from \"@internationalized/date\";          In the example above, we're setting the minimum value to 9:00 AM, and the default value to 8:00 AM. This causes the time field to be marked as invalid, and we can style it accordingly. If you adjust the time to be greater than the minimum value, the invalid state will be cleared.  Maximum Value  You can set a maximum value for the TimeField.Root component by using the maxValue prop. If a user selects a time that is greater than the maximum value, the time field will be marked as invalid.    import MyTimeField from \"$lib/components/MyTimeField.svelte\";  import { Time } from \"@internationalized/date\";          In the example above, we're setting the maximum value to 5:00 PM, and the default value to 6:00 PM. This causes the time field to be marked as invalid, and we can style it accordingly. If you adjust the time to be less than the maximum value, the invalid state will be cleared.  Custom Validation  You can use the validate prop to provide a custom validation function for the time field. This function should return a string or array of strings as validation errors if the time is invalid, or undefined/nothing if the time is valid.  The strings are then passed to the onInvalid callback, which you can use to display an error message to the user.    import MyTimeField from \"$lib/components/MyTimeField.svelte\";  import type { TimeValue } from \"bits-ui\";  import { Time } from \"@internationalized/date\";  import { toast } from \"your-favorite-toast-library\";   const value = new Time(12, 30);   function validate(time: TimeValue) {   return time.hour === 12 ? \"Time cannot be 12:00 PM\" : undefined;  }   function onInvalid(reason: \"min\" | \"max\" | \"custom\", msg?: string | string[]) {   if (reason === \"custom\") {    if (typeof msg === \"string\") {     // do something with the error message     toast.error(msg);     return;    } else if (Array.isArray(msg)) {     // do something with the error messages     toast.error(msg.join(\", \"));     return;    }    toast.error(\"The time is invalid\");   } else if (reason === \"min\") {    // let the user know that the date is too early.    toast.error(\"The time is too early.\");   } else if (reason === \"max\") {    // let the user know that the date is too late.    toast.error(\"The date is too late.\");   }  }        time.hour === 12 && time.minute === 0 ? \"Time cannot be 12:00 PM\" : undefined} onInvalid={(reason, msg) => {   if (reason === \"custom\") {    if (typeof msg === \"string\") {     toast.error(msg);     return;    } else if (Array.isArray(msg)) {     toast.error(msg.join(\", \"));     return;    }    toast.error(\"The time is invalid\");   } else if (reason === \"min\") {    toast.error(\"The time must be after 9:00 AM\");   } else if (reason === \"max\") {    toast.error(\"The time must be before 5:00 PM\");   }  }} />  Granularity  The granularity prop sets the granularity of the date field, which determines which segments are rendered in the date field. The granularity can be set to either 'hour', 'minute', or 'second' and defaults to 'minute'.    import MyTimeField from \"$lib/components/MyTimeField.svelte\";  import { Time } from \"@internationalized/date\";   const value = new Time(12, 30);          In the example above, we're setting the granularity to 'second', which means that the time field will include an additional segment for the seconds.  Localization  You can use the locale prop to set the locale of the date field. This will affect the formatting of the date field's segments and placeholders.    import MyTimeField from \"$lib/components/MyTimeField.svelte\";          Notice how in the example above, the hour is displayed as 13 (in 24-hour format) and the day period is not displayed, since the locale is set to de (German).  ","description":"Enables users to input a time within a designated field.","href":"/docs/components/time-field"},{"title":"Time Range Field","content":"  import { APISection, ComponentPreviewV2, DateRangeFieldDemo, TimeRangeFieldDemo, Callout } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Overview  The TimeRangeField component combines two $2 components to create a time range field. Check out the $2 component documentation for information on how to customize this component.  Structure    import { TimeRangeField } from \"bits-ui\";     Working Hours  {#each [\"start\", \"end\"] as const as type}       {#snippet children({ segments })}     {#each segments as { part, value }}             {value}           {/each}    {/snippet}     {/each}  Managing Placeholder State  This section covers how to manage the placeholder state of the component.  Two-Way Binding  Use bind:placeholder for simple, automatic state synchronization:    import { TimeRangeField } from \"bits-ui\";  import { Time } from \"@internationalized/date\";  let myPlaceholder = $state(new Time(12, 30));  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { TimeRangeField, type TimeValue } from \"bits-ui\";  import { Time } from \"@internationalized/date\";  let myPlaceholder = $state(new Time(12, 30));   function getPlaceholder() {   return myPlaceholder;  }   function setPlaceholder(newPlaceholder: TimeValue) {   myPlaceholder = newPlaceholder;  }  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { TimeRangeField, type TimeRange } from \"bits-ui\";  import { Time } from \"@internationalized/date\";  let myValue = $state({   start: new Time(12, 30),   end: new Time(12, 30),  });    {   myValue = {    start: myValue.start.add({ hours: 1 }),    end: myValue.end.add({ hours: 1 }),   };  }}  Add 1 hour  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { TimeRangeField, type TimeRange } from \"bits-ui\";   let myValue = $state({   start: undefined,   end: undefined,  });   function getValue() {   return myValue;  }   function setValue(newValue: TimeRange | undefined) {   myValue = newValue;  }        ","description":"Allows users to input a range of times within a designated field.","href":"/docs/components/time-range-field"},{"title":"Toggle Group","content":"  import { APISection, ComponentPreviewV2, ToggleGroupDemo } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { ToggleGroup } from \"bits-ui\";     bold  italic  Single & Multiple  The ToggleGroup component supports two type props, 'single' and 'multiple'. When the type is set to 'single', the ToggleGroup will only allow a single item to be selected at a time, and the type of the value prop will be a string.  When the type is set to 'multiple', the ToggleGroup will allow multiple items to be selected at a time, and the type of the value prop will be an array of strings.  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { ToggleGroup } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"item-1\")}> Press item 1   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { ToggleGroup } from \"bits-ui\";  let myValue = $state(\"\");   function getValue() {   return myValue;  }   function setValue(newValue: string) {   myValue = newValue;  }        ","description":"Groups multiple toggle controls, allowing users to enable one or multiple options.","href":"/docs/components/toggle-group"},{"title":"Toggle","content":"  import { APISection, ComponentPreviewV2, ToggleDemo } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Toggle } from \"bits-ui\";  Managing Pressed State  This section covers how to manage the pressed state of the component.  Two-Way Binding  Use bind:pressed for simple, automatic state synchronization:    import { Toggle } from \"bits-ui\";  let myPressed = $state(true);    (myPressed = false)}> un-press   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Toggle } from \"bits-ui\";  let myPressed = $state(false);   function getPressed() {   return myPressed;  }   function setPressed(newPressed: boolean) {   myPressed = newPressed;  }        ","description":"A control element that switches between two states, providing a binary choice.","href":"/docs/components/toggle"},{"title":"Toolbar","content":"  import { APISection, ComponentPreviewV2, ToolbarDemo } from '$lib/components/index.js'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Toolbar } from \"bits-ui\";  Managing Value State  This section covers how to manage the value state of the component.  Two-Way Binding  Use bind:value for simple, automatic state synchronization:    import { Toolbar } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"item-1\")}> Press item 1   Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Toolbar } from \"bits-ui\";  let myValue = $state(\"\");   function getValue() {   return myValue;  }   function setValue(newValue: string) {   myValue = newValue;  }             ","description":"Displays frequently used actions or tools in a compact, easily accessible bar.","href":"/docs/components/toolbar"},{"title":"Tooltip","content":"  import { ComponentPreviewV2, TooltipDemo, TooltipDemoCustom, TooltipDemoCustomAnchor, TooltipDemoDelayDuration, TooltipDemoTransition, APISection, Callout } from '$lib/components'  let { schemas } = $props()     {#snippet preview()}  {/snippet}  Structure    import { Tooltip } from \"bits-ui\";  Provider Component  The Tooltip.Provider component is required to be an ancestor of the Tooltip.Root component. It provides shared state for the tooltip components used within it. You can set a single delayDuration or disableHoverableContent prop on the provider component to apply to all the tooltip components within it.    import { Tooltip } from \"bits-ui\";                                                              It also ensures that only a single tooltip within the same provider can be open at a time. It's recommended to wrap your root layout content with the provider component, setting your sensible default props there.    import { Tooltip } from \"bits-ui\";  let { children } = $props();     {@render children()}  Managing Open State  This section covers how to manage the open state of the component.  Two-Way Binding  Use bind:open for simple, automatic state synchronization:    import { Tooltip } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Tooltip  Fully Controlled  Use a $2 for complete control over the state's reads and writes.    import { Tooltip } from \"bits-ui\";  let myOpen = $state(false);   function getOpen() {   return myOpen;  }   function setOpen(newOpen: boolean) {   myOpen = newOpen;  }  Mobile Tooltips  Tooltips are not supported on mobile devices. The intent of a tooltip is to provide a \"tip\" about a \"tool\" before the user interacts with that tool (in most cases, a button).  This is not possible on mobile devices, because there is no sense of hover on mobile. If a user were to press/touch a button with a tooltip, the action that button triggers would be taken before they were even able to see the tooltip, which renders it useless.  If you are using a tooltip on a button without an action, you should consider using a $2 instead.  If you'd like to learn more about how we came to this decision, here are some useful resources:  The tooltip is not the appropriate role for the more information \"i\" icon, ⓘ. A tooltip is directly associated with the owning element. The ⓘ isn't 'described by' detailed information; the tool or control is. $2  Tooltips should only ever contain non-essential content. The best approach to writing tooltip content is to always assume it may never be read. $2  Reusable Components  It's recommended to use the Tooltip primitives to build your own custom tooltip component that can be used throughout your application.  Below is an example of how you might create a reusable tooltip component that can be used throughout your application. Of course, this isn't the only way to do it, but it should give you a good idea of how to compose the primitives.    import { Tooltip } from \"bits-ui\";  import { type Snippet } from \"svelte\";   type Props = Tooltip.RootProps & {   trigger: Snippet;   triggerProps?: Tooltip.TriggerProps;  };   let {   open = $bindable(false),   children,   buttonText,   triggerProps = {},   ...restProps  }: Tooltip.RootProps = $props();         {@render trigger()}               {@render children?.()}        You could then use the MyTooltip component in your application like so:    import MyTooltip from \"$lib/components/MyTooltip.svelte\";  import BoldIcon from \"..some-icon-library\"; // not real    alert(\"changed to bold!\") }}>  {#snippet trigger()}     {/snippet}  Change font to bold  Delay Duration  You can change how long a user needs to hover over a trigger before the tooltip appears by setting the delayDuration prop on the Tooltip.Root or Tooltip.Provider component.  Close on Trigger Click  By default, the tooltip will close when the user clicks the trigger. If you want to disable this behavior, you can set the disableCloseOnTriggerClick prop to true.  Hoverable Content  By default, the tooltip will remain open when the user hovers over the content. If you instead want the tooltip to close as the user moves their mouse towards the content, you can set the disableHoverableContent prop to true.  Non-Keyboard Focus  If you want to prevent opening the tooltip when the user focuses the trigger without using the keyboard, you can set the ignoreNonKeyboardFocus prop to true.  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Tooltip.Content component to use Svelte Transitions or another animation library that requires more control.    import { Tooltip } from \"bits-ui\";  import { fly, fade } from \"svelte/transition\";          {#snippet child({ wrapperProps, props, open })}    {#if open}                                 {/if}   {/snippet}     Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content components that handles this logic if you intend to use this approach throughout your app. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}  Opt-out of Floating UI  When you use the Tooltip.Content component, Bits UI uses $2 to position the content relative to the trigger, similar to other popover-like components.  You can opt-out of this behavior by instead using the Tooltip.ContentStatic component. This component does not use Floating UI and leaves positioning the content entirely up to you.    Hello            When using the Tooltip.ContentStatic component, the Tooltip.Arrow component will not be rendered relative to it as it is designed to be used with Tooltip.Content.  Custom Anchor  By default, the Tooltip.Content is anchored to the Tooltip.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the Tooltip.Content component.    import { Tooltip } from \"bits-ui\";  let customAnchor = $state(null!);                   {#snippet preview()}  {/snippet}    ","description":"Provides additional information or context when users hover over or interact with an element.","href":"/docs/components/tooltip"},{"title":"IsUsingKeyboard","content":"Overview  IsUsingKeyboard is a utility component that tracks whether the user is actively using the keyboard or not. This component is used internally by Bits UI components to provide keyboard accessibility features.  It provides global state that is shared across all instances of the class to prevent duplicate event listener registration.  Usage    import { IsUsingKeyboard } from \"bits-ui\";   const isUsingKeyboard = new IsUsingKeyboard();  const shouldShowMenu = $derived(isUsingKeyboard.current);  `","description":"A utility to track whether the user is actively using the keyboard or not.","href":"/docs/utilities/is-using-keyboard"},{"title":"mergeProps","content":"Overview  mergeProps is a utility function designed to merge multiple props objects. It's particularly useful for composing components with different prop sets or extending the functionality of existing components.  It is used internally by Bits UI components to merge the custom restProps you pass to a component with the props that Bits UI provides to the component.  Key Features  Merges multiple props objects Chains event handlers with cancellation support Combines class names Merges style objects and strings Chains non-event handler functions  Detailed Behavior  Event Handlers  Event handlers are chained in the order they're passed. If a handler calls event.preventDefault(), subsequent handlers in the chain are not executed.  const props1 = { onclick: (e: MouseEvent) => console.log(\"First click\") }; const props2 = { onclick: (e: MouseEvent) => console.log(\"Second click\") };  const mergedProps = mergeProps(props1, props2); mergedProps.onclick(new MouseEvent(\"click\")); // Logs: \"First click\" then \"Second click\"  If preventDefault() is called:  const props1 = { onclick: (e: MouseEvent) => console.log(\"First click\") }; const props2 = {  onclick: (e: MouseEvent) => {   console.log(\"Second click\");   e.preventDefault();  }, }; const props3 = { onclick: (e: MouseEvent) => console.log(\"Third click\") };  const mergedProps = mergeProps(props1, props2, props3); mergedProps.onclick(new MouseEvent(\"click\")); // Logs: \"First click\" then \"Second click\" only  Since props2 called event.preventDefault(), props3's onclick handler will not be called.  Non-Event Handler Functions  Non-event handler functions are also chained, but without the ability to prevent subsequent functions from executing:  const props1 = { doSomething: () => console.log(\"Action 1\") }; const props2 = { doSomething: () => console.log(\"Action 2\") };  const mergedProps = mergeProps(props1, props2); mergedProps.doSomething(); // Logs: \"Action 1\" then \"Action 2\"  Classes  Class names are merged using $2:  const props1 = { class: \"text-lg font-bold\" }; const props2 = { class: [\"bg-blue-500\", \"hover:bg-blue-600\"] };  const mergedProps = mergeProps(props1, props2); console.log(mergedProps.class); // \"text-lg font-bold bg-blue-500 hover:bg-blue-600\"  Styles  Style objects and strings are merged, with later properties overriding earlier ones:  const props1 = { style: { color: \"red\", fontSize: \"16px\" } }; const props2 = { style: \"background-color: blue; font-weight: bold;\" };  const mergedProps = mergeProps(props1, props2); console.log(mergedProps.style); // \"color: red; font-size: 16px; background-color: blue; font-weight: bold;\"  import { mergeProps } from \"bits-ui\";  const props1 = { style: \"--foo: red\" }; const props2 = { style: { \"--foo\": \"green\", color: \"blue\" } };  const mergedProps = mergeProps(props1, props2);  console.log(mergedProps.style); // \"--foo: green; color: blue;\" `","description":"A utility function to merge props objects.","href":"/docs/utilities/merge-props"},{"title":"Portal","content":"Overview  The Portal component is a utility component that renders its children in a portal, preventing layout issues in complex UI structures. This component is used for the various Bits UI component that have a Portal sub-component.  Usage  Default behavior  By default, the Portal component will render its children in the body element.    import { Portal } from \"bits-ui\";     This content will be portalled to the body  Custom target  You can use the to prop to specify a custom target element or selector to render the content to.    import { Portal } from \"bits-ui\";          This content will be portalled to the #custom-target element Disable  You can use the disabled prop to disable the portal behavior.    import { Portal } from \"bits-ui\";     This content will not be portalled  `","description":"A component that renders its children in a portal, preventing layout issues in complex UI structures.","href":"/docs/utilities/portal"},{"title":"useId","content":"The useId function is a utility function that can be used to generate unique IDs. This function is used internally by all Bits UI components and is exposed for your convenience.  Usage    import { useId } from \"bits-ui\";   const id = useId();   Label here  `","description":"A utility function to generate unique IDs.","href":"/docs/utilities/use-id"},{"title":"WithElementRef","content":"The WithElementRef type helper is a convenience type that enables you to follow the same $2 prop pattern as used by Bits UI components when crafting your own.  type WithElementRef = T & { ref?: U | null };  This type helper is used internally by Bits UI components to enable the ref prop on a component.  Usage Example    import type { WithElementRef } from \"bits-ui\";   type Props = WithElementRef;   let { yourPropA, yourPropB, ref = $bindable(null) }: Props = $props();       `","description":"A type helper to enable the `ref` prop on a component.","href":"/docs/type-helpers/with-element-ref"},{"title":"WithoutChild","content":"The WithoutChild type helper is used to exclude the child snippet prop from a component. This is useful when you're building custom component wrappers that populate the children prop of a component and don't provide a way to pass a custom child snippet.  To learn more about the child snippet prop, check out the $2 documentation.    import { Accordion, type WithoutChild } from \"bits-ui\";   let { children, ...restProps }: WithoutChild = $props();        {@render children?.()}    `","description":"A type helper to exclude the child snippet prop from a component.","href":"/docs/type-helpers/without-child"},{"title":"WithoutChildrenOrChild","content":"The WithoutChildrenOrChild type helper is used to exclude the child and children props from a component. This is useful when you're building custom component wrappers that populate the children prop of a component and don't provide a way to pass a custom children or child snippet.  To learn more about the child snippet prop, check out the $2 documentation.    import { Accordion, type WithoutChildrenOrChild } from \"bits-ui\";   let {   title,   ...restProps  }: WithoutChildrenOrChild = $props();     {title}   Now, the CustomAccordionTrigger component won't expose children or child props to the user, but will expose the other root component props.","description":"A type helper to exclude the child ad children snippet props from a component.","href":"/docs/type-helpers/without-children-or-child"},{"title":"WithoutChildren","content":"The WithoutChildren type helper is used to exclude the children snippet prop from a component. This is useful when you're building custom component wrappers that populate the children prop of a component.    import { Accordion, type WithoutChildren } from \"bits-ui\";   let { value, onValueChange, ...restProps }: WithoutChildren = $props();                   In the example above, we're using the WithoutChildren type helper to exclude the children snippet prop from the Accordion.Root component. This ensures our exposed props are consistent with what is being used internally.","description":"A type helper to exclude the children snippet prop from a component.","href":"/docs/type-helpers/without-children"},{"title":"Child Snippet","content":"The child snippet is a powerful feature that gives you complete control over the rendered elements in Bits UI components, allowing for customization while maintaining accessibility and functionality.  When to Use It  You should use the child snippet when you need:  Svelte-specific features like transitions, animations, actions, or scoped styles Integration with custom components in your application Precise control over the DOM structure Advanced composition of components  Basic Usage  Many Bits UI components have default HTML elements that wrap their content. For example, Accordion.Trigger renders a `` element by default:    {@render children()}   When you need to customize this element, the child snippet lets you take control:    import MyCustomButton from \"$lib/components\";  import { Accordion } from \"bits-ui\";     {#snippet child({ props })}   Toggle Item  {/snippet}       {#snippet child({ props })}   Toggle Item  {/snippet}     .scoped-button {   background-color: #3182ce;   color: #fff;  }   In this example:  The props parameter contains all necessary attributes and event handlers The {...props} spread applies these to your custom element/component You can add scoped styles, transitions, actions, etc. directly to the element  How It Works  When you use the child snippet:  The component passes all internal props and your custom props passed to the component via the props snippet parameter You decide which element receives these props The component's internal logic continues to work correctly  Behind the Scenes  Components that support the child snippet typically implement logic similar to:    // Bits UI component internal logic  let { child, children, ...restProps } = $props();  const trigger = makeTrigger();   // Merge internal props with user props  const mergedProps = $derived(mergeProps(restProps, trigger.props));   {#if child}  {@render child({ props: mergedProps })} {:else}     {@render children?.()}   {/if}  Working with Props  Custom IDs & Attributes  To use custom IDs, event handlers, or other attributes, pass them to the component first:   console.log(\"clicked\")}  {#snippet child({ props })}   Open accordion item  {/snippet}   The props object will now include:  Your custom ID (id=\"my-custom-id\") Your data attribute (data-testid=\"accordion-trigger\") Your click event handler, properly merged with internal handlers All required ARIA attributes and internal event handlers  Combining with Svelte Features  You can apply Svelte-specific features to your custom elements, such as transitions, actions, and scoped styles:    {#snippet child({ props })}            {/snippet}     .my-custom-trigger {   background-color: #3182ce;   color: #fff;  }  Floating Components  Floating content components (tooltips, popovers, dropdowns, etc.) require special handling due to their positioning requirements.  Required Structure  For floating components, you must use a two-level structure:  An outer wrapper element with {...wrapperProps} An inner content element with {...props}    {#snippet child({ wrapperProps, props, open })}   {#if open}                           {/if}  {/snippet}  Important Rules for Floating Content  The wrapper element with {...wrapperProps} must remain unstyled Positioning is handled by the wrapper element; styling goes on the inner content element The open parameter lets you conditionally render the content, triggering Svelte transitions Always maintain this two-level structure to ensure proper positioning and behavior  Components Requiring Wrapper Elements  The following components require a wrapper element:  Combobox.Content DatePicker.Content DateRangePicker.Content DropdownMenu.Content LinkPreview.Content Menubar.Content Popover.Content Select.Content Tooltip.Content  Examples  Basic Custom Element    {#snippet child({ props })}           Favorite     {/snippet}  With Svelte Transitions    {#snippet child({ props, open })}   {#if open}         Dialog content with a scale transition       {/if}  {/snippet}  Floating Element Example    {#snippet child({ wrapperProps, props, open })}   {#if open}         Custom tooltip content       {/if}  {/snippet}  Common Pitfalls  Missing props spread**: Always include {...props} on your custom element Styling the wrapper**: Never style the wrapper element in floating components Direct children**: When using child, other children outside the snippet are ignored Missing structure**: For floating elements, forgetting the two-level structure will break positioning  Related Resources  $2 Utility $2 $2","description":"Learn how to use the `child` snippet to render your own elements.","href":"/docs/child-snippet"},{"title":"Dates and Times","content":"The date and time components in Bits UI leverage the $2 package, providing a unified API for working with dates and times across different locales and time zones. This package is inspired by the $2 proposal and is designed to seamlessly integrate with the Temporal API once it becomes available.  Installation  You can install the package using your favorite package manager:  npm install @internationalized/date  It's highly recommended to familiarize yourself with the package's documentation before diving into the components. We'll cover the basics of how we use the package in Bits UI in the sections below, but their documentation provides much more detail on the various formats and how to work with them.  DateValue Types  Bits UI uses DateValue objects from @internationalized/date to represent dates and times consistently. These immutable objects provide specific information about the type of date they represent:  We use the DateValue objects provided by @internationalized/date to represent dates and times in a consistent way. These objects are immutable and provide information about the type of date they represent. The DateValue is a union of the following three types:  | Type               | Description                 | Example                                          | | ------------------ | --------------------------- | ------------------------------------------------ | | CalendarDate     | Date without time component | 2024-07-10                                     | | CalendarDateTime | Date with time              | 2024-07-10T12:30:00                            | | ZonedDateTime    | Date with time and timezone | 2024-07-10T21:00:00:00-04:00[America/New_York] |  Using these strongly-typed objects allows components to adapt appropriately to the date type you provide.  CalendarDate  Represents a date without a time component.  // Creating a CalendarDate import { CalendarDate, parseDate, today, getLocalTimeZone } from \"@internationalized/date\";  // From year, month, day parameters const date = new CalendarDate(2024, 7, 10);  // From ISO 8601 string const parsedDate = parseDate(\"2024-07-10\");  // Current date in specific timezone const losAngelesToday = today(\"America/Los_Angeles\");  // Current date in user's timezone const localToday = today(getLocalTimeZone());  See the $2 for additional methods.  CalendarDateTime  Represents a date with a time component, but without timezone information.  // Creating a CalendarDateTime import { CalendarDateTime, parseDateTime } from \"@internationalized/date\";  // From date and time components const dateTime = new CalendarDateTime(2024, 7, 10, 12, 30, 0);  // From ISO 8601 string const parsedDateTime = parseDateTime(\"2024-07-10T12:30:00\");  See the $2 for additional methods.  ZonedDateTime  Represents a specific date and time in a specific timezone - crucial for events that occur at an exact moment regardless of the user's location (like conferences or live broadcasts).  // Creating a ZonedDateTime import {  ZonedDateTime,  parseZonedDateTime,  parseAbsolute,  parseAbsoluteToLocal, } from \"@internationalized/date\";  const date = new ZonedDateTime(  2022,  2,  3, // Date (year, month, day)  \"America/Los_Angeles\", // Timezone  -28800000, // UTC offset in milliseconds  9,  15,  0 // Time (hour, minute, second) );  // From ISO 8601 strings using different parsing functions const date1 = parseZonedDateTime(\"2024-07-12T00:45[America/New_York]\"); const date2 = parseAbsolute(\"2024-07-12T07:45:00Z\", \"America/New_York\"); const date3 = parseAbsoluteToLocal(\"2024-07-12T07:45:00Z\");  See the $2 for more information.  Working with Date Ranges  For components that require date ranges, Bits UI provides a DateRange type:  type DateRange = {  start: DateValue;  end: DateValue; };  This type is used in components such as:  $2 $2 $2  Using the Placeholder  Each date/time component in Bits UI has a bindable placeholder prop that serves multiple important functions:  Starting Point: Acts as the initial date when no value is selected Type Definition: Determines what type of date/time to display if value is absent Calendar Navigation: Controls the visible date range in calendar views  Example: Using Placeholder with Calendar    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone, type DateValue } from \"@internationalized/date\";   // Initialize placeholder with today's date  let placeholder: DateValue = $state(today(getLocalTimeZone()));  let selectedMonth: number = $state(placeholder.month);     {   placeholder = placeholder.set({ month: selectedMonth });  }}  bind:value={selectedMonth}  January  February Updating DateValue Objects  Since DateValue objects are immutable, you must create new instances when updating them:  // INCORRECT - will not work let placeholder = new CalendarDate(2024, 7, 10); placeholder.month = 8; // Error! DateValue objects are immutable  // CORRECT - using methods that return new instances let placeholder = new CalendarDate(2024, 7, 10);  // Method 1: Using set() placeholder = placeholder.set({ month: 8 });  // Method 2: Using add() placeholder = placeholder.add({ months: 1 });  // Method 3: Using subtract() placeholder = placeholder.subtract({ days: 5 });  // Method 4: Using cycle() - cycles through valid values placeholder = placeholder.cycle(\"month\", \"forward\", [1, 3, 5, 7, 9, 11]);  Formatting and Parsing  Formatting Dates for Display  For consistent, locale-aware date formatting, use the DateFormatter class:  import { DateFormatter } from \"@internationalized/date\";  // Create a formatter for the current locale const formatter = new DateFormatter(\"en-US\", {  dateStyle: \"full\",  timeStyle: \"short\", });  // Format a DateValue const formattedDate = formatter.format(myDateValue.toDate(\"America/New_York\")); // Example output: \"Wednesday, July 10, 2024 at 12:30 PM\"  The DateFormatter wraps the native $2 while fixing browser inconsistencies and polyfilling newer features.  Parsing Date Strings  When working with date strings from APIs or databases, use the appropriate parsing function for your needs:  import {  parseDate, // For CalendarDate  parseDateTime, // For CalendarDateTime  parseZonedDateTime, // For ZonedDateTime with timezone name  parseAbsolute, // For ZonedDateTime from UTC string + timezone  parseAbsoluteToLocal, // For ZonedDateTime in local timezone } from \"@internationalized/date\";  // Examples const date = parseDate(\"2024-07-10\"); // CalendarDate const dateTime = parseDateTime(\"2024-07-10T12:30:00\"); // CalendarDateTime const zonedDate = parseZonedDateTime(\"2024-07-12T00:45[America/New_York]\"); // ZonedDateTime const absoluteDate = parseAbsolute(\"2024-07-12T07:45:00Z\", \"America/New_York\"); // ZonedDateTime const localDate = parseAbsoluteToLocal(\"2024-07-12T07:45:00Z\"); // ZonedDateTime in user's timezone  Common Gotchas and Tips  Month Indexing**: Unlike JavaScript's Date object (which is 0-indexed), @internationalized/date uses 1-indexed months (January = 1). Immutability**: Always reassign when modifying date objects: date = date.add({ days: 1 }). Timezone Handling**: Use ZonedDateTime for schedule-critical events like meetings or appointments. Type Consistency**: Match placeholder types to your needs - if you need time selection, use CalendarDateTime not CalendarDate. Performance**: Create DateFormatter instances once and reuse them rather than creating new instances on each render.  Related Resources  $2 $2 $2 $2 $2 $2 $2","description":"How to work with the various date and time components in Bits UI.","href":"/docs/dates"},{"title":"Figma","content":"The Figma UI Kit is open sourced by $2.    import { AspectRatio } from \"bits-ui\";  Grab a copy  https://www.figma.com/community/file/1430229712135910564/bits-ui-kit","description":"Every component recreated in Figma.","href":"/docs/figma-file"},{"title":"Getting Started","content":"Welcome to Bits UI, a collection of headless component primitives for Svelte 5 that prioritizes developer experience, accessibility, and flexibility. This guide will help you quickly integrate Bits UI into your Svelte application.  Installation  Install bits using your preferred package manager.  npm install bits-ui  Basic Usage  After installation, you can import and use Bits UI components in your Svelte files. Here's a simple example using the $2 component.    import { Accordion } from \"bits-ui\";            First      First accordion content           Second      Second accordion content Adding Styles  Bits UI components are headless by design, meaning they ship with minimal styling. This gives you complete control over the appearance of your components. Each component that renders an HTML element exposes a class prop and style prop that you can use to apply styles to the element.  Styling with TailwindCSS or UnoCSS  If you're using a CSS framework like TailwindCSS or UnoCSS, you can pass the classes directly to the components:    import { Accordion } from \"bits-ui\";                 Tailwind-styled Accordion                              This accordion is styled using Tailwind CSS classes. Styling with Data Attributes  Each Bits UI component applies specific data attributes to the underlying HTML elements. You can use these attributes to target components in your global styles:  Check the API Reference for each component to determine its data attributes Use those attributes in your CSS selectors    import { Button } from \"bits-ui\";  import \"../app.css\";   Click me  [data-button-root] {  height: 3rem;  width: 100%;  background-color: #3182ce;  color: white;  border-radius: 0.375rem;  padding: 0.5rem 1rem;  font-weight: 500; }  [data-button-root]:hover {  background-color: #2c5282; }  With this approach, every Button.Root component will have these styles applied to it automatically.  TypeScript Support  Bits UI is built with TypeScript and provides comprehensive type definitions. When using TypeScript, you'll get full type checking and autocompletion:    import { Accordion } from \"bits-ui\";   // TypeScript will validate these props  const accordionMultipleProps: Accordion.RootProps = {   type: \"multiple\",   value: [\"item-1\"], // type error if value is not an array  };   const accordionSingleProps: Accordion.RootProps = {   type: \"single\",   value: \"item-1\", // type error if value is an array  };  Next Steps  Now that you have Bits UI installed and working, you can:  Explore the $2 to learn about all available components Learn about render delegation using the $2 for maximum flexibility and customization Learn how Bits UI handles $2 and how you can take more control over your components  Resources  If you have questions or need help, there are several ways to get support from the Bits UI community:  For confirmed bugs, please $2 on GitHub. Have a question or need help? Join our $2 or $2 on GitHub to chat with other developers and the Bits UI team. Have a feature request or idea? $2 on GitHub to share your thoughts. All feature requests start as discussions before formally being moved to issues.","description":"Learn how to get started using Bits in your app.","href":"/docs/getting-started"},{"title":"Introduction","content":"Bits UI is a headless component library for Svelte focused on developer experience, accessibility, and full creative control. Use it to build high-quality, accessible UIs without giving up styling freedom or performance.  Why Bits UI?  Bring Your Own Styles  Most components ship completely unstyled, with the exception of those required for core functionality. No CSS resets, no design system assumptions. You bring the styles using standard class props or data-* attributes. $2.  Building for Developer Experience  Everything is designed to stay out of your way:  Full TypeScript coverage Stable, predictable APIs Flexible event override system Great defaults, easily overridden Comprehensive documentation and examples  Production-Ready Accessibility  Accessibility isn't just an afterthought - it's baked in:  WAI-ARIA compliance Keyboard navigation by default Focus management handled for you Screen reader support built-in  Composable by Design  Components are primitives, not black boxes. They compose cleanly and play well together:  $2 for total flexibility Chainable events and callbacks Override-friendly defaults Minimal dependencies  Community  Bits UI was built and is maintained by $2 with design support from $2 and his team at $2 and tooling support from $2. Contributions, issues, and feedback are always welcome.  Found an issue? $2. Have a feature request? $2  Acknowledgments  Built on the shoulders of giants:  $2 - inspired the internal architecture $2 - API design inspiration $2 - inspiration for the date/time components and excellence in accessibility","description":"The headless components for Svelte.","href":"/docs/introduction"},{"title":"LLMs","content":"At the top of each documentation page, you'll find a convenient \"Copy Markdown\" button alongside a direct link to the LLM-friendly version of that page (e.g., /llms.txt). These tools make it easy to copy the content in Markdown format or access the machine-readable llms.txt file tailored for that specific page.  Bits UI documentation is designed to be accessible not only to humans but also to large language models (LLMs). We've adopted the $2 proposal standard, which provides a structured, machine-readable format optimized for LLMs. This enables developers, researchers, and AI systems to efficiently parse and utilize our documentation.  What is llms.txt?  The llms.txt standard is an emerging convention for presenting documentation in a simplified, text-based format that's easy for LLMs to process. By following this standard, Bits UI ensures compatibility with AI tools and workflows, allowing seamless integration into LLM-powered applications, research, or automation systems.  Accessing LLM-friendly Documentation  To access the LLM-friendly version of any supported Bits UI documentation page, simply append /llms.txt to the end of the page's URL. This will return the content in a plain-text, LLM-optimized format.  Example  Standard Page**: The Accordion component documentation is available at $2. LLM-friendly Version**: Append /llms.txt to access it at $2.  Root Index  To explore all supported pages in LLM-friendly format, visit the root index at $2. This page provides a comprehensive list of available documentation endpoints compatible with the llms.txt standard.  Full LLM-friendly Documentation  For a complete, consolidated view of the Bits UI documentation in an LLM-friendly format, navigate to $2. This single endpoint aggregates all documentation content into a machine-readable structure, ideal for bulk processing or ingestion into AI systems.  Notes  Not all pages may support the /llms.txt suffix (those deemed irrelevant to LLMs, such as the Figma page). Check the root $2 page for an up-to-date list of compatible URLs. The \"Copy Markdown\" button at the top of each page provides the same content you'd find in the /llms.txt of that page.  By embracing the llms.txt standard, Bits UI empowers both human developers and AI systems to make the most of our documentation. Whether you're building with Bits UI or training an LLM, these tools are designed to enhance your experience.","description":"How to access LLM-friendly versions of Bits UI documentation.","href":"/docs/llms"},{"title":"Migration Guide","content":"  import { Callout } from '$lib/components';  Bits UI v1  Bits UI v1 is a major update that introduces significant improvements, but it also comes with breaking changes. Since anything before v1.0 was a pre-release, backward compatibility was not guaranteed. This guide will help you transition smoothly, though it may not cover every edge case.  We highly recommend reviewing the documentation for each component you use, as their APIs may have changed.    Looking for the old documentation? You can still access Bits UI v0.x at $2. However, we encourage you to migrate as soon as possible to take advantage of the latest features and improvements.  Why Upgrade?  Bits UI has been completely rewritten for Svelte 5, bringing several key benefits:  Performance improvements** – Faster rendering and reduced overhead. More flexible APIs** – Easier customization and integration. Bug fixes and stability** – Addressing every bug and issue from v0.x. Better developer experience** – Improved consistency and documentation.  Once you get familiar with Bits UI v1, we're confident you'll find it to be a more powerful and streamlined headless component library.  Shared Changes  el prop replaced with ref**: The el prop has been removed across all components that render and HTML element. Use the ref prop instead. See the $2 documentation for more information. asChild prop replaced with child snippet**: Components that previously used asChild now use the child snippet prop. See the $2 documentation. Transition props removed**: Components no longer accept transition props. Instead, use the child snippet along with forceMount to leverage Svelte transitions. More details in the $2 documentation. let: directives replaced with snippet props**: Components that used to expose data via let: directives now provide it through children/child snippet props.  Accordion  The multiple prop has been removed from the Accordion.Root component and replaced with a required type prop which can be set to either 'single' or 'multiple'. This is used as a discriminant to properly type the value prop as either a string or string[]. The various transition props have been removed from the Accordion.Content component. See the $2 documentation for more information.  See the $2 documentation for more information.  Alert Dialog  The various transition props have been removed from the AlertDialog.Content and AlertDialog.Overlay components. See the $2 documentation for more information. To render the dialog content in a portal, you now must wrap the AlertDialog.Content in the AlertDialog.Portal component. The AlertDialog.Action component no longer closes the dialog by default, as we learned it was causing more harm than good when attempting to submit a form with the Action button. See the $2 section for more information on how to handle submitting forms before closing the dialog.  Button  The Button component no longer accepts a builders prop, instead you should use the child snippet on the various components to receive/pass the attributes to the underlying button. See $2 for more information.  Checkbox  The Checkbox.Indicator component has been removed in favor of using the children snippet prop to get a reference to the checked state and render a custom indicator. See the $2 documentation for more information. The Checkbox.Input component has been removed in favor of automatically rendering a hidden input when the name prop is provided to the Checkbox.Root component. The checked state of the Checkbox component is now of type boolean instead of boolean | 'indeterminate', indeterminate is its own state now and can be managed via the indeterminate prop. A new component, Checkbox.Group has been introduced to support checkbox groups.  See the $2 documentation for more information.  Combobox  The multiple prop has been removed from the Combobox.Root component and replaced with a required type prop which can be set to either 'single' or 'multiple'. This is used as a discriminant to properly type the value prop as either a string or string[]. The selected prop has been replaced with a value prop, which is limited to a string (or string[] if type=\"multiple\"). The combobox now automatically renders a hidden input when the name prop is provided to the Combobox.Root component. The Combobox.ItemIndicator component has been removed in favor of using the children snippet prop to get a reference to the selected state and render a custom indicator. See the $2 documentation for more information. Combobox.Group and Combobox.GroupHeading have been added to support groups within the combobox. In Bits UI v0, the Combobox.Content was automatically portalled unless you explicitly set the portal prop to false. In v1, we provide a Combobox.Portal component that you can wrap around the Combobox.Content to portal the content. Combobox.Portal accepts a to prop that can be used to specify the target portal container (defaults to document.body), and a disabled prop that can be used to disable portalling.  Context Menu/Dropdown Menu/Menubar Menu  The Menu.RadioIndicator and Menu.CheckboxIndicator components have been removed in favor of using the children snippet prop to get a reference to the checked or selected state and render a custom indicator. See the $2, $2, and $2 documentation for more information. The Menu.Label component, which was used as the heading for a group of items has been replaced with the Menu.GroupHeading component. The href prop on the .Item components has been removed in favor of the child snippet and rendering your own anchor element. In Bits UI v0, the Menu.Content was automatically portalled unless you explicitly set the portal prop to false. In v1, we provide a Menu.Portal component that you can wrap around the Menu.Content to portal the content. Menu.Portal accepts a to prop that can be used to specify the target portal container (defaults to document.body), and a disabled prop that can be used to disable portalling.  Pin Input  The PinInput component has been completely overhauled to better act as an OTP input component, with code and inspiration taken from $2 by $2. The best way to migrate is to reference the $2 documentation to see how to use the new component.  Popover  In Bits UI v0, the Popover.Content was automatically portalled unless you explicitly set the portal prop to false. In v1, we provide a Popover.Portal component that you can wrap around the Popover.Content to portal the content. Popover.Portal accepts a to prop that can be used to specify the target portal container (defaults to document.body), and a disabled prop that can be used to disable portalling.  Radio Group  RadioGroup.ItemIndicator has been removed in favor of using the children snippet prop to get a reference to the checked state which provides more flexibility to render a custom indicator as needed. See the $2 documentation for more information.  Scroll Area  ScrollArea.Content has been removed as it is not necessary for functionality in Bits UI v1.  Select  The multiple prop has been removed from the Select.Root component and replaced with a required type prop which can be set to either 'single' or 'multiple'. This is used as a discriminant to properly type the value prop as either a string or string[]. The selected prop has been replaced with a value prop, which is limited to a string (or string[] if type=\"multiple\"). The select now automatically renders a hidden input when the name prop is provided to the Select.Root component. The Select.ItemIndicator component has been removed in favor of using the children snippet prop to get a reference to the selected state and render a custom indicator. See the $2 documentation for more information. Select.Group and Select.GroupHeading have been added to support groups within the Select. Select.Value has been removed in favor of enabling developers to use the value prop to render your own custom label in the trigger to represent the value. In Bits UI v0, the Select.Content was automatically portalled unless you explicitly set the portal prop to false. In v1, we provide a Select.Portal component that you can wrap around the Select.Content to portal the content. Select.Portal accepts a to prop that can be used to specify the target portal container (defaults to document.body), and a disabled prop that can be used to disable portalling.  Slider  Slider.Root now requires a type prop to be set to either 'single' or 'multiple' to properly type the value as either a number or number[]. A new prop, onValueCommit has been introduced which is called when the user commits a value change (e.g. by releasing the mouse button or pressing Enter). This is useful for scenarios where you want to update the value only when the user has finished interacting with the slider, not for each movement of the thumb.  Tooltip  A required component necessary to provide context for shared tooltips, Tooltip.Provider has been added. This replaces the group prop on the previous version's Tooltip component. You can wrap your entire app with Tooltip.Provider, or wrap a specific section of your app with it to provide shared context for tooltips.","description":"Learn how to migrate from 0.x to 1.x+","href":"/docs/migration-guide"},{"title":"Ref","content":"The ref prop provides direct access to the underlying HTML elements in Bits UI components, enabling you to manipulate the DOM when necessary.  Basic Usage  Every Bits UI component that renders an HTML element exposes a ref prop that you can bind to access the rendered element. This is particularly useful for programmatically manipulating the element, such as focusing inputs or measuring dimensions.    import { Accordion } from \"bits-ui\";   let triggerRef = $state(null);   function focusTrigger() {   triggerRef?.focus();  }   Focus trigger  Trigger content  With Child Snippet  Bits UI uses element IDs to track references to underlying elements. This approach ensures that the ref prop works correctly even when using the $2.  Simple Delegation Example  The ref binding will automatically work with delegated child elements/components.    import CustomButton from \"./CustomButton.svelte\";  import { Accordion } from \"bits-ui\";   let triggerRef = $state(null);   function focusTrigger() {   triggerRef?.focus();  }     {#snippet child({ props })}     {/snippet}  Using Custom IDs  When you need to use a custom id on the element, pass it to the parent component first so it can be correctly registered with the ref binding:    import CustomButton from \"./CustomButton.svelte\";  import { Accordion } from \"bits-ui\";   let triggerRef = $state(null);  const myCustomId = \"my-custom-id\";     {#snippet child({ props })}        {/snippet}  Common Pitfalls  Avoid setting the id directly on the child component/element, as this breaks the connection between the ref binding and the element:     {#snippet child({ props })}     {/snippet}   In this example, the Accordion.Trigger component can't track the element because it doesn't know the custom ID.  Why Possibly null?  The ref value may be null until the component mounts in the DOM. This behavior is consistent with native DOM methods like getElementById which can return null.  Creating Your Own ref Props  To implement the same ref pattern in your custom components, Bits UI provides a $2 type helper. This enables you to create type-safe components that follow the same pattern.    import { WithElementRef } from \"bits-ui\";  import type { HTMLButtonAttributes } from \"svelte/elements\";   // Define props with the ref type  let {   ref = $bindable(null),   children,   ...rest  }: WithElementRef = $props();     {@render children?.()}  `","description":"Learn about the $bindable ref prop.","href":"/docs/ref"},{"title":"State Management","content":"State management is a critical aspect of modern UI development. Bits UI components support multiple approaches to manage component state, giving you flexibility based on your specific needs.  Each component's API reference will highlight what props are bindable. You can replace the value prop used in the examples on this page with any bindable prop.  Two-Way Binding  The simplest approach is using Svelte's built-in two-way binding with bind::    import { ComponentName } from \"bits-ui\";   let myValue = $state(\"default-value\");    (myValue = \"new-value\")}> Update Value   Why Use It?  Zero-boilerplate state updates External controls work automatically Great for simple use cases  Function Binding  For complete control, use a $2 that handles both getting and setting values:    import { ComponentName } from \"bits-ui\";   let myValue = $state(\"default-value\");   function getValue() {   return myValue;  }   function setValue(newValue: string) {   // Only update during business hours   const now = new Date();   const hour = now.getHours();    if (hour >= 9 && hour     When the component wants to set the value from an internal action, it will invoke the setter, where you can determine if the setter actually updates the state or not.  When to Use  Complex state transformation logic Conditional updates Debouncing or throttling state changes Maintaining additional state alongside the primary value Integrating with external state systems","description":"How to manage the state of Bits UI components","href":"/docs/state-management"},{"title":"Styling","content":"We ship almost zero styles with Bits UI by design, giving you complete flexibility when styling your components. For each component that renders an HTML element, we expose the class and style props to apply styles directly to the component.  Styling Approaches  CSS Frameworks  If you're using a CSS framework like $2 or $2, simply pass the classes to the component:    import { Accordion } from \"bits-ui\";   Click me  Data Attributes  Each Bits UI component applies specific data attributes to its rendered elements. These attributes provide reliable selectors for styling across your application.  /* Target all Accordion.Trigger components */ [data-accordion-trigger] {  height: 3rem;  width: 100%;  background-color: #3182ce;  color: #fff; }  Import your stylesheet in your layout component:    import \"../app.css\";  let { children } = $props();   {@render children()}  Now every Accordion.Trigger component will have the styles applied to it.  Global Classes  Alternatively, you can use global class names:  .accordion-trigger {  height: 3rem;  width: 100%;  background-color: #3182ce;  color: #fff; }  Import your stylesheet in your layout component:    import \"../app.css\";  let { children } = $props();   {@render children()}  Use the global class with the component:    import { Accordion } from \"bits-ui\";   Click me  Scoped Styles  To use Svelte's scoped styles, use the child snippet to bring the element into your component's scope. See the $2 documentation for more information.    import { Accordion } from \"bits-ui\";     {#snippet child({ props })}    Click me!   {/snippet}     .my-accordion-trigger {   height: 3rem;   width: 100%;   background-color: #3182ce;   color: #fff;  }  Style Prop  All Bits UI components that render an element accept a style prop as either a string or an object of CSS properties. These are merged with internal styles using the $2 function.     Click me      Click me  Styling Component States  Bits UI components may expose state information through data attributes and CSS variables, allowing you to create dynamic styles based on component state.  State Data Attributes  Components apply state-specific data attributes that you can target in your CSS:  /* Style the Accordion.Trigger when open */ $2 {  background-color: #f0f0f0;  font-weight: bold; }  /* Style the Accordion.Trigger when closed */ $2 {  background-color: #ffffff; }  /* Style disabled components */ $2 {  opacity: 0.5;  cursor: not-allowed; }  See each component's API reference for its specific data attributes.  CSS Variables  Bits UI components may expose CSS variables that allow you to access internal component values. For example, to ensure the Select.Content is the same width as the anchor (by default is the Select.Trigger unless using a customAnchor), you can use the --bits-select-anchor-width CSS variable:  [data-select-content] {  width: var(--bits-select-anchor-width);  min-width: var(--bits-select-anchor-width);  max-width: var(--bits-select-anchor-width); }  See each component's API reference for specific CSS variables it provides.  Example: Styling an Accordion  Here's an example styling an accordion with different states:    import { Accordion } from \"bits-ui\";        Section 1   Content for section 1       Section 2 (Disabled)   Content for section 2       /* Base styles */  :global([data-accordion-item]) {   border: 1px solid #e2e8f0;   border-radius: 0.25rem;   margin-bottom: 0.5rem;  }   /* Trigger styles based on state */  :global([data-accordion-trigger]) {   width: 100%;   padding: 1rem;   display: flex;   justify-content: space-between;   align-items: center;  }   :global($2) {   background-color: #f7fafc;   border-bottom: 1px solid #e2e8f0;  }   :global($2) {   opacity: 0.5;   cursor: not-allowed;  }   /* Content styles */  :global([data-accordion-content]) {   padding: 1rem;  }  Advanced Styling Techniques  Combining Data Attributes with CSS Variables  You can combine data attributes with CSS variables to create dynamic styles based on component state. Here's how to animate the accordion content using the --bits-accordion-content-height variable and the data-state attribute:  /* Basic transition animation */ [data-accordion-content] {  overflow: hidden;  transition: height 300ms ease-out;  height: 0; }  $2 {  height: var(--bits-accordion-content-height); }  $2 {  height: 0; }  Custom Keyframe Animations  For more control, use keyframe animations with the CSS variables:  /* Define keyframes for opening animation */ @keyframes accordionOpen {  0% {   height: 0;   opacity: 0;  }  80% {   height: var(--bits-accordion-content-height);   opacity: 0.8;  }  100% {   height: var(--bits-accordion-content-height);   opacity: 1;  } }  /* Define keyframes for closing animation */ @keyframes accordionClose {  0% {   height: var(--bits-accordion-content-height);   opacity: 1;  }  20% {   height: var(--bits-accordion-content-height);   opacity: 0.8;  }  100% {   height: 0;   opacity: 0;  } }  /* Apply animations based on state */ $2 {  animation: accordionOpen 400ms cubic-bezier(0.16, 1, 0.3, 1) forwards; }  $2 {  animation: accordionClose 300ms cubic-bezier(0.7, 0, 0.84, 0) forwards; }  Example: Animated Accordion  Here's an example of an accordion with a custom transition:    import { Accordion } from \"bits-ui\";        Section 1   Content for section 1       Section 2   Content for section 2       /* Base styles */  :global([data-accordion-item]) {   border: 1px solid #e2e8f0;   border-radius: 0.25rem;   margin-bottom: 0.5rem;  }   /* Trigger styles based on state */  :global([data-accordion-trigger]) {   width: 100%;   padding: 1rem;   display: flex;   justify-content: space-between;   align-items: center;  }   :global($2) {   background-color: #f7fafc;   border-bottom: 1px solid #e2e8f0;  }   /* Content styles */  :global([data-accordion-content]) {   overflow: hidden;   transition: height 300ms ease-out;  }   /* Define keyframes for opening animation */  @keyframes -global-accordionOpen {   0% {    height: 0;    opacity: 0;   }   80% {    height: var(--bits-accordion-content-height);    opacity: 0.8;   }   100% {    height: var(--bits-accordion-content-height);    opacity: 1;   }  }   /* Define keyframes for closing animation */  @keyframes -global-accordionClose {   0% {    height: var(--bits-accordion-content-height);    opacity: 1;   }   20% {    height: var(--bits-accordion-content-height);    opacity: 0.8;   }   100% {    height: 0;    opacity: 0;   }  }   /* Apply animations based on state */  :global($2) {   animation: accordionOpen 400ms cubic-bezier(0.16, 1, 0.3, 1) forwards;  }   :global($2) {   animation: accordionClose 300ms cubic-bezier(0.7, 0, 0.84, 0) forwards;  }  `","description":"Learn how to style Bits UI components.","href":"/docs/styling"},{"title":"Transitions","content":"  import Callout from '$lib/components/callout.svelte';   Svelte Transitions are one of the awesome features of Svelte. Unfortunately, they don't play very nicely with components, due to the fact that they rely on various directives like in:, out:, and transition:, which aren't supported by components.  In previous version of Bits UI, we had a workaround for this by exposing a ton of transition* props on the components that we felt were most likely to be used with transitions. However, this was a bit of a hack and limited us to only Svelte Transitions, and users who wanted to use other libraries or just CSS were left out.  With Bits UI for Svelte 5, we've completely removed this workaround and instead exposed props and snippets that allow you to use any animation or transitions library you want.  The Defaults  By default, Bits UI components handle the mounting and unmounting of specific components for you. They are wrapped in a component that ensures the component waits for transitions to finish before unmounting.  You can use any CSS transitions or animations you want with this approach, which is what we're doing in the various example components in this documentation, using $2.  Force Mounting  On each component that we conditionally render, a forceMount prop is exposed. If set to true, the component will be forced to mount in the DOM and become visible to the user. You can use this prop in conjunction with the $2 child snippet to conditionally render the component and apply Svelte Transitions or another animation library.  The child snippet exposes a prop that you can use to conditionally render the element and apply your transitions.    import { Dialog } from \"bits-ui\";  import { fly } from \"svelte/transition\";          {#snippet child({ props, open })}    {#if open}                    {/if}   {/snippet}     In the example above, we're using the forceMount prop to tell the component to forcefully mount the Dialog.Content component. We're then using the child snippet to delegate the rendering of the Dialog.Content to a div element which we can apply our props and transitions to.  We understand this isn't the prettiest syntax, but it enables us to cover every use case. If you intend to use this approach across your application, it's recommended to create a reusable component that handles this logic, like so:    import type { Snippet } from \"svelte\";  import { fly } from \"svelte/transition\";  import { Dialog, type WithoutChildrenOrChild } from \"bits-ui\";   let {   ref = $bindable(null),   children,   ...restProps  }: WithoutChildrenOrChild & {   children?: Snippet;  } = $props();     {#snippet child({ props, open })}   {#if open}         {@render children?.()}       {/if}  {/snippet}   Which can then be used alongside the other Dialog.* components:    import { Dialog } from \"bits-ui\";  import MyDialogContent from \"$lib/components/MyDialogContent.svelte\";     Open Dialog            Dialog Title    Dialog Description    Close    Other dialog content Floating Content Components  Content components that rely on Floating UI require a slight modification to how the child snippet is used.  For example, if we were to use the Popover.Content component, we need to add a wrapper element within the child snippet, and spread the wrapperProps snippet prop to it.    import { Popover } from \"bits-ui\";  import { fly } from \"svelte/transition\";     Open Popover         {#snippet child({ wrapperProps, props, open })}     {#if open}                                       {/if}    {/snippet}       `","description":"Learn how to use transitions with Bits UI components.","href":"/docs/transitions"}]