# Bits UI v3 - Planned Changes

Table of Contents

- [Bits UI v3 - Planned Changes](#bits-ui-v3---planned-changes)
  - [Floating Content Wrapper → Positioner Component](#floating-content-wrapper--positioner-component)
    - [Motivation](#motivation)
    - [Proposal](#proposal)
    - [Alternatives Considered](#alternatives-considered)
    - [Impact](#impact)
    - [Migration Example](#migration-example)
  - [New `Select.List` \& `Combobox.List` Components](#new-selectlist--comboboxlist-components)
    - [Motivation](#motivation-1)
    - [Proposal](#proposal-1)
    - [Alternatives Considered](#alternatives-considered-1)
    - [Impact](#impact-1)
  - [Form Components](#form-components)
    - [Motivation](#motivation-2)
    - [Proposal](#proposal-2)
    - [Impact](#impact-2)
  - [Allow Open on Hover for Floating Components](#allow-open-on-hover-for-floating-components)
    - [Motivation](#motivation-3)
    - [Proposal](#proposal-3)
    - [Alternatives Considered](#alternatives-considered-2)
    - [Impact](#impact-3)
  - [Filter Inside of Select and/or Combobox](#filter-inside-of-select-andor-combobox)
    - [Motivation](#motivation-4)
    - [Proposal](#proposal-4)
    - [Alternatives Considered](#alternatives-considered-3)
    - [Impact](#impact-4)

## Floating Content Wrapper → Positioner Component

### Motivation

Currently, all floating components render an internal wrapper element around their content to handle positioning. This hidden "floating wrapper" simplifies usage but makes the system more rigid and harder to customize.

When floating behavior isn’t desired, users must switch to a separate `*.ContentStatic` component - a workaround added after v1 to avoid another round of breaking changes. This approach duplicates logic, creates unnecessary branching in the codebase, and forces users to understand an artificial distinction between "floating" and "static" variants.

Base UI provides a cleaner solution with a `*.Positioner` component that's explicitly placed around the content. This keeps the content itself simple while giving users full control over how positioning is applied (or omitted).

### Proposal

Expose a new `*.Positioner` component that users place around the existing `*.Content` component. The current internal wrapper logic will be removed from `*.Content`. We would also remove the `*.ContentStatic` components.

When floating behavior is needed, users include the `*.Positioner`. When it isn’t, they simply omit it - no need for a separate "static" content variant.

Example Usage:

```diff
<Tooltip.Root>
    <Tooltip.Trigger>Trigger</Tooltip.Trigger>
    <Tooltip.Portal>
+        <Tooltip.Positioner sideOffset={8} alignOffset={4}>
            <Tooltip.Content>
                <!-- ... >
            </Tooltip.Content>
+        </Tooltip.Positioner>
    </Tooltip.Portal>
</Tooltip.Root>
```

The `*.Positioner` component would accept all the floating-ui specific props, such as `sideOffset`, `alignOffset`, `avoidCollisions`, `collisionBoundary`, `collisionPadding`, `hideWhenDetached`, `sticky`, `updatePositionStrategy`, `strategy`, `customAnchor`, etc.

### Alternatives Considered

- **Keep `*.ContentStatic`** -
  Maintains backward compatibility but continues the two-component split and internal duplication.
- **Keep wrapper hidden inside `*.Content`** - Retains the current API simplicity but keeps key positioning behavior opaque and hard to override.

### Impact

- **Breaking Change:** Users will now manually include `*.Positioner` for floating behavior.
- **Simpler API surface:** Removes `*.ContentStatic`, unifies the content model.
- **More flexible composition:** Positioning becomes explicit and fully customizable.
- **Cleaner internals:** No more wrapperProps forwarding or hidden layout elements.

### Migration Example

Before (v2):

```svelte
<Tooltip.Root>
  <Tooltip.Trigger>Trigger</Tooltip.Trigger>
  <Tooltip.Portal>
    <Tooltip.Content sideOffset={8} alignOffset={4}>
      Tooltip text
    </Tooltip.Content>
  </Tooltip.Portal>
</Tooltip.Root>
```

After (v3):

```svelte
<Tooltip.Root>
  <Tooltip.Trigger>Trigger</Tooltip.Trigger>
  <Tooltip.Portal>
    <Tooltip.Positioner sideOffset={8} alignOffset={4}>
      <Tooltip.Content>Tooltip text</Tooltip.Content>
    </Tooltip.Positioner>
  </Tooltip.Portal>
</Tooltip.Root>
```

## New `Select.List` & `Combobox.List` Components

### Motivation

Both Select and Combobox components follow the ARIA "listbox" pattern. Currently, the `role="listbox"` attribute is applied directly to the `*.Content` component. This makes it impossible to insert additional elements within Content - for example, a search input to filter options - without breaking the ARIA role structure.

Because the entire content area is treated as a listbox, developers can't cleanly compose UI elements like headers, separators, or search fields alongside the options list. This limits flexibility and violates accessibility semantics when done manually.

### Proposal

Introduce new `Select.List` and `Combobox.List` components that live inside their respective `*.Content` components. These `*.List` components will render the list of options and carry the `role="listbox"` attribute, while `*.Content` becomes a more general layout container.

This change makes it possible to add other elements inside `Content` - such as a search field, label, or custom header - without affecting ARIA correctness.

Example Usage:

```diff
<Select.Content>
    <label for="search">Search</label>
    <input id="search" type="text" placeholder="Search options" />
+    <Select.List>
        <Select.Item />
        <Select.Item />
+    </Select.List>
</Select.Content>
```

### Alternatives Considered

- **Keep `role="listbox"` on `*.Content`** - Simplifies the markup but prevents accessible composition of additional content.
- **Infer list semantics automatically based on child structure** - Would introduce unnecessary complexity and unreliable ARIA inference, as well as potential for bugs when the child structure changes.

### Impact

- **Breaking Change:** Developers must wrap `Select.Item` and `Combobox.Item` elements in a new `*.List` component.
- **Improved accessibility:** Ensures proper `role="listbox"` semantics while allowing flexible composition.
- **Greater flexibility:** Enables adding search inputs, headers, and other custom UI elements to the dropdown panel.
- **Cleaner separation of concerns:** `*.Content` manages layout and visibility; `*.List` manages option semantics and keyboard navigation.

## Form Components

### Motivation

SvelteKit has released a ton of new capabilities around forms with remote functions, and we should be able to leverage these to create a more seamless form experience.

Additionally, we should be able to properly leverage the browser's built-in form validation capabilities for our components, such as Checkbox, Radio, Select, DateField, etc.

### Proposal

TBD

### Impact

TBD

## Allow Open on Hover for Floating Components

### Motivation

Currently, users must manually wire up "open on hover" behavior for floating components such as `DropdownMenu` or `Popover`. While this is possible, it's awkward to implement correctly because users don't have direct hooks into the internal open/close logic, focus management, or leave delay handling.

As a result, most hover implementations end up either flickering, breaking keyboard navigation, or leaving the component open unintentionally. This behavior should be supported at the primitive level, where focus and pointer interactions are already managed consistently.

### Proposal

Add an openOnHover prop to all root-level floating components (e.g., `DropdownMenu.Root`, `Popover.Root`, etc.). When enabled, the component will open on pointer hover and close when the user moves the pointer away (when opened with hover), while preserving proper focus and dismissal behavior.

Example Usage:

```svelte
<DropdownMenu.Root openOnHover>
  <!-- ... -->
</DropdownMenu.Root>
```

Hover intent timing (e.g., open/close delays) will be handled internally in a consistent way across components, similar to the logic used by Tooltip.

### Alternatives Considered

None

### Impact

- non-breaking change for existing components, the `openOnHover` prop would be `false` by default
- improved user experience for hover-based floating components

## Filter Inside of Select and/or Combobox

### Motivation

This proposal builds on the new `Select.List` and `Combobox.List` components. Currently, adding a search input inside `Select.Content` or `Combobox.Content` is possible but problematic. Users often introduce ARIA violations by nesting form elements inside a `role="listbox"` container, or they break focus management since Bits UI handles focus internally for these components.

As a result, developers resort to ad-hoc workarounds - placing inputs outside the content area, managing their own state synchronization, or overriding internal focus logic. These approaches make what should be a simple "filterable select" pattern cumbersome and error-prone.

### Proposal

Introduce new subcomponents that enable filtering the list of options within `Select.Content` and `Combobox.Content`, while maintaining correct ARIA and focus behavior.

When these filtering components are present, the root component will automatically adapt its focus management strategy to account for the search input, ensuring smooth keyboard navigation between the input and the option list.

Exact component names and API design will be determined after some experimentation.

### Alternatives Considered

None

### Impact

- **Non-breaking change:** The new filtering components are opt-in.
- **Improved accessibility:** Maintains valid ARIA structure while allowing flexible UI composition.
- **Better UX:** Enables native-feeling, searchable selects and comboboxes without user hacks.
- **Extensibility:** Sets up a foundation for future advanced list behaviors (async loading, virtualized lists, etc.).
