[{"title":"Accordion","content":"  import { APISection, ComponentPreviewV2, AccordionDemo, AccordionDemoTransitions, AccordionDemoCustom, Callout } from '$lib/components/index.js'  export let schemas     {#snippet preview()}  {/snippet}  Overview  The Accordion component is a versatile UI element that organizes content into collapsible sections, enabling users to focus on specific information while reducing visual clutter. It's particularly useful for presenting large amounts of related content in a compact, navigable format.  Key Features  Customizable Behavior**: Can be configured for single or multiple open sections. Accessibility**: ARIA attributes for screen reader compatibility and keyboard navigation. Transition Support**: CSS variables and data attributes for smooth transitions between states. Flexible State Management**: Supports controlled and uncontrolled state, take control if needed. Compound Component Structure**: Provides a set of sub-components that work together to create a fully-featured accordion.  Architecture  The Accordion component is composed of several sub-components, each with a specific role:  Root**: The root element that wraps all accordion items and manages the overall state. Item**: Individual sections within the accordion. Trigger**: The button that toggles the visibility of the content. Header**: The title or heading of each item. Content**: The expandable/collapsible body of each item.  Structure  Here's an overview of how the Accordion component is structured in code:    import { Accordion } from \"bits-ui\";  Reusable Components  If you're planning to use the Accordion component throughout your application, it's recommended to create reusable wrapper components to reduce the amount of code you need to write each time.  For each individual item, you need an Accordion.Item, Accordion.Header, Accordion.Trigger and Accordion.Content component. We can combine these into a single MyAccordionItem component that makes it easier to reuse.    import { Accordion, type WithoutChildrenOrChild } from \"bits-ui\";   type Props = WithoutChildrenOrChild & {   title: string;   content: string;  };   let { title, content, ...restProps }: Props = $props();        {item.title}       {content}     We used the $2 type helper to omit the child and children snippet props from Accordion.ItemProps, since we are opting out of using $2 and are already taking care of rendering the children as text via the content prop.  For our MyAccordion component, we'll accept all the props that Accordion.Root accepts, as well as an additional items prop that will be used to render the MyAccordionItem components.    import { Accordion, type WithoutChildrenOrChild } from \"bits-ui\";  import MyAccordionItem from \"$lib/components/MyAccordionItem.svelte\";   type Item = {   value?: string;   title: string;   content: string;   disabled?: boolean;  };   let {   value = $bindable(),   ref = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   items: Item[];  } = $props();      {#each items as item, i (item.title + i)}     {/each}     import { MyAccordion, MyAccordionItem } from \"$lib/components\";     Content 1  Content 2  Content 3  Managing Value State  Bits UI offers several approaches to manage and synchronize the Accordion's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the accordion's internal state.    import { Accordion } from \"bits-ui\";  let myValue = $state([]);    {   myValue = [\"item-1\", \"item-2\"];  }}  Open Items 1 and 2  Key Benefits  Simplifies state management Automatically updates myValue when the accordion changes (e.g., via clicking on an item's trigger) Allows external control (e.g., opening an item via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Accordion } from \"bits-ui\";  let myValue = $state([]);    {   myValue = value;   // additional logic here.  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the accordion's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the accordion responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the Accordion.Root component. Provide a value prop to Accordion.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { Accordion } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = v)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Single Type  Set the type prop to \"single\" to allow only one accordion item to be open at a time.  Multiple Type  Set the type prop to \"multiple\" to allow multiple accordion items to be open at the same time.  Default Open Items  To set default open items, pass them as the value prop, which will be an array if the type is \"multiple\", or a string if the type is \"single\".  Disable Items  To disable an individual accordion item, set the disabled prop to true. This will prevent users from interacting with the item.  Svelte Transitions  The Accordion component can be enhanced with Svelte's built-in transition effects or other animation libraries.  Using forceMount and child Snippets  To apply Svelte transitions to Accordion components, use the forceMount prop in combination with the child snippet. This approach gives you full control over the mounting behavior and animation of the Accordion.Content.    {#snippet child({ props, open })}   {#if open}         This is the accordion content that will transition in and out.       {/if}  {/snippet}   In this example:  The forceMount prop ensures the components are always in the DOM. The child snippet provides access to the open state and component props. Svelte's #if block controls when the content is visible. Transition directives (transition:fade and transition:fly) apply the animations.    {#snippet preview()}  {/snippet}  Best Practices  For cleaner code and better maintainability, consider creating custom reusable components that encapsulate this transition logic.    import { Accordion, type WithoutChildrenOrChild } from \"bits-ui\";  import type { Snippet } from \"svelte\";  import { fade } from \"svelte/transition\";   let {   ref = $bindable(null),   duration = 200,   children,   ...restProps  }: WithoutChildrenOrChild & {   duration?: number;   children: Snippet;  } = $props();     {#snippet child({ props, open })}   {#if open}         {@render children?.()}       {/if}  {/snippet}   You can then use the MyAccordionContent component alongside the other Accordion primitives throughout your application:           A                  ","description":"Organizes content into collapsible sections, allowing users to focus on one or more sections at a time.","href":"/docs/components/accordion"},{"title":"Alert Dialog","content":"  import { APISection, ComponentPreviewV2, AlertDialogDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Key Features  Compound Component Structure**: Offers a set of sub-components that work together to create a fully-featured alert dialog. Accessibility**: Built with WAI-ARIA guidelines in mind, ensuring keyboard navigation and screen reader support. Customizable**: Each sub-component can be styled and configured independently. Portal Support**: Content can be rendered in a portal, ensuring proper stacking context. Managed Focus**: Automatically manages focus, with the option to take control if needed. Flexible State Management**: Supports both controlled and uncontrolled state, allowing for full control over the dialog's open state.  Architecture  The Alert Dialog component is composed of several sub-components, each with a specific role:  Root**: The main container component that manages the state of the dialog. Provides context for all child components. Trigger**: A button that toggles the dialog's open state. Portal**: Renders its children in a portal, outside the normal DOM hierarchy. Overlay**: A backdrop that sits behind the dialog content. Content**: The main container for the dialog's content. Title**: Renders the dialog's title. Description**: Renders a description or additional context for the dialog. Cancel**: A button that closes the dialog by cancelling the action. Action**: A button that closes the dialog by taking an action.  Structure    import { AlertDialog } from \"bits-ui\";  Reusable Components  Bits UI provides a decent number of components to construct an Alert Dialog. The idea is to provide a set of building blocks that can be used to create a variety of different components. It's recommended to use these components to build your own reusable Alert Dialog components that can be used throughout your application.  The following example shows at a high level how you might create a reusable Alert Dialog component. We've mixed and matched string props and snippets to demonstrate the flexibility of the component API. Use whatever makes sense for you.  This example is used in a few places throughout this documentation page to give you a better idea of how it's used.    import type { Snippet } from \"svelte\";  import { AlertDialog, type WithoutChild } from \"bits-ui\";   type Props = AlertDialog.RootProps & {   buttonText: string;   title: Snippet;   description: Snippet;   contentProps?: WithoutChild;   // ...other component props if you wish to pass them  };   let {   open = $bindable(false),   children,   buttonText,   contentProps,   title,   description,   ...restProps  }: Props = $props();        {buttonText}                   {@render title()}             {@render description()}        {@render children?.()}    Cancel    Confirm        You can then use the MyAlertDialog component in your application like so:    import MyAlertDialog from \"$lib/components/MyAlertDialog.svelte\";     {#snippet title()}   Delete your account  {/snippet}  {#snippet description()}   This action cannot be undone.  {/snippet}   Alternatively, you can define the snippets separately and pass them as props to the component:    import MyAlertDialog from \"$lib/components/MyAlertDialog.svelte\";   {#snippet title()}  Delete your account {/snippet} {#snippet description()}  This action cannot be undone. {/snippet}  Managing Open State  Bits UI offers several approaches to manage and synchronize the Alert Dialog's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the dialog's internal state.    import { AlertDialog } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Dialog  Key Benefits  Simplifies state management Automatically updates isOpen when the dialog closes (e.g., via escape key) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { AlertDialog } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = open;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the dialog's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the dialog responds to open/close events.    import { AlertDialog } from \"bits-ui\";   let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Focus  Focus Trap  By default, when a dialog is opened, focus will be trapped within the Dialog, preventing the user from interacting with the rest of the page. This follows the $2 for alert dialogs.  Although it isn't recommended unless absolutely necessary, you can disabled this behavior by setting the trapFocus prop to false on the AlertDialog.Content component.  Open Focus  By default, when a dialog is opened, focus will be set to the AlertDialog.Cancel button if it exists, or the first focusable element within the AlertDialog.Content. This ensures that users navigating my keyboard end up somewhere within the Dialog that they can interact with.  You can override this behavior using the onOpenAutoFocus prop on the AlertDialog.Content component. It's highly recommended that you use this prop to focus something within the Dialog.  You'll first need to cancel the default behavior of focusing the first focusable element by cancelling the event passed to the onOpenAutoFocus callback. You can then focus whatever you wish.    import { AlertDialog } from \"bits-ui\";  let nameInput = $state();     Open AlertDialog   {    e.preventDefault();    nameInput?.focus();   }} Close Focus  By default, when a dialog is closed, focus will be set to the trigger element of the dialog. You can override this behavior using the onCloseAutoFocus prop on the AlertDialog.Content component.  You'll need to cancel the default behavior of focusing the trigger element by cancelling the event passed to the onCloseAutoFocus callback, and then focus whatever you wish.    import { AlertDialog } from \"bits-ui\";  let nameInput = $state();      Open AlertDialog   {    e.preventDefault();    nameInput?.focus();   }} Advanced Behaviors  The Alert Dialog component offers several advanced features to customize its behavior and enhance user experience. This section covers scroll locking, escape key handling, and interaction outside the dialog.  Scroll Lock  By default, when an Alert Dialog opens, scrolling the body is disabled. This provides a more native-like experience, focusing user attention on the dialog content.  Customizing Scroll Behavior  To allow body scrolling while the dialog is open, use the preventScroll prop on AlertDialog.Content:         Enabling body scroll may affect user focus and accessibility. Use this option judiciously.  Escape Key Handling  By default, pressing the Escape key closes an open Alert Dialog. Bits UI provides two methods to customize this behavior.  Method 1: escapeKeydownBehavior  The escapeKeydownBehavior prop allows you to customize the behavior taken by the component when the Escape key is pressed. It accepts one of the following values:  'close' (default): Closes the Alert Dialog immediately. 'ignore': Prevents the Alert Dialog from closing. 'defer-otherwise-close': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Alert Dialog will close immediately. 'defer-otherwise-ignore': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Alert Dialog will ignore the key press and not close.  To always prevent the Alert Dialog from closing on Escape key press, set the escapeKeydownBehavior prop to 'ignore' on Dialog.Content:  Method 2: onEscapeKeydown  For more granular control, override the default behavior using the onEscapeKeydown prop:   {   e.preventDefault();   // do something else instead  }}     This method allows you to implement custom logic when the Escape key is pressed.  Interaction Outside  By default, interacting outside the Alert Dialog content area closes the Alert Dialog. Bits UI offers two ways to modify this behavior.  Method 1: interactOutsideBehavior  The interactOutsideBehavior prop allows you to customize the behavior taken by the component when an interaction (touch, mouse, or pointer event) occurs outside the content. It accepts one of the following values:  'close' (default): Closes the Alert Dialog immediately. 'ignore': Prevents the Alert Dialog from closing. 'defer-otherwise-close': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Alert Dialog will close immediately. 'defer-otherwise-ignore': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Alert Dialog will ignore the event and not close.  To always prevent the Alert Dialog from closing on Escape key press, set the escapeKeydownBehavior prop to 'ignore' on Alert.Content:  Method 2: onInteractOutside  For custom handling of outside interactions, you can override the default behavior using the onInteractOutside prop:   {   e.preventDefault();   // do something else instead  }}     This approach allows you to implement specific behaviors when users interact outside the Alert Dialog content.  Best Practices  Scroll Lock**: Consider your use case carefully before disabling scroll lock. It may be necessary for dialogs with scrollable content or for specific UX requirements. Escape Keydown**: Overriding the default escape key behavior should be done thoughtfully. Users often expect the escape key to close modals. Outside Interactions**: Ignoring outside interactions can be useful for important dialogs or multi-step processes, but be cautious not to trap users unintentionally. Accessibility**: Always ensure that any customizations maintain or enhance the dialog's accessibility. User Expectations**: Try to balance custom behaviors with common UX patterns to avoid confusing users.  By leveraging these advanced features, you can create highly customized dialog experiences while maintaining usability and accessibility standards.  Nested Dialogs  Dialogs can be nested within each other to create more complex layouts. See the $2 component for more information on nested dialogs.  Svelte Transitions  See the $2 component for more information on Svelte Transitions with dialog components.  Working with Forms  Form Submission  When using the AlertDialog component, often you'll want to submit a form or perform an asynchronous action when the user clicks the Action button.  This can be done by waiting for the asynchronous action to complete, then programmatically closing the dialog.    import { AlertDialog } from \"bits-ui\";   function wait(ms: number) {   return new Promise((resolve) => setTimeout(resolve, ms));  }   let open = $state(false);               Confirm your action    Are you sure you want to do this?     {      wait(1000).then(() => (open = false));     }}     No, cancel (close dialog)     Yes (submit form) Inside a Form  If you're using an AlertDialog within a form, you'll need to ensure that the Portal is disabled or not included in the AlertDialog structure. This is because the Portal will render the dialog content outside of the form, which will prevent the form from being submitted correctly.  ","description":"A modal window that alerts users with important information and awaits their acknowledgment or action.","href":"/docs/components/alert-dialog"},{"title":"Aspect Ratio","content":"  import { APISection, ComponentPreviewV2, AspectRatioDemo } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Architecture  Root**: The root component which contains the aspect ratio logic  Structure  Here's an overview of how the Aspect Ratio component is structured in code:    import { AspectRatio } from \"bits-ui\";  Reusable Component  If you plan on using a lot of AspectRatio components throughout your application, you can create a reusable component that combines the AspectRatio.Root and whatever other elements you'd like to render within it. In the following example, we're creating a reusable MyAspectRatio component that takes in a src prop and renders an img element with the src prop.    import { AspectRatio, type WithoutChildrenOrChild } from \"bits-ui\";   let {   src,   alt,   ref = $bindable(null),   imageRef = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   src: string;   alt: string;   imageRef?: HTMLImageElement | null;  } = $props();        You can then use the MyAspectRatio component in your application like so:    import MyAspectRatio from \"$lib/components/MyAspectRatio.svelte\";  Custom Ratio  Use the ratio prop to set a custom aspect ratio for the image.       ","description":"Displays content while maintaining a specified aspect ratio, ensuring consistent visual proportions.","href":"/docs/components/aspect-ratio"},{"title":"Avatar","content":"  import { APISection, ComponentPreviewV2, AvatarDemo } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  The Avatar component is designed to represent a user or entity within your application's user interface. It provides a flexible and accessible way to display profile pictures or placeholder images.  Key Features  Compound Component Structure**: Offers a set of sub-components that work together to create a fully-featured avatar. Fallback Mechanism**: Provides a fallback when the primary image is unavailable or loading. Customizable**: Each sub-component can be styled and configured independently to match your design system.  Architecture  The Avatar component is composed of several sub-components, each with a specific role:  Root**: The main container component that manages the state of the avatar. Image**: The primary image element that displays the user's profile picture or a representative image. Fallback**: The fallback element that displays alternative content when the primary image is unavailable or loading.  Structure  Here's an overview of how the Avatar component is structured in code:    import { Avatar } from \"bits-ui\";  Reusable Components  You can create your own reusable components that combine the Avatar primitives and simplify the usage throughout your application. In the following example, we're creating a reusable MyAvatar component that takes in a src and fallback prop and renders an Avatar.Root component with an Avatar.Image and Avatar.Fallback component.    import { Avatar, type WithoutChildrenOrChild } from \"bits-ui\";   let {   src,   alt,   fallback,   ref = $bindable(null),   imageRef = $bindable(null),   fallbackRef = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   src: string;   alt: string;   fallback: string;   imageRef?: HTMLImageElement | null;   fallbackRef?: HTMLElement | null;  } = $props();          {fallback}     You could then use the MyAvatar component in your application like so:    import MyAvatar from \"$lib/components/MyAvatar.svelte\";     ","description":"Represents a user or entity with a recognizable image or placeholder in UI elements.","href":"/docs/components/avatar"},{"title":"Button","content":"  import { APISection, ComponentPreviewV2, ButtonDemo } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Button } from \"bits-ui\";     ","description":"A component that if passed a `href` prop will render an anchor element instead of a button element.","href":"/docs/components/button"},{"title":"Calendar","content":"  import { APISection, ComponentPreviewV2, CalendarDemo, Callout } from '$lib/components'  export let schemas;     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Structure    import { Calendar } from \"bits-ui\";     {#snippet children({ months, weekdays })}                      {#each months as month}                      {#each weekdays as day}                 {day}               {/each}                      {#each month.weeks as weekDates}               {#each weekDates as date}                                    {/each}             {/each}            {/each}  {/snippet}  Placeholder  The placeholder prop for the Calendar.Root component determines what date our calendar should start with when the user hasn't selected a date yet. It also determines the current \"view\" of the calendar.  As the user navigates through the calendar, the placeholder will be updated to reflect the currently focused date in that view.  By default, the placeholder will be set to the current date, and be of type CalendarDate.  Managing Placeholder State  Bits UI offers several approaches to manage and synchronize the component's placeholder state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:placeholder directive. This method automatically keeps your local state in sync with the component's internal state.    import { Calendar } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myPlaceholder = new CalendarDate(2024, 8, 3))}>  Set placeholder to August 3rd, 2024  Key Benefits  Simplifies state management Automatically updates myPlaceholder when the internal state changes Allows external control (e.g., changing the placeholder via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onPlaceholderChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Calendar } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    {   placeholder = p;  }} Use Cases  Implementing custom behaviors on placeholder change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's placeholder state, use the controlledPlaceholder prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledPlaceholder prop to true on the Calendar.Root component. Provide a placeholder prop to Calendar.Root, which should be a variable holding the current state. Implement an onPlaceholderChange handler to update the state when the internal state changes.    import { Calendar } from \"bits-ui\";  let myPlaceholder = $state();    (myPlaceholder = p)} When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Value State  Bits UI offers several approaches to manage and synchronize the component's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { Calendar } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myValue = myValue.add({ days: 1 }))}> Add 1 day   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes Allows external control (e.g., changing the value via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Calendar } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    {   value = v.set({ hour: v.hour + 1 });  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledValue prop to true on the Calendar.Root component. Provide a value prop to Calendar.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { Calendar } from \"bits-ui\";  let myValue = $state();    (myValue = v)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Default Value  Often, you'll want to start the Calendar.Root component with a default value. Likely this value will come from a database in the format of an ISO 8601 string.  You can use the parseDate function from the @internationalized/date package to parse the string into a CalendarDate object.    import { Calendar } from \"bits-ui\";  import { parseDate } from \"@internationalized/date\";   // this came from a database/API call  const date = \"2024-08-03\";   let value = $state(parseDate(date));  Validation  Minimum Value  You can set a minimum value for the calendar by using the minValue prop on Calendar.Root. If a user selects a date that is less than the minimum value, the calendar will be marked as invalid.    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const yesterday = todayDate.subtract({ days: 1 });  Maximum Value  You can set a maximum value for the calendar by using the maxValue prop on Calendar.Root. If a user selects a date that is greater than the maximum value, the calendar will be marked as invalid.    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const tomorrow = todayDate.add({ days: 1 });  Unavailable Dates  You can specify specific dates that are unavailable for selection by using the isDateUnavailable prop. This prop accepts a function that returns a boolean value indicating whether a date is unavailable or not.    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone, isNotNull } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const tomorrow = todayDate.add({ days: 1 });   function isDateUnavailable(date: DateValue) {   return date.day === 1;  }  Disabled Dates  You can specify specific dates that are disabled for selection by using the isDateDisabled prop.    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone, isNotNull } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const tomorrow = todayDate.add({ days: 1 });   function isDateDisabled(date: DateValue) {   return date.day === 1;  }  Appearance & Behavior  Fixed Weeks  You can use the fixedWeeks prop to ensure that the calendar renders a fixed number of weeks, regardless of the number of days in the month. This is useful to keep the calendar visually consistent when the number of days in the month changes.  Multiple Months  You can use the numberOfMonths prop to render multiple months at once.  Paged Navigation  By default, when the calendar has more than one month, the previous and next buttons will shift the calendar forward or backward by one month. However, you can change this behavior by setting the pagedNavigation prop to true, which will shift the calendar forward or backward by the number of months being displayed.  Localization  The calendar will automatically format the content of the calendar according to the locale prop, which defaults to 'en-US', but can be changed to any locale supported by the $2 API.  Week Starts On  The calendar will automatically format the content of the calendar according to the weekStartsOn prop, which defaults to 0, but can be changed to any day of the week, where 0 is Sunday and 6 is Saturday.  Multiple Selection  You can set the type prop to 'multiple' to allow users to select multiple dates at once.  Custom Composition  Month Selector  The Calendar component includes a PrevButton and NextButton component to allow users to navigate between months. This is useful, but sometimes you may want to allow the user to select a specific month from a list of months, rather than having to navigate one at a time.  To achieve this, you can use the placeholder prop to set the month of the the calendar view programmatically.    import { Calendar } from \"bits-ui\";  import { CalendarDate } from \"@internationalized/date\";   let placeholder = $state(new CalendarDate(2024, 8, 3));     {   placeholder = placeholder.set({ month: 8 });  }}  Set month to August        Updating the placeholder will update the calendar view to reflect the new month.  ","description":"Displays dates and days of the week, facilitating date-related interactions.","href":"/docs/components/calendar"},{"title":"Checkbox","content":"  import { APISection, ComponentPreviewV2, CheckboxDemo, CheckboxDemoCustom, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  The Checkbox component provides a flexible and accessible way to create checkbox inputs in your Svelte applications. It supports three states: checked, unchecked, and indeterminate, allowing for complex form interactions and data representations.  Key Features  Tri-State Support**: Handles checked, unchecked, and indeterminate states, providing versatility in form design. Accessibility**: Built with WAI-ARIA guidelines in mind, ensuring keyboard navigation and screen reader support. Flexible State Management**: Supports both controlled and uncontrolled state, allowing for full control over the checkbox's checked state.  Architecture  The Checkbox component is composed of the following parts:  Root**: The main component that manages the state and behavior of the checkbox.  Structure  Here's an overview of how the Checkbox component is structured in code:    import { Checkbox } from \"bits-ui\";     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {:else}    ❌   {/if}  {/snippet}  Reusable Components  It's recommended to use the Checkbox primitive to create your own custom checkbox component that can be used throughout your application. In the example below, we're using the Checkbox and $2 components to create a custom checkbox component.    import { Checkbox, Label, useId, type WithoutChildrenOrChild } from \"bits-ui\";   let {   id = useId(),   checked = $bindable(false),   ref = $bindable(null),   labelRef = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   labelText: string;   labelRef?: HTMLLabelElement | null;  } = $props();     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {:else}    ❌   {/if}  {/snippet}    {labelText}   You can then use the MyCheckbox component in your application like so:    import MyCheckbox from \"$lib/components/MyCheckbox.svelte\";  Managing Checked State  Bits UI offers several approaches to manage and synchronize the Checkbox's checked state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:checked directive. This method automatically keeps your local state in sync with the checkbox's internal state.    import MyCheckbox from \"$lib/components/MyCheckbox.svelte\";  let myChecked = $state(false);    (myChecked = false)}> uncheck   Key Benefits  Simplifies state management Automatically updates myChecked when the checkbox changes (e.g., via clicking on the checkbox) Allows external control (e.g., checking via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onCheckedChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import MyCheckbox from \"$lib/components/MyCheckbox.svelte\";  let myChecked = $state(false);    {   myChecked = checked;   if (checked === \"indeterminate\") {    // do something different   }   // additional logic here.  }} />  Use Cases  Implementing custom behaviors on checked/unchecked Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the checkbox's checked state, use the controlledChecked prop. This approach requires you to manually manage the checked state, giving you full control over when and how the checkbox responds to change events.  To implement controlled state:  Set the controlledChecked prop to true on the Checkbox.Root component. Provide a checked prop to Checkbox.Root, which should be a variable holding the current state. Implement an onCheckedChange handler to update the state when the internal state changes.    import { Checkbox } from \"bits-ui\";  let myChecked = $state(false);    (myChecked = c)}> When to Use  Implementing complex checked/unchecked logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Indeterminate State  Bits UI offers several approaches to manage and synchronize the Checkbox's indeterminate state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:indeterminate directive. This method automatically keeps your local state in sync with the checkbox's internal state.    import MyCheckbox from \"$lib/components/MyCheckbox.svelte\";  let myIndeterminate = $state(true);    (myIndeterminate = false)}> clear indeterminate   Key Benefits  Simplifies state management Automatically updates myIndeterminate when the checkbox changes (e.g., via clicking on the checkbox) Allows external control (e.g., checking via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onIndeterminateChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import MyCheckbox from \"$lib/components/MyCheckbox.svelte\";  let myIndeterminate = $state(true);    {   myIndeterminate = indeterminate;   // additional logic here.  }} />  Use Cases  Implementing custom behaviors Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the checkbox's checked state, use the controlledIndeterminate prop. This approach requires you to manually manage the indeterminate state, giving you full control over when and how the checkbox responds to change events.  To implement controlled state:  Set the controlledIndeterminate prop to true on the Checkbox.Root component. Provide a indeterminate prop to Checkbox.Root, which should be a variable holding the current state. Implement an onIndeterminateChange handler to update the state when the internal state changes.    import { Checkbox } from \"bits-ui\";  let myIndeterminate = $state(true);    (myIndeterminate = i)} When to Use  Implementing complex indeterminate logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Disabled State  You can disable the checkbox by setting the disabled prop to true.  HTML Forms  If you set the name prop, a hidden checkbox input will be rendered to submit the value of the checkbox with a form.  By default, the checkbox will be submitted with default checkbox value of 'on' if the checked prop is true.  Custom Input Value  If you'd prefer to submit a different value, you can use the value prop to set the value of the hidden input.  For example, if you wanted to submit a string value, you could do the following:  Required  If you want to make the checkbox required, you can use the required prop.       This will apply the required attribute to the hidden input element, ensuring that proper form submission is enforced.  ","description":"Allow users to switch between checked, unchecked, and indeterminate states.","href":"/docs/components/checkbox"},{"title":"Collapsible","content":"  import { APISection, ComponentPreviewV2, CollapsibleDemo, CollapsibleDemoTransitions, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  The Collapsible component enables you to create expandable and collapsible content sections. It provides an efficient way to manage space and organize information in user interfaces, enabling users to show or hide content as needed.  Key Features  Accessibility**: ARIA attributes for screen reader compatibility and keyboard navigation. Transition Support**: CSS variables and data attributes for smooth transitions between states. Flexible State Management**: Supports controlled and uncontrolled state, take control if needed. Compound Component Structure**: Provides a set of sub-components that work together to create a fully-featured collapsible.  Architecture  The Accordion component is composed of a few sub-components, each with a specific role:  Root**: The parent container that manages the state and context for the collapsible functionality. Trigger**: The interactive element (e.g., button) that toggles the expanded/collapsed state of the content. Content**: The container for the content that will be shown or hidden based on the collapsible state.  Structure  Here's an overview of how the Collapsible component is structured in code:    import { Collapsible } from \"bits-ui\";  Reusable Components  It's recommended to use the Collapsible primitives to create your own custom collapsible component that can be used throughout your application.    import { Collapsible, type WithoutChild } from \"bits-ui\";   type Props = WithoutChild & {   buttonText: string;  };   let {   open = $bindable(false),   ref = $bindable(null),   buttonText,   children,   ...restProps  }: Props = $props();     {buttonText}     {@render children?.()}     You can then use the MyCollapsible component in your application like so:    import MyCollapsible from \"$lib/components/MyCollapsible.svelte\";   Here is my collapsible content.  Managing Open State  Bits UI offers several approaches to manage and synchronize the Collapsible's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the Collapsible's internal state.    import { Collapsible } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Collapsible  Key Benefits  Simplifies state management Automatically updates isOpen when the collapsible closes (e.g., via trigger press) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Collapsible } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = open;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the Collapsible's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the collapsible responds to open/close events.  To implement controlled state:  Set the controlledOpen prop to true on the Collapsible.Root component. Provide an open prop to Collapsible.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { Collapsible } from \"bits-ui\";   let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Svelte Transitions  The Collapsible component can be enhanced with Svelte's built-in transition effects or other animation libraries.  Using forceMount and child Snippets  To apply Svelte transitions to Collapsible components, use the forceMount prop in combination with the child snippet. This approach gives you full control over the mounting behavior and animation of the Collapsible.Content.    import { Collapsible } from \"bits-ui\";  import { fade } from \"svelte/transition\";     Open     {#snippet child({ props, open })}    {#if open}                    {/if}   {/snippet}     In this example:  The forceMount prop ensures the content is always in the DOM. The child snippet provides access to the open state and component props. Svelte's #if block controls when the content is visible. Transition directive (transition:fade) apply the animations.  Best Practices  For cleaner code and better maintainability, consider creating custom reusable components that encapsulate this transition logic.    import { Collapsible, type WithoutChildrenOrChild } from \"bits-ui\";  import { fade } from \"svelte/transition\";  import type { Snippet } from \"svelte\";   let {   ref = $bindable(null),   duration = 200,   children,   ...restProps  }: WithoutChildrenOrChild & {   duration?: number;   children?: Snippet;  } = $props();     {#snippet child({ props, open })}   {#if open}         {@render children?.()}       {/if}  {/snippet}   You can then use the MyCollapsibleContent component alongside the other Collapsible primitives throughout your application:    import { Collapsible } from \"bits-ui\";  import { MyCollapsibleContent } from \"$lib/components\";     Open          ","description":"Conceals or reveals content sections, enhancing space utilization and organization.","href":"/docs/components/collapsible"},{"title":"Combobox","content":"  import { APISection, ComponentPreviewV2, ComboboxDemo, ComboboxDemoTransition, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  The Combobox component combines the functionality of an input field with a dropdown list of selectable options. It provides users with the ability to search, filter, and select from a predefined set of choices.  Key Features  Keyboard Navigation**: Full support for keyboard interactions, allowing users to navigate and select options without using a mouse. Customizable Rendering**: Flexible architecture for rendering options, including support for grouped items. Accessibility**: Built with ARIA attributes and keyboard interactions to ensure screen reader compatibility and accessibility standards. Portal Support**: Ability to render the dropdown content in a portal, preventing layout issues in complex UI structures.  Architecture  The Combobox component is composed of several sub-components, each with a specific role:  Root**: The main container component that manages the state and context for the combobox. Input**: The input field that allows users to enter search queries. Trigger**: The button or element that opens the dropdown list. Portal**: Responsible for portalling the dropdown content to the body or a custom target. Group**: A container for grouped items, used to group related items. GroupHeading**: A heading for a group of items, providing a descriptive label for the group. Item**: An individual item within the list. Separator**: A visual separator between items. Content**: The dropdown container that displays the items. It uses $2 to position the content relative to the trigger. ContentStatic**: An alternative to the Content component, that enables you to opt-out of Floating UI and position the content yourself. Arrow**: An arrow element that points to the trigger when using the Combobox.Content component.  Structure  Here's an overview of how the Combobox component is structured in code:    import { Combobox } from \"bits-ui\";  Reusable Components  It's recommended to use the Combobox primitives to build your own custom combobox component that can be reused throughout your application.    import { Combobox, type WithoutChildrenOrChild, mergeProps } from \"bits-ui\";   type Item = { value: string; label: string };   type Props = Combobox.RootProps & {   items: Item[];   inputProps?: WithoutChildrenOrChild;   contentProps?: WithoutChildrenOrChild;  };   let {   items,   value = $bindable(),   open = $bindable(false),   inputProps,   contentProps,   ...restProps  }: Props = $props();   let searchValue = $state(\"\");   const filteredItems = $derived.by(() => {   if (searchValue === \"\") return items;   return items.filter((item) => item.label.toLowerCase().includes(searchValue.toLowerCase()));  });   function handleInput(e: Event & { currentTarget: HTMLInputElement }) {   searchValue = e.currentTarget.value;  }   function handleOpenChange(newOpen: boolean) {   if (!newOpen) searchValue = \"\";  }   const mergedRootProps = $derived(mergeProps(restProps, { onOpenChange: handleOpenChange }));  const mergedInputProps = $derived(mergeProps(inputProps, { oninput: handleInput }));       Open         {#each filteredItems as item, i (i + item.value)}           {#snippet children({ selected })}       {item.label}       {selected ? \"✅\" : \"\"}      {/snippet}         {:else}      No results found     {/each}          import { CustomCombobox } from \"$lib/components\";   const items = [   { value: \"mango\", label: \"Mango\" },   { value: \"watermelon\", label: \"Watermelon\" },   { value: \"apple\", label: \"Apple\" },   // ...  ];  Managing Value State  Bits UI offers several approaches to manage and synchronize the Combobox's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { Combobox } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"A\")}> Select A   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., via clicking on an item) Allows external control (e.g., selecting an item via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Combobox } from \"bits-ui\";  let myValue = $state(\"\");    {   myValue = value;   // additional logic here.  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the Combobox.Root component. Provide a value prop to Combobox.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { Combobox } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = v)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Open State  Bits UI offers several approaches to manage and synchronize the Combobox's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the component's internal state.    import { Combobox } from \"bits-ui\";  let myOpen = $state(false);    (myOpen = true)}> Open   Key Benefits  Simplifies state management Automatically updates myOpen when the internal state changes (e.g., via clicking on the trigger/input) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Combobox } from \"bits-ui\";  let myOpen = $state(false);    {   myOpen = o;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledOpen prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledOpen prop to true on the Combobox.Root component. Provide an open prop to Combobox.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { Combobox } from \"bits-ui\";  let myOpen = $state(false);    (myOpen = v)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Opt-out of Floating UI  When you use the Combobox.Content component, Bits UI uses $2 to position the content relative to the trigger, similar to other popover-like components.  You can opt-out of this behavior by instead using the Combobox.ContentStatic component.                                                               When using this component, you'll need to handle the positioning of the content yourself. Keep in mind that using Combobox.Portal alongside Combobox.ContentStatic may result in some unexpected positioning behavior, feel free to not use the portal or work around it.  Custom Anchor  By default, the Combobox.Content is anchored to the Combobox.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the Combobox.Content component.    import { Combobox } from \"bits-ui\";   let customAnchor = $state(null!);  What is the Viewport?  The Combobox.Viewport component is used to determine the size of the content in order to determine whether or not the scroll up and down buttons should be rendered.  If you wish to set a minimum/maximum height for the select content, you should apply it to the Combobox.Viewport component.  Scroll Up/Down Buttons  The Combobox.ScrollUpButton and Combobox.ScrollDownButton components are used to render the scroll up and down buttons when the select content is larger than the viewport.  You must use the Combobox.Viewport component when using the scroll buttons.  Native Scrolling/Overflow  If you don't want to use the scroll buttons and prefer to use the standard scrollbar/overflow behavior, you can omit the Combobox.Scroll[Up|Down]Button components and the Combobox.Viewport component.  You'll need to set a height on the Combobox.Content component and appropriate overflow styles to enable scrolling.  Scroll Lock  By default, when a user opens the Combobox, scrolling outside the content will be disabled. You can override this behavior by setting the preventScroll prop to false.  Highlighted Items  The Combobox component follows the $2 for highlighting items. This means that the Combobox.Input retains focus the entire time, even when navigating with the keyboard, and items are highlighted as the user navigates them.  Styling Highlighted Items  You can use the data-highlighted attribute on the Combobox.Item component to style the item differently when it is highlighted.  onHighlight / onUnhighlight  To trigger side effects when an item is highlighted or unhighlighted, you can use the onHighlight and onUnhighlight props.   console.log('I am highlighted!')} onUnhighlight={() => console.log('I am unhighlighted!')} />  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Combobox.Content component to use Svelte Transitions or another animation library that requires more control.    import { Combobox } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ props, open })}   {#if open}                {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Enables users to pick from a list of options displayed in a dropdown.","href":"/docs/components/combobox"},{"title":"Command","content":"  import { APISection, ComponentPreviewV2, CommandDemo, CommandDemoDialog, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  The Command component, also known as a command menu, is designed to provide users with a quick and efficient way to search, filter, and select items within an application. It combines the functionality of a search input with a dynamic, filterable list of commands or options, making it ideal for applications that require fast navigation or action execution.  Key Features  Dynamic Filtering**: As users type in the input field, the list of commands or items is instantly filtered and sorted based on an (overridable) scoring algorithm. Keyboard Navigation**: Full support for keyboard interactions, allowing users to quickly navigate and select items without using a mouse. Grouped Commands**: Ability to organize commands into logical groups, enhancing readability and organization. Empty and Loading States**: Built-in components to handle scenarios where no results are found or when results are being loaded. Accessibility**: Designed with ARIA attributes and keyboard interactions to ensure screen reader compatibility and accessibility standards.  Architecture  The Command component is composed of several sub-components, each with a specific role:  Root**: The main container that manages the overall state and context of the command menu. Input**: The text input field where users can type to search or filter commands. List**: The container for the list of commands or items. Viewport**: The visible area of the command list, which applies CSS variables to handle dynamic resizing/animations based on the height of the list. Empty**: A component to display when no results are found. Loading**: A component to display while results are being fetched or processed. Group**: A container for a group of items within the command menu. GroupHeading**: A header element to provide an accessible label for a group of items. GroupItems**: A container for the items within a group. Item**: Individual selectable command or item. LinkItem**: A variant of Command.Item specifically for link-based actions. Separator**: A visual separator to divide different sections of the command list.  Structure  Here's an overview of how the Command component is structured in code:    import { Combobox } from \"bits-ui\";  Managing Value State  Bits UI offers several approaches to manage and synchronize the Command's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { Command } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"A\")}> Select A   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., via clicking on an item) Allows external control (e.g., selecting an item via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Command } from \"bits-ui\";  let myValue = $state(\"\");    {   myValue = value;   // additional logic here.  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the Command.Root component. Provide a value prop to Command.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { Command } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = v)}> When to Use  Implementing complex value change logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  In a Modal  You can combine the Command component with the Dialog component to display the command menu within a modal.      {#snippet preview()}  {/snippet}  Filtering  Custom Filter  By default, the Command component uses a scoring algorithm to determine how the items should be sorted/filtered. You can provide a custom filter function to override this behavior.  The function should return a number between 0 and 1, with 1 being a perfect match, and 0 being no match, resulting in the item being hidden entirely.  The following example shows how you might implement a strict substring match filter:    import { Command } from \"bits-ui\";   function customFilter(value: string, search: string, keywords?: string[]): number {   return value.includes(search) ? 1 : 0;  }  Disable Filtering  You can disable filtering by setting the shouldFilter prop to false.       This is useful when you have a lot of custom logic, need to fetch items asynchronously, or just want to handle filtering yourself. You'll be responsible for iterating over the items and determining which ones should be shown.  Item Selection  You can use the onSelect prop to handle the selection of items.   console.log(\"selected something!\")} />  Links  If you want one of the items to get all the benefits of a link (prefetching, etc.), you should use the Command.LinkItem component instead of the Command.Item component. The only difference is that the Command.LinkItem component will render an a element instead of a div element.       ","description":"A command menu component that can be used to search, filter, and select items.","href":"/docs/components/command"},{"title":"Context Menu","content":"  import { APISection, ComponentPreviewV2, ContextMenuDemo, ContextMenuDemoTransition, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { ContextMenu } from \"bits-ui\";                                           {#snippet children({ checked })}      {checked ? \"✅\" : \"\"}     {/snippet}                         {#snippet children({ checked })}       {checked ? \"✅\" : \"\"}      {/snippet} Reusable Components  If you're planning to use Context Menu in multiple places, you can create a reusable component that wraps the Context Menu component.  This example shows you how to create a Context Menu component that accepts a few custom props that make it more capable.    import type { Snippet } from \"svelte\";  import { ContextMenu, type WithoutChild } from \"bits-ui\";  type Props = ContextMenu.Props & {   trigger: Snippet;   items: string[];   contentProps?: WithoutChild;   // other component props if needed  };  let {   open = $bindable(false),   children,   trigger,   items,   contentProps,   ...restProps  }: Props = $props();        {@render trigger()}                Select an Office     {#each items as item}             {item}           {/each}            You can then use the CustomContextMenu component like this:    import CustomContextMenu from \"./CustomContextMenu.svelte\";     {#snippet triggerArea()}       Right-click me     {/snippet}   Alternatively, you can define the snippet(s) separately and pass them as props to the component:    import CustomContextMenu from \"./CustomContextMenu.svelte\";   {#snippet triggerArea()}     Right-click me   {/snippet}  Managing Open State  Bits UI offers several approaches to manage and synchronize the Context Menu's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the component's internal state.    import { ContextMenu } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Context Menu  Key Benefits  Simplifies state management Automatically updates isOpen when the menu closes/opens (e.g., via escape key) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { ContextMenu } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = o;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the dialog's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the dialog responds to open/close events.  To implement controlled state:  Set the controlledOpen prop to true on the ContextMenu.Root component. Provide an open prop to ContextMenu.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { ContextMenu } from \"bits-ui\";  let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Checkbox Items  You can use the ContextMenu.CheckboxItem component to create a menuitemcheckbox element to add checkbox functionality to menu items.    import { ContextMenu } from \"bits-ui\";   let notifications = $state(true);     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {/if}   Notifications  {/snippet}   See the $2 for more information.  Radio Groups  You can combine the ContextMenu.RadioGroup and ContextMenu.RadioItem components to create a radio group within a menu.    import { ContextMenu } from \"bits-ui\";   const values = [\"one\", \"two\", \"three\"];  let value = $state(\"one\");     {#each values as value}       {#snippet children({ checked })}     {#if checked}      ✅     {/if}     {value}    {/snippet}     {/each}   See the $2 and $2 APIs for more information.  Nested Menus  You can create nested menus using the ContextMenu.Sub component to create complex menu structures.    import { ContextMenu } from \"bits-ui\";     Item 1  Item 2     Open Sub Menu       Sub Item 1    Sub Item 2         -->  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the ContextMenu.Content component to use Svelte Transitions or another animation library that requires more control.    import { ContextMenu } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ props, open })}   {#if open}         Item 1     Item 2       {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Displays options or actions relevant to a specific context or selected item, triggered by a right-click.","href":"/docs/components/context-menu"},{"title":"Date Field","content":"  import { CalendarDateTime, CalendarDate, now, getLocalTimeZone, parseDate, today } from \"@internationalized/date\";  import { APISection, ComponentPreviewV2, DateFieldDemo, DateFieldDemoCustom, DemoContainer, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Overview  The DateField component is an alternative to the native `` element. It provides a more flexible and customizable way to select dates within a designated field.  Structure    import { DateField } from \"$lib\";     Check-in date     {#snippet children({ segments })}    {#each segments as { part, value }}           {value}         {/each}   {/snippet} Reusable Components  It's recommended to use the DateField primitives to build your own custom date field component that can be used throughout your application.  The following example shows how you might create a reusable MyDateField component that can be used throughout your application. For style inspiration, reference the featured demo at the top of this page.    import { DateField, type WithoutChildrenOrChild } from \"bits-ui\";   type Props = WithoutChildrenOrChild & {   labelText: string;  };   let { value, placeholder, name, ...restProps }: Props = $props();     {labelText}     {#snippet children({ segments })}    {#each segments as { part, value }}           {value}         {/each}   {/snippet}       {#snippet preview()}  {/snippet}    We'll be using this newly created MyDateField component in the following demos and examples to prevent repeating the same code, so be sure to reference it as you go through the documentation.  Segments  A segment of the DateField represents a not only a specific part of the date, such as the day, month, year, hour, but can also reference a \"literal\" which is typically a separator between the different parts of the date, and varies based on the locale.  Notice that in the MyDateField component we created, we're styling the DateField.Segment components differently based on whether they are a \"literal\" or not.  Placeholder  The placeholder prop for the DateField.Root component isn't what is displayed when the field is empty, but rather what date our field should start with when the user attempts to cycle through the segments. The placeholder can also be used to set a granularity for the date field, which will determine which type of DateValue object is used for the value.  By default, the placeholder will be set to the current date, and be of type CalendarDate. However, if we wanted this date field to also allow for selecting a time, we could set the placeholder to a CalendarDateTime object.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { CalendarDateTime } from \"@internationalized/date\";          If we're collecting a date from the user where we want the timezone as well, we can use a ZonedDateTime object instead.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { now, getLocalTimeZone } from \"@internationalized/date\";            If you're creating a date field for something like a birthday, ensure your placeholder is set in a leap year to ensure users born on a leap year will be able to select the correct date.  Managing Placeholder State  Bits UI offers several approaches to manage and synchronize the component's placeholder state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:placeholder directive. This method automatically keeps your local state in sync with the component's internal state.    import { DateField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myPlaceholder = new CalendarDate(2024, 8, 3))}>  Set placeholder to August 3rd, 2024  Key Benefits  Simplifies state management Automatically updates myPlaceholder when the internal state changes Allows external control (e.g., changing the placeholder via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onPlaceholderChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DateField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    {   placeholder = p;  }} Use Cases  Implementing custom behaviors on placeholder change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's placeholder state, use the controlledPlaceholder prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledPlaceholder prop to true on the DateField.Root component. Provide a placeholder prop to DateField.Root, which should be a variable holding the current state. Implement an onPlaceholderChange handler to update the state when the internal state changes.    import { DateField } from \"bits-ui\";  let myPlaceholder = $state();    (myPlaceholder = p)} When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Value State  Bits UI offers several approaches to manage and synchronize the component's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { DateField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myValue = myValue.add({ days: 1 }))}> Add 1 day   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes Allows external control (e.g., changing the value via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DateField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    {   value = v.set({ hour: v.hour + 1 });  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledValue prop to true on the DateField.Root component. Provide a value prop to DateField.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { DateField } from \"bits-ui\";  let myValue = $state();    (myValue = v)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Default Value  Often, you'll want to start the DateField.Root component with a default value. Likely this value will come from a database in the format of an ISO 8601 string. You can use the parseDate function from the @internationalized/date package to parse the string into a CalendarDate object.    import { DateField } from \"bits-ui\";  import { parseDate } from \"@internationalized/date\";   // this came from a database/API call  const date = \"2024-08-03\";   let value = $state(parseDate(date));             Now our input is populated with the default value. In addition to the parseDate function, you can also use parseDateTime or parseZonedDateTime to parse the string into a CalendarDateTime or ZonedDateTime object respectively.  Validation  Minimum Value  You can set a minimum value for the DateField.Root component by using the minValue prop. If a user selects a date that is less than the minimum value, the date field will be marked as invalid.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { today, getLocalTimeZone } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const yesterday = todayDate.subtract({ days: 1 });          In the example above, we're setting the minimum value to today, and the default value to yesterday. This causes the date field to be marked as invalid, and we can style it accordingly. If you adjust the date to be greater than the minimum value, the invalid state will be cleared.  Maximum Value  You can set a maximum value for the DateField.Root component by using the maxValue prop. If a user selects a date that is greater than the maximum value, the date field will be marked as invalid.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { today, getLocalTimeZone } from \"@internationalized/date\";   const todayDate = today(getLocalTimeZone());  const tomorrow = todayDate.add({ days: 1 });          In the example above, we're setting the maximum value to today, and the default value to tomorrow. This causes the date field to be marked as invalid, and we can style it accordingly. If you adjust the date to be less than the maximum value, the invalid state will be cleared.  Custom Validation  You can use the validate prop to provide a custom validation function for the date field. This function should return a string or array of strings as validation errors if the date is invalid, or undefined/nothing if the date is valid.  The strings are then passed to the onInvalid callback, which you can use to display an error message to the user.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { CalendarDate, type DateValue } from \"@internationalized/date\";   const value = new CalendarDate(2024, 8, 2);   function validate(date: DateValue) {   return date.day === 1 ? \"Date cannot be the first day of the month\" : undefined;  }   function onInvalid(reason: \"min\" | \"max\" | \"custom\", msg?: string | string[]) {   if (reason === \"custom\") {    if (typeof msg === \"string\") {     // do something with the error message     console.log(msg);     return;    } else if (Array.isArray(msg)) {     // do something with the error messages     console.log(msg);     return;    }    console.log(\"The date is invalid\");   } else if (reason === \"min\") {    // let the user know that the date is too early.    console.log(\"The date is too early.\");   } else if (reason === \"max\") {    // let the user know that the date is too late.    console.log(\"The date is too late.\");   }  }        date.day === 1 ? \"Date cannot be the first day of the month\" : undefined} value={new CalendarDate(2024, 8, 2)} onInvalid={(reason, msg) => {   if (reason === \"custom\") {    if (typeof msg === \"string\") {     // do something with the error message     console.log(msg);     return;    } else if (Array.isArray(msg)) {     // do something with the error messages     console.log(msg);     return;    }    console.log(\"The date is invalid\");   } else if (reason === \"min\") {    // let the user know that the date is too early.    console.log(\"The date is too early.\");   } else if (reason === \"max\") {    // let the user know that the date is too late.    console.log(\"The date is too late.\");   }  }} />   In the example above, we're setting the isDateUnavailable prop to a function that returns true for the first day of the month. Try selecting a date that is the first day of the month to see the date field marked as invalid.  Granularity  The granularity prop sets the granularity of the date field, which determines which segments are rendered in the date field. The granularity can be set to either 'day', 'hour', 'minute', or 'second'.    import MyDateField from \"$lib/components/MyDateField.svelte\";  import { CalendarDateTime } from \"@internationalized/date\";   const value = new CalendarDateTime(2024, 8, 2, 12, 30);          In the example above, we're setting the granularity to 'second', which means that the date field will include an additional segment for the seconds.  Localization  You can use the locale prop to set the locale of the date field. This will affect the formatting of the date field's segments and placeholders.    import MyDateField from \"$lib/components/MyDateField.svelte\";          ","description":"Enables users to input specific dates within a designated field.","href":"/docs/components/date-field"},{"title":"Date Picker","content":"  import { APISection, ComponentPreviewV2, DatePickerDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Structure    import { DatePicker } from \"bits-ui\";          {#snippet children({ segments })}    {#each segments as { part, value }}           {value}         {/each}   {/snippet}              {#snippet children({ months, weekdays })}                                 {#each months as month}                              {#each weekdays as day}                     {day}                   {/each}                              {#each month.weeks as weekDates}                   {#each weekDates as date}                                            {/each}                 {/each}                  {/each}    {/snippet} Managing Placeholder State  Bits UI offers several approaches to manage and synchronize the component's placeholder state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:placeholder directive. This method automatically keeps your local state in sync with the component's internal state.    import { DatePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myPlaceholder = new CalendarDate(2024, 8, 3))}>  Set placeholder to August 3rd, 2024  Key Benefits  Simplifies state management Automatically updates myPlaceholder when the internal state changes Allows external control (e.g., changing the placeholder via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onPlaceholderChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DatePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    {   placeholder = p;  }} Use Cases  Implementing custom behaviors on placeholder change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's placeholder state, use the controlledPlaceholder prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledPlaceholder prop to true on the DatePicker.Root component. Provide a placeholder prop to DatePicker.Root, which should be a variable holding the current state. Implement an onPlaceholderChange handler to update the state when the internal state changes.    import { DatePicker } from \"bits-ui\";  let myPlaceholder = $state();    (myPlaceholder = p)} When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Value State  Bits UI offers several approaches to manage and synchronize the component's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { DatePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    (myValue = myValue.add({ days: 1 }))}> Add 1 day   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes Allows external control (e.g., changing the value via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DatePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    {   value = v.set({ hour: v.hour + 1 });  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledValue prop to true on the DatePicker.Root component. Provide a value prop to DatePicker.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { DatePicker } from \"bits-ui\";  let myValue = $state();    (myValue = v)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Open State  Bits UI offers several approaches to manage and synchronize the component's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the component's internal state.    import { DatePicker } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open DatePicker  Key Benefits  Simplifies state management Automatically updates isOpen when the picker closes (e.g., via escape key) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DatePicker } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = open;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the dialog responds to open/close events.  To implement controlled state:  Set the controlledOpen prop to true on the DatePicker.Root component. Provide an open prop to DatePicker.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { DatePicker } from \"bits-ui\";   let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Customization  The DatePicker component is made up of three other Bits UI components: $2, $2, and $2.  You can check out the documentation for each of these components to learn more about their customization options, each of which can be used to customize the DatePicker component.  ","description":"Facilitates the selection of dates through an input and calendar-based interface.","href":"/docs/components/date-picker"},{"title":"Date Range Field","content":"  import { APISection, ComponentPreviewV2, DateRangeFieldDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Overview  The DateRangeField component combines two $2 components to create a date range field. Check out the $2 component documentation for information on how to customize this component.  Structure    import { DateRangeField } from \"$lib\";     Check-in date  {#each [\"start\", \"end\"] as const as type}       {#snippet children({ segments })}     {#each segments as { part, value }}             {value}           {/each}    {/snippet}     {/each}  Managing Placeholder State  Bits UI offers several approaches to manage and synchronize the component's placeholder state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:placeholder directive. This method automatically keeps your local state in sync with the component's internal state.    import { DateRangeField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));  Key Benefits  Simplifies state management Automatically updates myPlaceholder when the internal state changes Allows external control (e.g., changing the placeholder via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onPlaceholderChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DateRangeField } from \"bits-ui\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    {   myPlaceholder = p.set({ year: 2025 });  }} Use Cases  Implementing custom behaviors on placeholder change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's placeholder state, use the controlledPlaceholder prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledPlaceholder prop to true on the DateRangeField.Root component. Provide a placeholder prop to DateRangeField.Root, which should be a variable holding the current state. Implement an onPlaceholderChange handler to update the state when the internal state changes.    import { DateRangeField } from \"bits-ui\";  let myPlaceholder = $state();    (myPlaceholder = p)} When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Value State  Bits UI offers several approaches to manage and synchronize the component's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { DateRangeField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state({   start: new CalendarDateTime(2024, 8, 3, 12, 30),   end: new CalendarDateTime(2024, 8, 4, 12, 30),  });    {   value = {    start: value.start.add({ days: 1 }),    end: value.end.add({ days: 1 }),   };  }}  Add 1 day  Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes Allows external control (e.g., changing the value via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DateRangeField } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state({   start: new CalendarDateTime(2024, 8, 3, 12, 30),   end: new CalendarDateTime(2024, 8, 4, 12, 30),  });    {   value = {    start: v.start?.set({ hour: v.start.hour + 1 }),    end: v.end?.set({ hour: v.end.hour + 1 }),   };  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledValue prop to true on the DateRangeField.Root component. Provide a value prop to DateRangeField.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { DateRangeField } from \"bits-ui\";  let myValue = $state();    (myValue = v)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.    ","description":"Allows users to input a range of dates within a designated field.","href":"/docs/components/date-range-field"},{"title":"Date Range Picker","content":"  import { APISection, ComponentPreviewV2, DateRangePickerDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Structure    import { DateRangePicker } from \"bits-ui\";       {#each [\"start\", \"end\"] as const as type}       {#snippet children({ segments })}     {#each segments as { part, value }}             {value}           {/each}    {/snippet}     {/each}           {#snippet children({ months, weekdays })}                                 {#each months as month}                              {#each weekdays as day}                     {day}                   {/each}                              {#each month.weeks as weekDates}                   {#each weekDates as date}                                    {date.day}                                 {/each}                 {/each}                  {/each}    {/snippet} Managing Placeholder State  Bits UI offers several approaches to manage and synchronize the component's placeholder state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:placeholder directive. This method automatically keeps your local state in sync with the component's internal state.    import { DateRangePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));  Key Benefits  Simplifies state management Automatically updates myPlaceholder when the internal state changes Allows external control (e.g., changing the placeholder via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onPlaceholderChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DateRangePicker } from \"bits-ui\";  let myPlaceholder = $state(new CalendarDateTime(2024, 8, 3, 12, 30));    {   myPlaceholder = p.set({ year: 2025 });  }} Use Cases  Implementing custom behaviors on placeholder change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's placeholder state, use the controlledPlaceholder prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledPlaceholder prop to true on the DateRangePicker.Root component. Provide a placeholder prop to DateRangePicker.Root, which should be a variable holding the current state. Implement an onPlaceholderChange handler to update the state when the internal state changes.   import { DateRangePicker } from \"bits-ui\";  let myPlaceholder = $state();    (myPlaceholder = p)} When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Value State  Bits UI offers several approaches to manage and synchronize the component's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { DateRangePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state({   start: new CalendarDateTime(2024, 8, 3, 12, 30),   end: new CalendarDateTime(2024, 8, 4, 12, 30),  });    {   value = {    start: value.start.add({ days: 1 }),    end: value.end.add({ days: 1 }),   };  }}  Add 1 day  Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes Allows external control (e.g., changing the value via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DateRangePicker } from \"bits-ui\";  import { CalendarDateTime } from \"@internationalized/date\";  let myValue = $state({   start: new CalendarDateTime(2024, 8, 3, 12, 30),   end: new CalendarDateTime(2024, 8, 4, 12, 30),  });    {   value = {    start: v.start?.set({ hour: v.start.hour + 1 }),    end: v.end?.set({ hour: v.end.hour + 1 }),   };  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledValue prop to true on the DateRangePicker.Root component. Provide a value prop to DateRangePicker.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { DateRangePicker } from \"bits-ui\";  let myValue = $state();    (myValue = v)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Open State  Bits UI offers several approaches to manage and synchronize the component's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the component's internal state.    import { DateRangePicker } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open DateRangePicker  Key Benefits  Simplifies state management Automatically updates isOpen when the picker closes (e.g., via escape key) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DateRangePicker } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = open;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the dialog responds to open/close events.  To implement controlled state:  Set the controlledOpen prop to true on the DateRangePicker.Root component. Provide an open prop to DateRangePicker.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { DateRangePicker } from \"bits-ui\";   let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Customization  The DateRangePicker component is made up of three other Bits UI components: $2, $2, and $2.  You can check out the documentation for each of these components to learn more about their customization options, each of which can be used to customize the DateRangePicker component.  ","description":"Facilitates the selection of date ranges through an input and calendar-based interface.","href":"/docs/components/date-range-picker"},{"title":"Dialog","content":"  import { APISection, ComponentPreviewV2, DialogDemo, DialogDemoCustom, DialogDemoNested, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  The Dialog component in Bits UI provides a flexible and accessible way to create modal dialogs in your Svelte applications. It follows a compound component pattern, allowing for fine-grained control over the dialog's structure and behavior while maintaining accessibility and ease of use.  Key Features  Compound Component Structure**: Offers a set of sub-components that work together to create a fully-featured dialog. Accessibility**: Built with WAI-ARIA guidelines in mind, ensuring keyboard navigation and screen reader support. Customizable**: Each sub-component can be styled and configured independently. Portal Support**: Content can be rendered in a portal, ensuring proper stacking context. Managed Focus**: Automatically manages focus, with the option to take control if needed. Flexible State Management**: Supports both controlled and uncontrolled state, allowing for full control over the dialog's open state.  Architecture  The Dialog component is composed of several sub-components, each with a specific role:  Root**: The main container component that manages the state of the dialog. Provides context for all child components. Trigger**: A button that toggles the dialog's open state. Portal**: Renders its children in a portal, outside the normal DOM hierarchy. Overlay**: A backdrop that sits behind the dialog content. Content**: The main container for the dialog's content. Title**: Renders the dialog's title. Description**: Renders a description or additional context for the dialog. Close**: A button that closes the dialog.  Structure  Here's an overview of how the Dialog component is structured in code:    import { Dialog } from \"bits-ui\";  Reusable Components  Bits UI provides a comprehensive set of Dialog components that serve as building blocks for creating customized, reusable Dialog implementations. This approach offers flexibility in design while maintaining consistency and accessibility across your application.  Building a Reusable Dialog  The following example demonstrates how to create a versatile, reusable Dialog component using Bits UI building blocks. This implementation showcases the flexibility of the component API by combining props and snippets.    import type { Snippet } from \"svelte\";  import { Dialog, type WithoutChild } from \"bits-ui\";   type Props = Dialog.RootProps & {   buttonText: string;   title: Snippet;   description: Snippet;   contentProps?: WithoutChild;   // ...other component props if you wish to pass them  };   let {   open = $bindable(false),   children,   buttonText,   contentProps,   title,   description,   ...restProps  }: Props = $props();        {buttonText}                   {@render title()}             {@render description()}        {@render children?.()}    Close Dialog Usage with Inline Snippets    import MyDialog from \"$lib/components/MyDialog.svelte\";     {#snippet title()}   Account settings  {/snippet}   {#snippet description()}   Manage your account settings and preferences.  {/snippet}  Usage with Separate Snippets    import MyDialog from \"$lib/components/MyDialog.svelte\";   {#snippet title()}  Account settings {/snippet}  {#snippet description()}  Manage your account settings and preferences. {/snippet}  Best Practices  Prop Flexibility**: Design your component to accept props for any nested components for maximum flexibility Styling Options**: Use tools like clsx to merge class overrides Binding Props**: Use bind: and expose $bindable props to provide consumers with full control Type Safety**: Use the exported types from Bits UI to type your component props  Managing Open State  Bits UI offers several approaches to manage and synchronize the Alert Dialog's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the dialog's internal state.    import { Dialog } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Dialog  Key Benefits  Simplifies state management Automatically updates isOpen when the dialog closes (e.g., via escape key) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Dialog } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = open;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the dialog's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the dialog responds to open/close events.  To implement controlled state:  Set the controlledOpen prop to true on the Dialog.Root component. Provide an open prop to Dialog.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { Dialog } from \"bits-ui\";   let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Focus Management  Proper focus management is crucial for accessibility and user experience in modal dialogs. Bits UI's Dialog component provides several features to help you manage focus effectively.  Focus Trap  By default, the Dialog implements a focus trap, adhering to the WAI-ARIA design pattern for modal dialogs. This ensures that keyboard focus remains within the Dialog while it's open, preventing users from interacting with the rest of the page.  Disabling the Focus Trap  While not recommended, you can disable the focus trap if absolutely necessary:         Disabling the focus trap may compromise accessibility. Only do this if you have a specific reason and implement an alternative focus management strategy.  Open Focus  When a Dialog opens, focus is automatically set to the first focusable element within Dialog.Content. This ensures keyboard users can immediately interact with the Dialog contents.  Customizing Initial Focus  To specify which element receives focus when the Dialog opens, use the onOpenAutoFocus prop on Dialog.Content:    import { Dialog } from \"bits-ui\";  let nameInput = $state();     Open Dialog   {    e.preventDefault();    nameInput?.focus();   }}          Always ensure that something within the Dialog receives focus when it opens. This is crucial for maintaining keyboard navigation context and makes your users happy.  Close Focus  When a Dialog closes, focus returns to the element that triggered its opening (typically the Dialog.Trigger).  Customizing Close Focus  To change which element receives focus when the Dialog closes, use the onCloseAutoFocus prop on Dialog.Content:    import { Dialog } from \"bits-ui\";  let nameInput = $state();      Open Dialog   {    e.preventDefault();    nameInput?.focus();   }} Best Practices  Always maintain a clear focus management strategy for your Dialogs. Ensure that focus is predictable and logical for keyboard users. Test your focus management with keyboard navigation to verify its effectiveness.  Advanced Behaviors  Bits UI's Dialog component offers several advanced features to customize its behavior and enhance user experience. This section covers scroll locking, escape key handling, and interaction outside the dialog.  Scroll Lock  By default, when a Dialog opens, scrolling the body is disabled. This provides a more native-like experience, focusing user attention on the dialog content.  Customizing Scroll Behavior  To allow body scrolling while the dialog is open, use the preventScroll prop on Dialog.Content:         Enabling body scroll may affect user focus and accessibility. Use this option judiciously.  Escape Key Handling  By default, pressing the Escape key closes an open Dialog. Bits UI provides two methods to customize this behavior.  Method 1: escapeKeydownBehavior  The escapeKeydownBehavior prop allows you to customize the behavior taken by the component when the Escape key is pressed. It accepts one of the following values:  'close' (default): Closes the Dialog immediately. 'ignore': Prevents the Dialog from closing. 'defer-otherwise-close': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Dialog will close immediately. 'defer-otherwise-ignore': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Dialog will ignore the key press and not close.  To always prevent the Dialog from closing on Escape key press, set the escapeKeydownBehavior prop to 'ignore' on Dialog.Content:  Method 2: onEscapeKeydown  For more granular control, override the default behavior using the onEscapeKeydown prop:   {   e.preventDefault();   // do something else instead  }}     This method allows you to implement custom logic when the Escape key is pressed.  Interaction Outside  By default, interacting outside the Dialog content area closes the Dialog. Bits UI offers two ways to modify this behavior.  Method 1: interactOutsideBehavior  The interactOutsideBehavior prop allows you to customize the behavior taken by the component when an interaction (touch, mouse, or pointer event) occurs outside the content. It accepts one of the following values:  'close' (default): Closes the Dialog immediately. 'ignore': Prevents the Dialog from closing. 'defer-otherwise-close': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Dialog will close immediately. 'defer-otherwise-ignore': If an ancestor Bits UI component also implements this prop, it will defer the closing decision to that component. Otherwise, the Dialog will ignore the event and not close.  To always prevent the Dialog from closing on Escape key press, set the escapeKeydownBehavior prop to 'ignore' on Dialog.Content:  Method 2: onInteractOutside  For custom handling of outside interactions, you can override the default behavior using the onInteractOutside prop:   {   e.preventDefault();   // do something else instead  }}     This approach allows you to implement specific behaviors when users interact outside the Dialog content.  Best Practices  Scroll Lock**: Consider your use case carefully before disabling scroll lock. It may be necessary for dialogs with scrollable content or for specific UX requirements. Escape Keydown**: Overriding the default escape key behavior should be done thoughtfully. Users often expect the escape key to close modals. Outside Interactions**: Ignoring outside interactions can be useful for important dialogs or multi-step processes, but be cautious not to trap users unintentionally. Accessibility**: Always ensure that any customizations maintain or enhance the dialog's accessibility. User Expectations**: Try to balance custom behaviors with common UX patterns to avoid confusing users.  By leveraging these advanced features, you can create highly customized dialog experiences while maintaining usability and accessibility standards.  Nested Dialogs  Dialogs can be nested within each other to create more complex user interfaces:    import MyDialog from \"$lib/components/MyDialog.svelte\";     {#snippet title()}   First Dialog  {/snippet}  {#snippet description()}   This is the first dialog.  {/snippet}     {#snippet title()}    Second Dialog   {/snippet}   {#snippet description()}    This is the second dialog.   {/snippet} Svelte Transitions  The Dialog component can be enhanced with Svelte's built-in transition effects or other animation libraries.  Using forceMount and child Snippets  To apply Svelte transitions to Dialog components, use the forceMount prop in combination with the child snippet. This approach gives you full control over the mounting behavior and animation of Dialog.Content and Dialog.Overlay.    import { Dialog } from \"bits-ui\";  import { fly, fade } from \"svelte/transition\";          {#snippet child({ props, open })}    {#if open}                    {/if}   {/snippet}       {#snippet child({ props, open })}    {#if open}                    {/if}   {/snippet}     In this example:  The forceMount prop ensures the components are always in the DOM. The child snippet provides access to the open state and component props. Svelte's #if block controls when the content is visible. Transition directives (transition:fade and transition:fly) apply the animations.  Best Practices  For cleaner code and better maintainability, consider creating custom reusable components that encapsulate this transition logic.    import { Dialog, type WithoutChildrenOrChild } from \"bits-ui\";  import { fade } from \"svelte/transition\";  import type { Snippet } from \"svelte\";   let {   ref = $bindable(null),   duration = 200,   children,   ...restProps  }: WithoutChildrenOrChild & {   duration?: number;   children?: Snippet;  } = $props();     {#snippet child({ props, open })}   {#if open}         {@render children?.()}       {/if}  {/snippet}   You can then use the MyDialogOverlay component alongside the other Dialog primitives throughout your application:    import { Dialog } from \"bits-ui\";  import { MyDialogOverlay } from \"$lib/components\";     Open Working with Forms  Form Submission  When using the Dialog component, often you'll want to submit a form or perform an asynchronous action and then close the dialog.  This can be done by waiting for the asynchronous action to complete, then programmatically closing the dialog.    import { Dialog } from \"bits-ui\";   function wait(ms: number) {   return new Promise((resolve) => setTimeout(resolve, ms));  }   let open = $state(false);               Confirm your action    Are you sure you want to do this?     {      wait(1000).then(() => (open = false));     }}     Submit form Inside a Form  If you're using a Dialog within a form, you'll need to ensure that the Portal is disabled or not included in the Dialog structure. This is because the Portal will render the dialog content outside of the form, which will prevent the form from being submitted correctly.  ","description":"A modal window presenting content or seeking user input without navigating away from the current context.","href":"/docs/components/dialog"},{"title":"Dropdown Menu","content":"  import { APISection, ComponentPreviewV2, DropdownMenuDemo, DropdownMenuDemoTransition, Callout } from '$lib/components'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { DropdownMenu } from \"bits-ui\";  Reusable Components  If you're planning to use Dropdown Menu in multiple places, you can create a reusable component that wraps the Dropdown Menu component.  This example shows you how to create a Dropdown Menu component that accepts a few custom props that make it more capable.    import type { Snippet } from \"svelte\";  import { DropdownMenu, type WithoutChild } from \"bits-ui\";   type Props = DropdownMenu.Props & {   buttonText: string;   items: string[];   contentProps?: WithoutChild;   // other component props if needed  };   let {   open = $bindable(false),   children,   buttonText,   items,   contentProps,   ...restProps  }: Props = $props();        {buttonText}                {#each items as item}             {item}           {/each}            You can then use the MyDropdownMenu component like this:    import MyDropdownMenu from \"./MyDropdownMenu.svelte\";  Managing Open State  Bits UI offers several approaches to manage and synchronize the Dropdown Menu's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the component's internal state.    import { DropdownMenu } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Context Menu  Key Benefits  Simplifies state management Automatically updates isOpen when the menu closes/opens (e.g., via escape key) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { DropdownMenu } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = o;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the dialog's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the dialog responds to open/close events.  To implement controlled state:  Set the controlledOpen prop to true on the DropdownMenu.Root component. Provide an open prop to DropdownMenu.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { DropdownMenu } from \"bits-ui\";  let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Groups  To group related menu items, you can use the DropdownMenu.Group component along with either a DropdownMenu.GroupHeading or an aria-label attribute on the DropdownMenu.Group component.    File  New  Open  Save  Save As     New  Open  Save  Save As  Group Heading  The DropdownMenu.GroupHeading component must be a child of either a DropdownMenu.Group or DropdownMenu.RadioGroup component. If used on its own, an error will be thrown during development.    File         Favorite color Checkbox Items  You can use the DropdownMenu.CheckboxItem component to create a menuitemcheckbox element to add checkbox functionality to menu items.    import { DropdownMenu } from \"bits-ui\";   let notifications = $state(true);     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {/if}   Notifications  {/snippet}   The checked state does not persist between menu open/close cycles. To persist the state, you must store it in a $state variable and pass it to the checked prop.  Radio Groups  You can combine the DropdownMenu.RadioGroup and DropdownMenu.RadioItem components to create a radio group within a menu.    import { DropdownMenu } from \"bits-ui\";   const values = [\"one\", \"two\", \"three\"];  let value = $state(\"one\");     Favorite number  {#each values as value}       {#snippet children({ checked })}     {#if checked}      ✅     {/if}     {value}    {/snippet}     {/each}   The value state does not persist between menu open/close cycles. To persist the state, you must store it in a $state variable and pass it to the value prop.  Nested Menus  You can create nested menus using the DropdownMenu.Sub component to create complex menu structures.    import { DropdownMenu } from \"bits-ui\";     Item 1  Item 2     Open Sub Menu       Sub Item 1    Sub Item 2         -->  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the DropdownMenu.Content component to use Svelte Transitions or another animation library that requires more control.    import { DropdownMenu } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ props, open })}   {#if open}         Item 1     Item 2       {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}  Custom Anchor  By default, the DropdownMenu.Content is anchored to the DropdownMenu.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the DropdownMenu.Content component.    import { DropdownMenu } from \"bits-ui\";  let customAnchor = $state(null!);                 ","description":"Displays a menu of items that users can select from when triggered.","href":"/docs/components/dropdown-menu"},{"title":"Label","content":"  import { APISection, ComponentPreviewV2, LabelDemo } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Label } from \"bits-ui\";     ","description":"Identifies or describes associated UI elements.","href":"/docs/components/label"},{"title":"Link Preview","content":"  import { APISection, ComponentPreviewV2, LinkPreviewDemo, LinkPreviewDemoTransition, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  A component that lets users preview a link before they decide to follow it. This is useful for providing non-essential context or additional information about a link without having to navigate away from the current page.    This component is only intended to be used with a mouse or other pointing device. It doesn't respond to touch events, and the preview content cannot be accessed via the keyboard. On touch devices, the link will be followed immediately. As it is not accessible to all users, the preview should not contain vital information.  Structure    import { LinkPreview } from \"bits-ui\";  Managing Open State  Bits UI offers several approaches to manage and synchronize the Link Preview's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the component's internal state.    import { LinkPreview } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Link Preview  Key Benefits  Simplifies state management Automatically updates isOpen when the preview closes/opens (e.g., via escape key) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { LinkPreview } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = o;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the dialog's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the dialog responds to open/close events.  To implement controlled state:  Set the controlledOpen prop to true on the LinkPreview.Root component. Provide an open prop to LinkPreview.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { LinkPreview } from \"bits-ui\";  let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Opt-out of Floating UI  When you use the LinkPreview.Content component, Bits UI uses $2 to position the content relative to the trigger, similar to other popover-like components.  You can opt-out of this behavior by instead using the LinkPreview.ContentStatic component. This component does not use Floating UI and leaves positioning the content entirely up to you.                The LinkPreview.Arrow component is designed to be used with Floating UI and LinkPreview.Content, so you may experience unexpected behavior if you attempt to use it with LinkPreview.ContentStatic.  Custom Anchor  By default, the LinkPreview.Content is anchored to the LinkPreview.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the LinkPreview.Content component.    import { LinkPreview } from \"bits-ui\";  let customAnchor = $state(null!);  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the LinkPreview.Content component to use Svelte Transitions or another animation library that requires more control.    import { LinkPreview } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ props, open })}   {#if open}                {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Displays a summarized preview of a linked content's details or information.","href":"/docs/components/link-preview"},{"title":"Menubar","content":"  import { APISection, ComponentPreviewV2, MenubarDemo } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Menubar } from \"bits-ui\";                                                       {#snippet children({ checked })}       {checked ? \"✅\" : \"\"}      {/snippet}                              {#snippet children({ checked })}        {checked ? \"✅\" : \"\"}       {/snippet} Reusable Components  If you're planning to use Menubar in multiple places, you can create reusable components that wrap the different parts of the Menubar.  In the following example, we're creating a reusable MyMenubarMenu component that contains the trigger, content, and items of a menu.    import { Menubar, type WithoutChildrenOrChild } from \"bits-ui\";   type Props = WithoutChildrenOrChild & {   triggerText: string;   items: { label: string; value: string; onSelect?: () => void }[];   contentProps?: WithoutChildrenOrChild;   // other component props if needed  };   let { triggerText, items, contentProps, ...restProps }: Props = $props();        {triggerText}           {#each items as item}           {item.label}         {/each}        Now, we can use the MyMenubarMenu component within a Menubar.Root component to render out the various menus.    import { Menubar } from \"bits-ui\";  import MyMenubarMenu from \"./MyMenubarMenu.svelte\";   const sales = [   { label: \"Michael Scott\", value: \"michael\" },   { label: \"Dwight Schrute\", value: \"dwight\" },   { label: \"Jim Halpert\", value: \"jim\" },   { label: \"Stanley Hudson\", value: \"stanley\" },   { label: \"Phyllis Vance\", value: \"phyllis\" },   { label: \"Pam Beesly\", value: \"pam\" },   { label: \"Andy Bernard\", value: \"andy\" },  ];   const hr = [   { label: \"Toby Flenderson\", value: \"toby\" },   { label: \"Holly Flax\", value: \"holly\" },   { label: \"Jan Levinson\", value: \"jan\" },  ];   const accounting = [   { label: \"Angela Martin\", value: \"angela\" },   { label: \"Kevin Malone\", value: \"kevin\" },   { label: \"Oscar Martinez\", value: \"oscar\" },  ];   const menubarMenus = [   { title: \"Sales\", items: sales },   { title: \"HR\", items: hr },   { title: \"Accounting\", items: accounting },  ];     {#each menubarMenus as { title, items }}     {/each}  Value State  Bits UI provides flexible options for controlling and synchronizing the menubar's active value state. The value represents the currently opened menu within the menubar.  Two-Way Binding  Use the bind:value directive for effortless two-way synchronization between your local state and the menubar's internal state.    import { Menubar } from \"bits-ui\";  let activeValue = $state(\"\");    (activeValue = \"menu-1\")}>Open Menubar Menu  Change Handler  You can also use the onValueCHange prop to update local state when the menubar's active menu changes. This is useful when you don't want two-way binding for one reason or another, or you want to perform additional logic when the menus open or close.    import { Menubar } from \"bits-ui\";  let activeValue = $state(\"\");    {   activeValue = value;   // additional logic here.  }} Checkbox Items  You can use the Menubar.CheckboxItem component to create a menuitemcheckbox element to add checkbox functionality to menu items.    import { Menubar } from \"bits-ui\";   let notifications = $state(true);     {#snippet children({ checked, indeterminate })}   {#if indeterminate}    {:else if checked}    ✅   {/if}   Notifications  {/snippet}  Radio Groups  You can combine the Menubar.RadioGroup and Menubar.RadioItem components to create a radio group within a menu.    import { Menubar } from \"bits-ui\";   const values = [\"one\", \"two\", \"three\"];  let value = $state(\"one\");     {#each values as value}       {#snippet children({ checked })}     {#if checked}      ✅     {/if}     {value}    {/snippet}     {/each}  Nested Menus  You can create nested menus using the Menubar.Sub component to create complex menu structures.    import { Menubar } from \"bits-ui\";     Item 1  Item 2     Open Sub Menu       Sub Item 1    Sub Item 2         -->  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Menubar.Content component to use Svelte Transitions or another animation library that requires more control.    import { Menubar } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ props, open })}   {#if open}         Item 1     Item 2       {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.  ","description":"Organizes and presents a collection of menu options or actions within a horizontal bar.","href":"/docs/components/menubar"},{"title":"Navigation Menu","content":"  import { APISection, ComponentPreviewV2, NavigationMenuDemo } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { NavigationMenu } from \"bits-ui\";                                                              ","description":"A list of links that allow users to navigate between pages of a website.","href":"/docs/components/navigation-menu"},{"title":"Pagination","content":"  import { APISection, ComponentPreviewV2, PaginationDemo, Callout } from '$lib/components/index.js'  export let schemas     {#snippet preview()}  {/snippet}  Structure    import { Pagination } from \"bits-ui\";       {#each pages as page (page.key)}     {/each} Managing Page State  Bits UI offers several approaches to manage and synchronize the Pagination's page state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:page directive. This method automatically keeps your local state in sync with the component's internal state.    import { Pagination } from \"bits-ui\";  let myPage = $state(1);    (myPage = 2)}> Go to page 2   Key Benefits  Simplifies state management Automatically updates myPage when the internal state changes (e.g., via clicking on a page button) Allows external control (e.g., changing the page via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onPageChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Pagination } from \"bits-ui\";  let myPage = $state(1);    {   myPage = p;   // additional logic here.  }} Use Cases  Implementing custom behaviors on page change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's pressed state, use the controlledPage prop. This approach requires you to manually manage the state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledPage prop to true on the Pagination.Root component. Provide a page prop to Pagination.Root, which should be a variable holding the current state. Implement an onPageChange handler to update the state when the internal state changes.    import { Pagination } from \"bits-ui\";  let myPage = $state(1);    (myPage = p)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Ellipsis  The pages snippet prop consists of two types of items: 'page' and 'ellipsis'. The 'page' type represents an actual page number, while the 'ellipsis' type represents a placeholder for rendering an ellipsis between pages.  ","description":"Facilitates navigation between pages.","href":"/docs/components/pagination"},{"title":"PIN Input","content":"  import { APISection, ComponentPreviewV2, PinInputDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  The PIN Input component provides a customizable solution for One-Time Password (OTP), Two-Factor Authentication (2FA), or Multi-Factor Authentication (MFA) input fields. Due to the lack of a native HTML element for these purposes, developers often resort to either basic input fields or custom implementations. This component offers a robust, accessible, and flexible alternative.    This component is derived from and would not have been possible without the work done by $2 with $2.  Key Features  Invisible Input Technique**: Utilizes an invisible input element for seamless integration with form submissions and browser autofill functionality. Customizable Appearance**: Allows for custom designs while maintaining core functionality. Accessibility**: Ensures keyboard navigation and screen reader compatibility. Flexible Configuration**: Supports various PIN lengths and input types (numeric, alphanumeric).  Architecture  Root Container: A relatively positioned root element that encapsulates the entire component. Invisible Input: A hidden input field that manages the actual value and interacts with the browser's built-in features. Visual Cells: Customizable elements representing each character of the PIN, rendered as siblings to the invisible input.  This structure allows for a seamless user experience while providing developers with full control over the visual representation.  Structure    import { PinInput } from \"bits-ui\";     {#snippet children({ cells })}   {#each cells as cell}       {/each}  {/snippet}  Managing Value State  Bits UI offers several approaches to manage and synchronize the component's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { PinInput } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"123456\")}> Set value to 123456   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., user typing in the input) Allows external control (e.g., switching tabs via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { PinInput } from \"bits-ui\";  let myValue = $state(\"\");    {   myValue = v;   // additional logic here.  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the PinInput.Root component. Provide a value prop to PinInput.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { PinInput } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = v)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Paste Handling  The onPaste prop allows you to sanitize pasted text. This can be useful for cleaning up pasted text, like removing hyphens or other characters that should not make it into the input. This function should return the sanitized text.    import { PinInput } from \"bits-ui\";    text.replace(/-/g, \"\")}> HTML Forms  The PinInput.Root component is designed to work seamlessly with HTML forms. Simply pass the name prop to the PinInput.Root component and the input will be submitted with the form.  Submit On Complete  To submit the form when the input is complete, you can use the onComplete prop.    import { PinInput } from \"bits-ui\";  let form = $state(null!);      form.submit()}> Patterns  You can use the pattern prop to restrict the characters that can be entered or pasted into the input.   Client-side validation cannot replace server-side validation. Use this in addition to server-side validation for an improved user experience.   Bits UI exports a few common patterns that you can import and use in your application.  REGEXP_ONLY_DIGITS - Only allow digits to be entered. REGEXP_ONLY_CHARS - Only allow characters to be entered. REGEXP_ONLY_DIGITS_AND_CHARS - Only allow digits and characters to be entered.    import { PinInput, REGEXP_ONLY_DIGITS } from \"bits-ui\";        ","description":"Allows users to input a sequence of one-character alphanumeric inputs.","href":"/docs/components/pin-input"},{"title":"Popover","content":"  import { APISection, ComponentPreviewV2, PopoverDemo, PopoverDemoTransition, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Popover } from \"bits-ui\";  Managing Open State  Bits UI offers several approaches to manage and synchronize the Popover's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the dialog's internal state.    import { Popover } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Popover  Key Benefits  Simplifies state management Automatically updates isOpen when the popover closes/opens (e.g., via escape key) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Popover } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = o;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the dialog's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the dialog responds to open/close events.  To implement controlled state:  Set the controlledOpen prop to true on the Popover.Root component. Provide an open prop to Popover.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the local state when the internal state changes.    import { Popover } from \"bits-ui\";   let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Focus  Focus Trap  By default, when a Popover is opened, focus will be trapped within that Popover. You can disable this behavior by setting the trapFocus prop to false on the Popover.Content component.  Open Focus  By default, when a Popover is opened, focus will be set to the first focusable element with the Popover.Content. This ensures that users navigating my keyboard end up somewhere within the Popover that they can interact with.  You can override this behavior using the onOpenAutoFocus prop on the Popover.Content component. It's highly recommended that you use this prop to focus something within the Popover's content.  You'll first need to cancel the default behavior of focusing the first focusable element by cancelling the event passed to the onOpenAutoFocus callback. You can then focus whatever you wish.    import { Popover } from \"bits-ui\";  let nameInput = $state();     Open Popover   {    e.preventDefault();    nameInput?.focus();   }} Close Focus  By default, when a Popover is closed, focus will be set to the trigger element of the Popover. You can override this behavior using the onCloseAutoFocus prop on the Popover.Content component.  You'll need to cancel the default behavior of focusing the trigger element by cancelling the event passed to the onCloseAutoFocus callback, and then focus whatever you wish.    import { Popover } from \"bits-ui\";  let nameInput = $state();      Open Popover   {    e.preventDefault();    nameInput?.focus();   }} Scroll Lock  By default, when a Popover is opened, users can still scroll the body and interact with content outside of the Popover. If you wish to lock the body scroll and prevent users from interacting with content outside of the Popover, you can set the preventScroll prop to true on the Popover.Content component.  Escape Keydown  By default, when a Popover is open, pressing the Escape key will close the dialog. Bits UI provides a couple ways to override this behavior.  escapeKeydownBehavior  You can set the escapeKeydownBehavior prop to 'ignore' on the Popover.Content component to prevent the dialog from closing when the Escape key is pressed.  onEscapeKeydown  You can also override the default behavior by cancelling the event passed to the onEscapeKeydown callback on the Popover.Content component.   e.preventDefault()}> Interact Outside  By default, when a Popover is open, pointer down events outside the content will close the popover. Bits UI provides a couple ways to override this behavior.  interactOutsideBehavior  You can set the interactOutsideBehavior prop to 'ignore' on the Popover.Content component to prevent the dialog from closing when the user interacts outside the content.  onInteractOutside  You can also override the default behavior by cancelling the event passed to the onInteractOutside callback on the Popover.Content component.   e.preventDefault()}> Custom Anchor  By default, the Popover.Content is anchored to the Popover.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the Popover.Content component.    import { Popover } from \"bits-ui\";  let customAnchor = $state(null!);  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Popover.Content component to use Svelte Transitions or another animation library that requires more control.    import { Popover } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ props, open })}   {#if open}                {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Display supplementary content or information when users interact with specific elements.","href":"/docs/components/popover"},{"title":"Progress","content":"  import { APISection, ComponentPreviewV2, ProgressDemo } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Progress } from \"bits-ui\";     ","description":"Visualizes the progress or completion status of a task or process.","href":"/docs/components/progress"},{"title":"Radio Group","content":"  import { APISection, ComponentPreviewV2, RadioGroupDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { RadioGroup } from \"bits-ui\";        {#snippet children({ checked })}    {#if checked}     ✅    {/if}   {/snippet} Reusable Components  It's recommended to use the RadioGroup primitives to create your own custom components that can be used throughout your application.  In the example below, we're creating a custom MyRadioGroup component that takes in an array of items and renders a radio group with those items along with a $2 component for each item.    import { RadioGroup, Label, type WithoutChildrenOrChild, useId } from \"bits-ui\";   type Item = {   value: string;   label: string;   disabled?: boolean;  };   type Props = WithoutChildrenOrChild & {   items: Item[];  };   let { value = $bindable(\"\"), ref = $bindable(null), items, ...restProps }: Props = $props();     {#each items as item}   {@const id = useId()}            {#snippet children({ checked })}      {#if checked}       ✅      {/if}     {/snippet}        {item.label}     {/each}   You can then use the MyRadioGroup component in your application like so:    import MyRadioGroup from \"$lib/components/MyRadioGroup.svelte\";   const myItems = [   { value: \"apple\", label: \"Apple\" },   { value: \"banana\", label: \"Banana\" },   { value: \"coconut\", label: \"Coconut\", disabled: true },  ];  Managing Value State  Bits UI offers several approaches to manage and synchronize the Radio Group's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { RadioGroup } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"A\")}> Select A   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., via clicking on an item) Allows external control (e.g., selecting an item via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { RadioGroup } from \"bits-ui\";  let myValue = $state(\"\");    {   myValue = v;   // additional logic here.  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the RadioGroup.Root component. Provide a value prop to RadioGroup.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { RadioGroup } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = v)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  HTML Forms  If you set the name prop on the RadioGroup.Root component, a hidden input element will be rendered to submit the value of the radio group to a form.  Required  To make the hidden input element required you can set the required prop on the RadioGroup.Root component.  Disabling Items  You can disable a radio group item by setting the disabled prop to true.  Apple  Orientation  The orientation prop is used to determine the orientation of the radio group, which influences how keyboard navigation will work.  When the orientation is set to 'vertical', the radio group will navigate through the items using the ArrowUp and ArrowDown keys. When the orientation is set to 'horizontal', the radio group will navigate through the items using the ArrowLeft and ArrowRight keys.            ","description":"Allows users to select a single option from a list of mutually exclusive choices.","href":"/docs/components/radio-group"},{"title":"Range Calendar","content":"  import { APISection, ComponentPreviewV2, RangeCalendarDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}      Before diving into this component, it's important to understand how dates/times work in Bits UI. Please read the $2 documentation to learn more!  Structure    import { RangeCalendar } from \"bits-ui\";     {#snippet children({ months, weekdays })}                     {#each months as month}                      {#each weekdays as day}                 {day}               {/each}                      {#each month.weeks as weekDates}               {#each weekDates as date}                                    {/each}             {/each}            {/each}  {/snippet}   ","description":"Presents a calendar view tailored for selecting date ranges.","href":"/docs/components/range-calendar"},{"title":"Scroll Area","content":"  import { APISection, ComponentPreviewV2, ScrollAreaDemo, ScrollAreaDemoCustom } from '$lib/components'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { ScrollArea } from \"bits-ui\";  Reusable Components  If you're planning to use the Scroll Area throughout your application, it's recommended to create a reusable component to reduce the amount of code you need to write each time.  This example shows you how to create a Scroll Area component that accepts a few custom props that make it more capable.    import { ScrollArea, type WithoutChild } from \"bits-ui\";   type Props = WithoutChild & {   orientation: \"vertical\" | \"horizontal\" | \"both\";   viewportClasses?: string;  };   let {   ref = $bindable(null),   orientation = \"vertical\",   viewportClasses,   children,   ...restProps  }: Props = $props();   {#snippet Scrollbar({ orientation }: { orientation: \"vertical\" | \"horizontal\" })}        {/snippet}       {@render children?.()}    {#if orientation === \"vertical\" || orientation === \"both\"}   {@render Scrollbar({ orientation: \"vertical\" })}  {/if}  {#if orientation === \"horizontal\" || orientation === \"both\"}   {@render Scrollbar({ orientation: \"horizontal\" })}  {/if}     We'll use this custom component in the following examples to demonstrate how to customize the behavior of the Scroll Area.  Scroll Area Types  Hover  The hover type is the default type of the scroll area, demonstrated in the featured example above. It only shows scrollbars when the user hovers over the scroll area and the content is larger than the viewport.  Scroll  The scroll type displays the scrollbars when the user scrolls the content. This is similar to the behavior of MacOS.  Auto  The auto type behaves similarly to your typical browser scrollbars. When the content is larger than the viewport, the scrollbars will appear and remain visible at all times.  Always  The always type behaves as if you set overflow: scroll on the scroll area. Scrollbars will always be visible, even when the content is smaller than the viewport. We've also set the orientation prop on the MyScrollArea to 'both' to ensure both scrollbars are rendered.  Customizing the Hide Delay  You can customize the hide delay of the scrollbars using the scrollHideDelay prop.         ","description":"Provides a consistent scroll area across platforms.","href":"/docs/components/scroll-area"},{"title":"Select","content":"  import { APISection, ComponentPreviewV2, SelectDemo, SelectDemoCustomAnchor, SelectDemoMultiple, SelectDemoTransition, Callout } from '$lib/components'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  The Select component provides users with a selectable list of options. It's designed to offer an enhanced selection experience with features like typeahead search, keyboard navigation, and customizable grouping. This component is particularly useful for scenarios where users need to choose from a predefined set of options, offering more functionality than a standard select element.  Key Features  Typeahead Search**: Users can quickly find options by typing Keyboard Navigation**: Full support for keyboard interactions, allowing users to navigate through options using arrow keys, enter to select, and more. Grouped Options**: Ability to organize options into logical groups, enhancing readability and organization of large option sets. Scroll Management**: Includes scroll up/down buttons for easy navigation in long lists. Accessibility**: Built-in ARIA attributes and keyboard support ensure compatibility with screen readers and adherence to accessibility standards. Portal Support**: Option to render the select content in a portal, preventing layout issues in complex UI structures.  Architecture  The Select component is composed of several sub-components, each with a specific role:  Root**: The main container component that manages the state and context for the combobox. Trigger**: The button or element that opens the dropdown list. Portal**: Responsible for portalling the dropdown content to the body or a custom target. Group**: A container for grouped items, used to group related items. GroupHeading**: A heading for a group of items, providing a descriptive label for the group. Item**: An individual item within the list. Separator**: A visual separator between items. Content**: The dropdown container that displays the items. It uses $2 to position the content relative to the trigger. ContentStatic** (Optional): An alternative to the Content component, that enables you to opt-out of Floating UI and position the content yourself. Arrow**: An arrow element that points to the trigger when using the Combobox.Content component.  Structure  Here's an overview of how the Select component is structured in code:    import { Select } from \"bits-ui\";  Reusable Components  As you can see from the structure above, there are a number of pieces that make up the Select component. These pieces are provided to give you maximum flexibility and customization options, but can be a burden to write out everywhere you need to use a select in your application.  To ease this burden, it's recommended to create your own reusable select component that wraps the primitives and provides a more convenient API for your use cases.  Here's an example of how you might create a reusable MySelect component that receives a list of options and renders each of them as an item.    import { Select, type WithoutChildren } from \"bits-ui\";   type Props = WithoutChildren & {   placeholder?: string;   items: { value: string; label: string; disabled?: boolean }[];   contentProps?: WithoutChildren;   // any other specific component props if needed  };   let { value = $bindable(\"\"), items, contentProps, placeholder, ...restProps }: Props = $props();   const selectedLabel = $derived(items.find((item) => item.value === value)?.label);        {#if selectedLabel}         {selectedLabel}       {:else}       {/if}           up         {#each items as { value, label, disabled } (value)}             {#snippet children({ selected })}        {selected ? \"✅\" : \"\"}                 {item.label}               {/snippet}           {/each}        down        You can then use the MySelect component throughout your application like so:    import MySelect from \"$lib/components/MySelect.svelte\";   const items = [   { value: \"apple\", label: \"Apple\" },   { value: \"banana\", label: \"Banana\" },   { value: \"cherry\", label: \"Cherry\" },  ];   let fruit = $state(\"apple\");  Managing Value State  Bits UI offers several approaches to manage and synchronize the Select's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { Select } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"A\")}> Select A   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., via clicking on an item) Allows external control (e.g., selecting an item via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Select } from \"bits-ui\";  let myValue = $state(\"\");    {   myValue = value;   // additional logic here.  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the Select.Root component. Provide a value prop to Select.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { Select } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = v)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Managing Open State  Bits UI offers several approaches to manage and synchronize the Select's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the component's internal state.    import { Select } from \"bits-ui\";  let myOpen = $state(false);    (myOpen = true)}> Open   Key Benefits  Simplifies state management Automatically updates myOpen when the internal state changes (e.g., via clicking on the trigger/input) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Select } from \"bits-ui\";  let myOpen = $state(false);    {   myOpen = o;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledOpen prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledOpen prop to true on the Select.Root component. Provide an open prop to Select.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { Select } from \"bits-ui\";  let myOpen = $state(false);    (myOpen = v)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Multiple Selection  The type prop can be set to 'multiple' to allow multiple items to be selected at a time.    import { Select } from \"bits-ui\";   let value = $state([]);          {#snippet preview()}  {/snippet}  Opt-out of Floating UI  When you use the Select.Content component, Bits UI uses $2 to position the content relative to the trigger, similar to other popover-like components.  You can opt-out of this behavior by instead using the Select.ContentStatic component.                                                             When using this component, you'll need to handle the positioning of the content yourself. Keep in mind that using Select.Portal alongside Select.ContentStatic may result in some unexpected positioning behavior, feel free to not use the portal or work around it.  Custom Anchor  By default, the Select.Content is anchored to the Select.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the Select.Content component.    import { Select } from \"bits-ui\";   let customAnchor = $state(null!);  What is the Viewport?  The Select.Viewport component is used to determine the size of the content in order to determine whether or not the scroll up and down buttons should be rendered.  If you wish to set a minimum/maximum height for the select content, you should apply it to the Select.Viewport component.  Scroll Up/Down Buttons  The Select.ScrollUpButton and Select.ScrollDownButton components are used to render the scroll up and down buttons when the select content is larger than the viewport.  You must use the Select.Viewport component when using the scroll buttons.  Native Scrolling/Overflow  If you don't want to use the scroll buttons and prefer to use the standard scrollbar/overflow behavior, you can omit the Select.Scroll[Up|Down]Button components and the Select.Viewport component.  You'll need to set a height on the Select.Content component and appropriate overflow styles to enable scrolling.  Scroll Lock  By default, when a user opens the select, scrolling outside the content will not be disabled. You can override this behavior by setting the preventScroll prop to true.  Highlighted Items  The Select component follows the $2 for highlighting items. This means that the Select.Trigger retains focus the entire time, even when navigating with the keyboard, and items are highlighted as the user navigates them.  Styling Highlighted Items  You can use the data-highlighted attribute on the Select.Item component to style the item differently when it is highlighted.  onHighlight / onUnhighlight  To trigger side effects when an item is highlighted or unhighlighted, you can use the onHighlight and onUnhighlight props.   console.log('I am highlighted!')} onUnhighlight={() => console.log('I am unhighlighted!')} />  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Select.Content component to use Svelte Transitions or another animation library that requires more control.    import { Select } from \"bits-ui\";  import { fly } from \"svelte/transition\";     {#snippet child({ props, open })}   {#if open}                {/if}  {/snippet}   Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content component that handles this logic if you intend to use this approach. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}    ","description":"Enables users to choose from a list of options presented in a dropdown.","href":"/docs/components/select"},{"title":"Separator","content":"  import { APISection, ComponentPreviewV2, SeparatorDemo } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Separator } from \"bits-ui\";     ","description":"Visually separates content or UI elements for clarity and organization.","href":"/docs/components/separator"},{"title":"Slider","content":"  import { APISection, ComponentPreviewV2, SliderDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Slider } from \"bits-ui\";  Reusable Components  Bits UI provides primitives that enable you to build your own custom slider component that can be reused throughout your application.  Here's an example of how you might create a reusable MySlider component.    import { Slider } from \"bits-ui\";   type Props = WithoutChildren;   let { value = $bindable(), ref = $bindable(null), ...restProps }: Props = $props();     {#snippet children({ thumbs, ticks })}      {#each thumbs as index}       {/each}    {#each ticks as index}       {/each}  {/snippet}   You can then use the MySlider component in your application like so:    import MySlider from \"$lib/components/MySlider.svelte\";   let someValue = $state([5, 10]);  Managing Value State  Bits UI offers several approaches to manage and synchronize the Slider's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { Slider } from \"bits-ui\";  let myValue = $state([0]);    (myValue = [20])}> Set value to 20   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., via dragging the thumb(s)) Allows external control (e.g., updating the value via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Slider } from \"bits-ui\";  let myValue = $state([0]);    {   myValue = v;   // additional logic here.  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the Slider.Root component. Provide a value prop to Slider.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { Slider } from \"bits-ui\";  let myValue = $state([0]);    (myValue = v)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Value Commit  You can use the onValueCommit prop to be notified when the user finishes dragging the thumb and the value changes. This is different than the onValueChange callback because it waits until the user stops dragging before calling the callback, where the onValueChange callback is called as the user dragging.   {   console.log(\"user is done sliding!\", v);  }} />  Multiple Thumbs and Ticks  If the value prop has more than one value, the slider will render multiple thumbs. You can also use the ticks snippet prop to render ticks at specific intervals    import { Slider } from \"bits-ui\";   let value = $state([5, 7]);     {#snippet children({ ticks, thumbs })}       {#each thumbs as index}       {/each}    {#each ticks as index}       {/each}  {/snippet}   To determine the number of ticks that will be rendered, you can simply divide the max value by the step value.  Vertical Orientation  You can use the orientation prop to change the orientation of the slider, which defaults to \"horizontal\".  RTL Support  You can use the dir prop to change the reading direction of the slider, which defaults to \"ltr\".  Auto Sort  By default, the slider will sort the values from smallest to largest, so if you drag a smaller thumb to a larger value, the value of that thumb will be updated to the larger value.  You can disable this behavior by setting the autoSort prop to false.  HTML Forms  Since there is a near endless number of possible values that a user can select, the slider does not render a hidden input element by default.  You'll need to determine how you want to submit the value(s) of the slider with a form.  Here's an example of how you might do that:    import MySlider from \"$lib/components/MySlider.svelte\";   let expectedIncome = $state([50, 100]);           Submit   ","description":"Allows users to select a value from a continuous range by sliding a handle.","href":"/docs/components/slider"},{"title":"Switch","content":"  import { APISection, ComponentPreviewV2, SwitchDemo, SwitchDemoCustom, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Overview  The Switch component provides an intuitive and accessible toggle control, allowing users to switch between two states, typically \"on\" and \"off\". This component is commonly used for enabling or disabling features, toggling settings, or representing boolean values in forms. The Switch offers a more visual and interactive alternative to traditional checkboxes for binary choices.  Key Features  Accessibility**: Built with WAI-ARIA guidelines in mind, ensuring keyboard navigation and screen reader support. State Management**: Internally manages the on/off state, with options for controlled and uncontrolled usage. Style-able**: Data attributes allow for smooth transitions between states and custom styles. HTML Forms**: Can render a hidden input element for form submissions.  Architecture  The Switch component is composed of two main parts:  Root**: The main container component that manages the state and behavior of the switch. Thumb**: The \"movable\" part of the switch that indicates the current state.  Structure  Here's an overview of how the Switch component is structured in code:    import { Switch } from \"bits-ui\";  Reusable Components  It's recommended to use the Switch primitives to create your own custom switch component that can be used throughout your application.  In the example below, we're using the Checkbox and $2 components to create a custom switch component.    import { Switch, Label, useId, type WithoutChildrenOrChild } from \"bits-ui\";   let {   id = useId(),   checked = $bindable(false),   ref = $bindable(null),   ...restProps  }: WithoutChildrenOrChild & {   labelText: string;  } = $props();       {labelText}  You can then use the MySwitch component in your application like so:    import MySwitch from \"$lib/components/MySwitch.svelte\";   let notifications = $state(true);  Managing Checked State  Bits UI offers several approaches to manage and synchronize the Switch's checked state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:checked directive. This method automatically keeps your local state in sync with the switch's internal state.    import { Switch } from \"bits-ui\";  let myChecked = $state(true);    (myChecked = false)}> uncheck   Key Benefits  Simplifies state management Automatically updates myChecked when the switch changes (e.g., via clicking on the switch) Allows external control (e.g., checking via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onCheckedChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Switch } from \"bits-ui\";  let myChecked = $state(false);    {   myChecked = checked;   // additional logic here.  }} />  Use Cases  Implementing custom behaviors on checked/unchecked Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the switch's checked state, use the controlledChecked prop. This approach requires you to manually manage the checked state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledChecked prop to true on the Switch.Root component. Provide a checked prop to Switch.Root, which should be a variable holding the current state. Implement an onCheckedChange handler to update the state when the internal state changes.    import { Switch } from \"bits-ui\";  let myChecked = $state(false);    (myChecked = c)}> When to Use  Implementing complex checked/unchecked logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Disabled State  You can disable the switch by setting the disabled prop to true.  HTML Forms  If you pass the name prop to Switch.Root, a hidden input element will be rendered to submit the value of the switch to a form.  By default, the input will be submitted with the default checkbox value of 'on' if the switch is checked.  Custom Input Value  If you'd prefer to submit a different value, you can use the value prop to set the value of the hidden input.  For example, if you wanted to submit a string value, you could do the following:  Required  If you want to make the switch required, you can use the required prop.       This will apply the required attribute to the hidden input element, ensuring that proper form submission is enforced.  ","description":"A toggle control enabling users to switch between \"on\" and \"off\" states.","href":"/docs/components/switch"},{"title":"Tabs","content":"  import { APISection, ComponentPreviewV2, TabsDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Tabs } from \"bits-ui\";  Managing Value State  Bits UI offers several approaches to manage and synchronize the component's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { Tabs } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"tab-1\")}> Activate tab 1   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., via clicking on an tab's trigger) Allows external control (e.g., switching tabs via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Tabs } from \"bits-ui\";  let myValue = $state(\"\");    {   myValue = v;   // additional logic here.  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the Tabs.Root component. Provide a value prop to Tabs.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { Tabs } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = v)}> When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Orientation  The orientation prop is used to determine the orientation of the Tabs component, which influences how keyboard navigation will work.  When the orientation is set to 'horizontal', the ArrowLeft and ArrowRight keys will move the focus to the previous and next tab, respectively. When the orientation is set to 'vertical', the ArrowUp and ArrowDown keys will move the focus to the previous and next tab, respectively.  Activation Mode  By default, the Tabs component will automatically activate the tab associated with a trigger when that trigger is focused. This behavior can be disabled by setting the activationMode prop to 'manual'.  When set to 'manual', the user will need to activate the tab by pressing the trigger.       ","description":"Organizes content into distinct sections, allowing users to switch between them.","href":"/docs/components/tabs"},{"title":"Toggle Group","content":"  import { APISection, ComponentPreviewV2, ToggleGroupDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { ToggleGroup } from \"bits-ui\";     bold  italic  Single & Multiple  The ToggleGroup component supports two type props, 'single' and 'multiple'. When the type is set to 'single', the ToggleGroup will only allow a single item to be selected at a time, and the type of the value prop will be a string.  When the type is set to 'multiple', the ToggleGroup will allow multiple items to be selected at a time, and the type of the value prop will be an array of strings.  Managing Value State  Bits UI offers several approaches to manage and synchronize the component's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { ToggleGroup } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"item-1\")}> Press item 1   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., via clicking on an item) Allows external control (e.g., toggling an item via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { ToggleGroup } from \"bits-ui\";  let myValue = $state(\"\");    {   myValue = v;   // additional logic here.  }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the ToggleGroup.Root component. Provide a value prop to ToggleGroup.Root, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { ToggleGroup } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = v)} When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.    ","description":"Groups multiple toggle controls, allowing users to enable one or multiple options.","href":"/docs/components/toggle-group"},{"title":"Toggle","content":"  import { APISection, ComponentPreviewV2, ToggleDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Toggle } from \"bits-ui\";  Managing Pressed State  Bits UI offers several approaches to manage and synchronize the Toggle's pressed state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:pressed directive. This method automatically keeps your local state in sync with the component's internal state.    import { Toggle } from \"bits-ui\";  let myPressed = $state(true);    (myPressed = false)}> un-press   Key Benefits  Simplifies state management Automatically updates myPressed when the switch changes (e.g., via clicking on the toggle) Allows external control (e.g., pressing/toggling via a separate button/programmatically)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onPressedChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Toggle } from \"bits-ui\";  let myPressed = $state(false);    {   myPressed = p;   // additional logic here.  }} />  Use Cases  Implementing custom behaviors on pressed/unpressed Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's pressed state, use the controlledPressed prop. This approach requires you to manually manage the checked state, giving you full control over when and how the component responds to change events.  To implement controlled state:  Set the controlledPressed prop to true on the Toggle.Root component. Provide a pressed prop to Toggle.Root, which should be a variable holding the current state. Implement an onPressedChange handler to update the state when the internal state changes.    import { Toggle } from \"bits-ui\";  let myPressed = $state(false);    (myPressed = p)}> When to Use  Implementing complex checked/unchecked logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.    ","description":"A control element that switches between two states, providing a binary choice.","href":"/docs/components/toggle"},{"title":"Toolbar","content":"  import { APISection, ComponentPreviewV2, ToolbarDemo, Callout } from '$lib/components/index.js'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Toolbar } from \"bits-ui\";  Managing Value State  Bits UI offers several approaches to manage and synchronize the component's value state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:value directive. This method automatically keeps your local state in sync with the component's internal state.    import { Toolbar } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = \"item-1\")}> Press item 1   Key Benefits  Simplifies state management Automatically updates myValue when the internal state changes (e.g., via clicking on an item) Allows external control (e.g., toggling an item via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onValueChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Toolbar } from \"bits-ui\";  let myValue = $state(\"\");      {    myValue = v;    // additional logic here.   }} Use Cases  Implementing custom behaviors on value change Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the component's value state, use the controlledValue prop. This approach requires you to manually manage the value state, giving you full control over when and how the component responds to value change events.  To implement controlled state:  Set the controlledValue prop to true on the Toolbar.Group component. Provide a value prop to Toolbar.Group, which should be a variable holding the current state. Implement an onValueChange handler to update the state when the internal state changes.    import { Toolbar } from \"bits-ui\";  let myValue = $state(\"\");      {    myValue = v;    // additional logic here.   }} When to Use  Implementing complex logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.    ","description":"Displays frequently used actions or tools in a compact, easily accessible bar.","href":"/docs/components/toolbar"},{"title":"Tooltip","content":"  import { ComponentPreviewV2, TooltipDemo, TooltipDemoCustom, TooltipDemoDelayDuration, TooltipDemoTransition, APISection, Callout } from '$lib/components'  export let schemas;     {#snippet preview()}  {/snippet}  Structure    import { Tooltip } from \"bits-ui\";  Provider Component  The Tooltip.Provider component is required to be an ancestor of the Tooltip.Root component. It provides shared state for the tooltip components used within it. You can set a single delayDuration or disableHoverableContent prop on the provider component to apply to all the tooltip components within it.    import { Tooltip } from \"bits-ui\";                                                              It also ensures that only a single tooltip within the same provider can be open at a time. It's recommended to wrap your root layout content with the provider component, setting your sensible default props there.    import { Tooltip } from \"bits-ui\";  let { children } = $props();     {@render children()}  Managing Open State  Bits UI offers several approaches to manage and synchronize the Tooltip's open state, catering to different levels of control and integration needs.  1. Two-Way Binding  For seamless state synchronization, use Svelte's bind:open directive. This method automatically keeps your local state in sync with the component's internal state.    import { Tooltip } from \"bits-ui\";  let isOpen = $state(false);    (isOpen = true)}>Open Tooltip  Key Benefits  Simplifies state management Automatically updates isOpen when the tooltip closes (e.g., via escape key) Allows external control (e.g., opening via a separate button)  2. Change Handler  For more granular control or to perform additional logic on state changes, use the onOpenChange prop. This approach is useful when you need to execute custom logic alongside state updates.    import { Tooltip } from \"bits-ui\";  let isOpen = $state(false);    {   isOpen = o;   // additional logic here.  }} Use Cases  Implementing custom behaviors on open/close Integrating with external state management solutions Triggering side effects (e.g., logging, data fetching)  3. Fully Controlled  For complete control over the dialog's open state, use the controlledOpen prop. This approach requires you to manually manage the open state, giving you full control over when and how the tooltip responds to open/close events.  To implement controlled state:  Set the controlledOpen prop to true on the Tooltip.Root component. Provide an open prop to Tooltip.Root, which should be a variable holding the current state. Implement an onOpenChange handler to update the state when the internal state changes.    import { Tooltip } from \"bits-ui\";   let myOpen = $state(false);    (myOpen = o)}> When to Use  Implementing complex open/close logic Coordinating multiple UI elements Debugging state-related issues    While powerful, fully controlled state should be used judiciously as it increases complexity and can cause unexpected behaviors if not handled carefully.  For more in-depth information on controlled components and advanced state management techniques, refer to our $2 documentation.  Mobile Tooltips  Tooltips are not supported on mobile devices. The intent of a tooltip is to provide a \"tip\" about a \"tool\" before the user interacts with that tool (in most cases, a button).  This is not possible on mobile devices, because there is no sense of hover on mobile. If a user were to press/touch a button with a tooltip, the action that button triggers would be taken before they were even able to see the tooltip, which renders it useless.  If you are using a tooltip on a button without an action, you should consider using a $2 instead.  If you'd like to learn more about how we came to this decision, here are some useful resources:  The tooltip is not the appropriate role for the more information \"i\" icon, ⓘ. A tooltip is directly associated with the owning element. The ⓘ isn't 'described by' detailed information; the tool or control is. $2  Tooltips should only ever contain non-essential content. The best approach to writing tooltip content is to always assume it may never be read. $2  Reusable Components  It's recommended to use the Tooltip primitives to build your own custom tooltip component that can be used throughout your application.  Below is an example of how you might create a reusable tooltip component that can be used throughout your application. Of course, this isn't the only way to do it, but it should give you a good idea of how to compose the primitives.    import { Tooltip } from \"bits-ui\";  import { type Snippet } from \"svelte\";   type Props = Tooltip.RootProps & {   trigger: Snippet;   triggerProps?: Tooltip.TriggerProps;  };   let {   open = $bindable(false),   children,   buttonText,   triggerProps = {},   ...restProps  }: Tooltip.RootProps = $props();         {@render trigger()}               {@render children?.()}        You could then use the MyTooltip component in your application like so:    import MyTooltip from \"$lib/components/MyTooltip.svelte\";  import BoldIcon from \"..some-icon-library\"; // not real    alert(\"changed to bold!\") }}>  {#snippet trigger()}     {/snippet}  Change font to bold  Delay Duration  You can change how long a user needs to hover over a trigger before the tooltip appears by setting the delayDuration prop on the Tooltip.Root or Tooltip.Provider component.  Close on Trigger Click  By default, the tooltip will close when the user clicks the trigger. If you want to disable this behavior, you can set the disableCloseOnTriggerClick prop to true.  Hoverable Content  By default, the tooltip will remain open when the user hovers over the content. If you instead want the tooltip to close as the user moves their mouse towards the content, you can set the disableHoverableContent prop to true.  Non-Keyboard Focus  If you want to prevent opening the tooltip when the user focuses the trigger without using the keyboard, you can set the ignoreNonKeyboardFocus prop to true.  Svelte Transitions  You can use the forceMount prop along with the child snippet to forcefully mount the Tooltip.Content component to use Svelte Transitions or another animation library that requires more control.    import { Tooltip } from \"bits-ui\";  import { fly, fade } from \"svelte/transition\";          {#snippet child({ props, open })}    {#if open}                    {/if}   {/snippet}     Of course, this isn't the prettiest syntax, so it's recommended to create your own reusable content components that handles this logic if you intend to use this approach throughout your app. For more information on using transitions with Bits UI components, see the $2 documentation.    {#snippet preview()}  {/snippet}  Opt-out of Floating UI  When you use the Tooltip.Content component, Bits UI uses $2 to position the content relative to the trigger, similar to other popover-like components.  You can opt-out of this behavior by instead using the Tooltip.ContentStatic component. This component does not use Floating UI and leaves positioning the content entirely up to you.    Hello            When using the Tooltip.ContentStatic component, the Tooltip.Arrow component will not be rendered relative to it as it is designed to be used with Tooltip.Content.  Custom Anchor  By default, the Tooltip.Content is anchored to the Tooltip.Trigger component, which determines where the content is positioned.  If you wish to instead anchor the content to a different element, you can pass either a selector string or an HTMLElement to the customAnchor prop of the Tooltip.Content component.    import { Tooltip } from \"bits-ui\";  let customAnchor = $state(null!);                 ","description":"Provides additional information or context when users hover over or interact with an element.","href":"/docs/components/tooltip"},{"title":"mergeProps","content":"Overview  mergeProps is a utility function designed to merge multiple props objects. It's particularly useful for composing components with different prop sets or extending the functionality of existing components.  It is used internally by Bits UI components to merge the custom restProps you pass to a component with the props that Bits UI provides to the component.  Key Features  Merges multiple props objects Chains event handlers with cancellation support Combines class names Merges style objects and strings Chains non-event handler functions  Detailed Behavior  Event Handlers  Event handlers are chained in the order they're passed. If a handler calls event.preventDefault(), subsequent handlers in the chain are not executed.  const props1 = { onclick: (e: MouseEvent) => console.log(\"First click\") }; const props2 = { onclick: (e: MouseEvent) => console.log(\"Second click\") };  const mergedProps = mergeProps(props1, props2); mergedProps.onclick(new MouseEvent(\"click\")); // Logs: \"First click\" then \"Second click\"  If preventDefault() is called:  const props1 = { onclick: (e: MouseEvent) => console.log(\"First click\") }; const props2 = {  onclick: (e: MouseEvent) => {   console.log(\"Second click\");   e.preventDefault();  }, }; const props3 = { onclick: (e: MouseEvent) => console.log(\"Third click\") };  const mergedProps = mergeProps(props1, props2, props3); mergedProps.onclick(new MouseEvent(\"click\")); // Logs: \"First click\" then \"Second click\" only  Since props2 called event.preventDefault(), props3's onclick handler will not be called.  Non-Event Handler Functions  Non-event handler functions are also chained, but without the ability to prevent subsequent functions from executing:  const props1 = { doSomething: () => console.log(\"Action 1\") }; const props2 = { doSomething: () => console.log(\"Action 2\") };  const mergedProps = mergeProps(props1, props2); mergedProps.doSomething(); // Logs: \"Action 1\" then \"Action 2\"  Classes  Class names are merged using $2:  const props1 = { class: \"text-lg font-bold\" }; const props2 = { class: [\"bg-blue-500\", \"hover:bg-blue-600\"] };  const mergedProps = mergeProps(props1, props2); console.log(mergedProps.class); // \"text-lg font-bold bg-blue-500 hover:bg-blue-600\"  Styles  Style objects and strings are merged, with later properties overriding earlier ones:  const props1 = { style: { color: \"red\", fontSize: \"16px\" } }; const props2 = { style: \"background-color: blue; font-weight: bold;\" };  const mergedProps = mergeProps(props1, props2); console.log(mergedProps.style); // \"color: red; font-size: 16px; background-color: blue; font-weight: bold;\"  import { mergeProps } from \"bits-ui\";  const props1 = { style: \"--foo: red\" }; const props2 = { style: { \"--foo\": \"green\", color: \"blue\" } };  const mergedProps = mergeProps(props1, props2);  console.log(mergedProps.style); // \"--foo: green; color: blue;\" `","description":"A utility function to merge props objects.","href":"/docs/utilities/merge-props"},{"title":"Portal","content":"Overview  The Portal component is a utility component that renders its children in a portal, preventing layout issues in complex UI structures. This component is used for the various Bits UI component that have a Portal sub-component.  Usage  Default behavior  By default, the Portal component will render its children in the body element.    import { Portal } from \"bits-ui\";     This content will be portalled to the body  Custom target  You can use the to prop to specify a custom target element or selector to render the content to.    import { Portal } from \"bits-ui\";          This content will be portalled to the #custom-target element Disable  You can use the disabled prop to disable the portal behavior.    import { Portal } from \"bits-ui\";     This content will not be portalled  `","description":"A component that renders its children in a portal, preventing layout issues in complex UI structures.","href":"/docs/utilities/portal"},{"title":"useId","content":"The useId function is a utility function that can be used to generate unique IDs. This function is used internally by all Bits UI components and is exposed for your convenience.  Usage    import { useId } from \"bits-ui\";   const id = useId();   Label here  `","description":"A utility function to generate unique IDs.","href":"/docs/utilities/use-id"},{"title":"WithElementRef","content":"The WithElementRef type helper is a convenience type that enables you to follow the same $2 prop pattern as used by Bits UI components when crafting your own.  type WithElementRef = T & { ref?: U | null };  This type helper is used internally by Bits UI components to enable the ref prop on a component.  Usage Example    import type { WithElementRef } from \"bits-ui\";   type Props = WithElementRef;   let { yourPropA, yourPropB, ref = $bindable(null) }: Props = $props();       `","description":"A type helper to enable the `ref` prop on a component.","href":"/docs/type-helpers/with-element-ref"},{"title":"WithoutChild","content":"The WithoutChild type helper is used to exclude the child snippet prop from a component. This is useful when you're building custom component wrappers that populate the children prop of a component and don't provide a way to pass a custom child snippet.  To learn more about the child snippet prop, check out the $2 documentation.    import { Accordion, type WithoutChild } from \"bits-ui\";   let { children, ...restProps }: WithoutChild = $props();        {@render children?.()}    `","description":"A type helper to exclude the child snippet prop from a component.","href":"/docs/type-helpers/without-child"},{"title":"WithoutChildrenOrChild","content":"The WithoutChildrenOrChild type helper is used to exclude the child and children props from a component. This is useful when you're building custom component wrappers that populate the children prop of a component and don't provide a way to pass a custom children or child snippet.  To learn more about the child snippet prop, check out the $2 documentation.    import { Accordion, type WithoutChildrenOrChild } from \"bits-ui\";   let {   title,   ...restProps  }: WithoutChildrenOrChild = $props();     {title}   Now, the CustomAccordionTrigger component won't expose children or child props to the user, but will expose the other root component props.","description":"A type helper to exclude the child ad children snippet props from a component.","href":"/docs/type-helpers/without-children-or-child"},{"title":"WithoutChildren","content":"The WithoutChildren type helper is used to exclude the children snippet prop from a component. This is useful when you're building custom component wrappers that populate the children prop of a component.    import { Accordion, type WithoutChildren } from \"bits-ui\";   let { value, onValueChange, ...restProps }: WithoutChildren = $props();                   In the example above, we're using the WithoutChildren type helper to exclude the children snippet prop from the Accordion.Root component. This ensures our exposed props are consistent with what is being used internally.","description":"A type helper to exclude the children snippet prop from a component.","href":"/docs/type-helpers/without-children"},{"title":"Child Snippet","content":"Usage  Many Bits UI components have a default HTML element that wraps their children. For example, Accordion.Trigger typically renders as:    {@render children()}   While you can set standard button attributes, you might need more control for:  Applying Svelte transitions or actions Using custom components Scoped CSS  This is where the child snippet comes in.  Components supporting render delegation accept an optional child prop, which is a Svelte snippet. When used, the component passes its attributes to this snippet, allowing you to apply them to any element.  Let's take a look at an example using the Accordion.Trigger component:    {#snippet child({ props })}   Open accordion item  {/snippet}   The props object includes event handlers, ARIA attributes, and any other attributes passed to Accordion.Trigger. Note that when using child, other children outside this snippet are ignored.  Custom IDs & Attributes  To use custom IDs, event handlers, or other attributes with a custom element, you must pass them to the component first. This is crucial because:  Many Bits UI internals rely on specific IDs Props are merged using a $2 function to handle cancelling internal handlers, etc.  Correct usage:   console.log(\"clicked\")}>    {#snippet child({ props })}   Open accordion item  {/snippet}   In this example, my-custom-id, the click event handler, and my-custom-class are properly merged into the props object, ensuring they work alongside Bits UI's internal logic.  Behind the scenes, components using the child prop typically implement logic similar to this:    // other imports/props/logic omitted for brevity  let { child, children, ...restProps } = $props();  const trigger = makeTrigger();   const mergedProps = $derived(mergeProps(restProps, trigger.props));   {#if child}  {@render child({ props: mergedProps })} {:else}     {@render children?.()}   {/if} `","description":"Learn how to use the `child` snippet to render your own elements.","href":"/docs/child-snippet"},{"title":"Controlled State","content":"  import { Callout } from '$lib/components'   Bits UI components offer flexibility in state management, allowing you to choose between uncontrolled and controlled states. This guide will help you understand when and how to use controlled state effectively.  Understanding State Management  Uncontrolled State (Default)  By default, Bits UI components operate in an uncontrolled state. In this mode:  The component internally manages its own state. You can bind: to the state for reference. The component decides when and how to update its state. You can update the state of the component yourself from the outside, but you can't prevent the component from updating it.  Here's an example of an uncontrolled Accordion:    import { Accordion } from \"bits-ui\";  let myValue = $state(\"\");        In this example, the Accordion.Root component manages its value state internally. When a user interacts with the accordion, the component updates the value automatically. The local myValue is synced with the component's internal value state in both directions.    When state is uncontrolled, the onValueChange prop is called after the state changes, so you can use it to perform additional logic/side effects after the state updates.  Controlled State  Controlled state puts you in charge of the component's state management. Use this approach when:  You need to meet specific conditions before state updates. You want to synchronize the component's state with other parts of your application. You require custom logic for state updates.  To implement controlled state:  Set the controlled prop to true (e.g., controlledValue). Pass a local state variable to the component. Use the onChange callback to update the local state (e.g., onValueChange).  Here's an example of how you might use controlled state with the Accordion component:    import { Accordion } from \"bits-ui\";  let myValue = $state(\"\");    (myValue = v)}>     In this controlled state example:  We set controlledValue to true. We pass our local myValue state to the value prop. We use onValueChange to handle state updates    Unlike uncontrolled state, controlled state does not update the state before calling the onValueChange function.  Best Practices  Choose wisely**: Use controlled state only when necessary. Uncontrolled state is simpler and sufficient for most use cases. Consistent control**: If you opt for controlled state, ensure you handle all related state updates to maintain consistency. Performance consideration**: Be mindful of potential performance impacts when using controlled state, especially with frequently updating components.  Common Controlled State Scenarios  Form validation before state updates Syncing component state with external data sources Implementing undo/redo functionality Creating interdependent component behaviors","description":"Learn how to use controlled state in Bits UI components.","href":"/docs/controlled-state"},{"title":"Dates and Times","content":"The date and time components in Bits UI are built on top of the $2 package, which provides a unified API for working with dates and times in different locales and time zones. It's heavily inspired by the $2 proposal, and intends to back the objects in this package with the Temporal API once it's available.  You can install the package using your favorite package manager:  npm install @internationalized/date  It's highly recommended to familiarize yourself with the package's documentation before diving into the components. We'll cover the basics of how we use the package in Bits UI in the sections below, but their documentation provides much more detail on the various formats and how to work with them.  DateValue  We use the DateValue objects provided by @internationalized/date to represent dates and times in a consistent way. These objects are immutable and provide information about the type of date they represent. The DateValue is a union of the following three types:  CalendarDate - Represents a date with no time component, such as 2024-07-10 CalendarDateTime - Represents a date and time, such as 2024-07-10T12:30:00 ZonedDateTime - Represents a date and time with a time zone, such as 2023-10-11T21:00:00:00-04:00[America/New_York]  The benefit of using these objects is that they allow you to be very specific about the type of date you want, and the component will adapt to that type. For example, if you pass a CalendarDate object to a DateField component, it will only display the date portion of the date, without the time. See the $2 component for more information.  CalendarDate  The CalendarDate object represents a date with no time component, such as 2024-07-10.  You can use the CalendarDate constructor to create a new CalendarDate object:  import { CalendarDate } from \"@internationalized/date\";  const date = new CalendarDate(2024, 7, 10);  You can also use the parseDate function to parse an $2 string into a CalendarDate object:  import { parseDate } from \"@internationalized/date\";  const date = parseDate(\"2024-07-10\");  If you want to create a CalendarDate with the current date, you can use the today function. This function requires a timezone identifier as an argument, which can be passed in as a string, or by using getLocalTimeZone which returns the user's current time zone:  import { today, getLocalTimeZone } from \"@internationalized/date\";  const losAngelesToday = today(\"America/Los_Angeles\"); const localToday = today(getLocalTimeZone());  See the $2 for more information.  CalendarDateTime  The CalendarDateTime object represents a date and time, such as 2024-07-10T12:30:00.  You can use the CalendarDateTime constructor to create a new CalendarDateTime object:  import { CalendarDateTime } from \"@internationalized/date\";  const dateTime = new CalendarDateTime(2024, 7, 10, 12, 30, 0);  You can also use the parseDateTime function to parse an $2 string into a CalendarDateTime object:  import { parseDateTime } from \"@internationalized/date\";  const dateTime = parseDateTime(\"2024-07-10T12:30:00\");  See the $2 for more information.  ZonedDateTime  The ZonedDateTime object represents a date and time with a time zone, which represents an exact date and time in a specific time zone. ZonedDateTimes are often used for things such as in person events (concerts, conferences, etc.), where you want to represent a date and time in a specific time zone, rather than a specific date and time in the user's local time zone.  You can use the ZonedDateTime constructor to create a new ZonedDateTime object:  import { ZonedDateTime } from \"@internationalized/date\";  const date = new ZonedDateTime(  // Date  2022,  2,  3,  // Time zone and UTC offset  \"America/Los_Angeles\",  -28800000,  // Time  9,  15,  0 );  You can also use one of the following parsing functions to parse an $2 string into a ZonedDateTime object:  import { parseZonedDateTime, parseAbsolute, parseAbsoluteToLocal } from \"@internationalized/date\";  const date = parseZonedDateTime(\"2024-07-12T00:45[America/New_York]\"); // or const date = parseAbsolute(\"2024-07-12T07:45:00Z\", \"America/New_York\"); // or const date = parseAbsoluteToLocal(\"2024-07-12T07:45:00Z\");  See the $2 for more information.  Date Ranges  Bits UI also provides a DateRange type with the following structure:  type DateRange = {  start: DateValue;  end: DateValue; };  This type is used to represent the value of the various date range components in Bits UI, such as the $2, $2, and $2.  Placeholder  Each of the date/time components in Bits UI has a bindable placeholder prop, which acts as the starting point for the component when no value is present. The placeholder value is used to determine the type of date/time to display, and the component and its value will adapt to that type.  For example, if you pass a CalendarDate object to a DateField component, it will only display the date portion of the date, without the time. If you pass a CalendarDateTime object, it will display the date and time. If you pass a ZonedDateTime object, it will display the date and time with the time zone information.  In addition to setting the starting point and type of the date/time, the placeholder is also used to control the view of the calendar. For example, if you wanted to give the user the ability to select a specific month to jump to in the calendar, you could simply update the placeholder to a DateValue representing that month. Here's an example of how you might do that:    import { Calendar } from \"bits-ui\";  import { today, getLocalTimeZone, type DateValue } from \"@internationalized/date\";   let placeholder: DateValue = $state(today(getLocalTimeZone()));  let selectedMonth: number = $state(placeholder.month);    {   placeholder = placeholder.set({ month: selectedMonth });  }}  bind:value={selectedMonth}  January  February          In the example above, we're using the placeholder value to control the view of the calendar. The user can select a specific month to jump to in the calendar, and the placeholder will be updated to reflect the selected month. When the placeholder is updated, the calendar view will automatically update to reflect that new month.  As the user interacts with the calendar, the placeholder will be updated to reflect the currently focused date in the calendar. If a value is selected in the calendar, the placeholder will be updated to reflect that selected value.  Updating the placeholder  It's important to note that DateValue objects are immutable, so you can't directly update the placeholder value. Instead, you'll need to reassign the value to the placeholder prop for the changes to reflect.  @internationalized/date provides a number of methods for updating the DateValue objects, such as set, add, subtract, and cycle, each of which will return a new DateValue object with the updated value.  For example, if you wanted to update the placeholder to the next month, you could use the add method to add one month to the current month in the placeholder value:  let placeholder = new CalendarDate(2024, 07, 10); console.log(placeholder.add({ months: 1 })); // 2024-08-10 console.log(placeholder); // 2024-07-10 (unchanged) placeholder = placeholder.add({ months: 1 }); console.log(placeholder); // 2024-08-10 (updated)  Formatting Dates  @internationalized/date provides a $2 class that is a wrapper around the $2 API that fixes various browser bugs, and polyfills new features.  It's highly recommended to use this class to format dates and times in your application, as it will ensure that the formatting is accurate for all locales, time zones, and calendars.  Parsing Dates  Often, you'll want to parse a string from a database or other source into a DateValue object for use with the date/time components in Bits UI. @internationalized/date provides various parsing functions that can be used to parse strings into each of the supported DateValue objects.  parseDate  The parseDate function is used to parse a string into a CalendarDate object.","description":"How to work with the various date and time components in Bits UI.","href":"/docs/dates"},{"title":"Figma","content":"The Figma UI Kit is open sourced by $2.    import { AspectRatio } from \"bits-ui\";  Grab a copy  https://www.figma.com/community/file/1430229712135910564/bits-ui-kit","description":"Every component recreated in Figma.","href":"/docs/figma-file"},{"title":"Getting Started","content":"Installation  Install bits using your favorite package manager.  npm install bits-ui  You can then import and start using them in your app.    import { Accordion } from \"bits-ui\";            First      First accordion content           Second      Second accordion content           Third      Third accordion content    `","description":"Learn how to get started using Bits in your app.","href":"/docs/getting-started"},{"title":"Introduction","content":"Bits UI is a collection of headless component primitives for Svelte that prioritizes developer experience, accessibility, and flexibility. Our vision is to empower developers to build high-quality, accessible user interfaces without sacrificing creative control or performance.  Why Bits UI?  Bring Your Own Styles  Most components ship with zero styling. Minimal styles are included only when absolutely necessary for core functionality. You maintain complete control over the visual design, applying your own styles through standard Svelte class props or targeting components via data attributes. See our $2 for implementation details.  Empowering DX  Every component is designed with developer experience in mind:  Extensive TypeScript support Predictable behavior and consistent APIs Comprehensive documentation and examples Flexible event override system for custom behavior Sensible defaults  Built for Production  Strives to follow $2 Built-in keyboard navigation Screen reader optimization Focus management  Composable Architecture  Components are designed to work independently or together, featuring:  $2 for maximum flexibility Chainable events and callbacks Override-friendly defaults Minimal dependencies  Community  Bits UI is an open-source project built and maintained by $2 with design support from $2 and his team at $2. We always welcome contributions and feedback from the community.  Found an accessibility issue or have a suggestion? $2.  Acknowledgments  Built on the shoulders of giants:  $2 - Inspired our internal architecture and powered the first version of Bits UI $2 - Reference for component API design $2 - Inspiration for date/time components","description":"The headless components for Svelte.","href":"/docs/introduction"},{"title":"Ref","content":"Bits UI components with underlying HTML elements provide a ref prop for direct element access.  For example, Accordion.Trigger's ref gives access to its rendered HTMLButtonElement:    import { Accordion } from \"bits-ui\";   let triggerRef = $state();   function focusTrigger() {   triggerRef?.focus();  }   Focus trigger  With delegation  Bits UI tracks the reference to the underlying element using its id attribute. This means that even if you use a custom element/component with $2, the ref prop will still work.    import CustomButton from \"./CustomButton.svelte\";  import { Accordion } from \"bits-ui\";   let triggerRef = $state();   function focusTrigger() {   triggerRef?.focus();  }     {#snippet child({ props })}     {/snippet}   One caveat is that if you wish to use a custom id on the element, you must pass it to the component first, so it can be registered and associated with the ref prop. The id you pass will be passed down via the props snippet prop on the child snippet.    import CustomButton from \"./CustomButton.svelte\";  import { Accordion } from \"bits-ui\";   let triggerRef = $state();   function focusTrigger() {   triggerRef?.focus();  }   const myCustomId = \"my-custom-id\";     {#snippet child({ props })}      {/snippet}   The following example would not work, as the Accordion.Trigger component has no idea what the id of the CustomButton is.    import CustomButton from \"./CustomButton.svelte\";  import { Accordion } from \"bits-ui\";   let triggerRef = $state();   function focusTrigger() {   triggerRef?.focus(); // will always be undefined  }     {#snippet child({ props })}      {/snippet}  Why Possibly null?  The ref prop may be null until the element has mounted, especially with the many components that use conditional rendering. This HTMLElement | null type mimics browser DOM methods like getElementById.  WithElementRef  Bits UI exposes a $2 type which enables you to create your own components following the same ref prop pattern.","description":"Learn about the $bindable ref prop.","href":"/docs/ref"},{"title":"Styling","content":"We ship almost zero styles with Bits UI. This is intentional. We want to give you the most flexibility possible when it comes to styling your components.  For each component that renders an HTML element, we expose a class prop that you can use to apply styles to the component. This is the recommended and most straightforward way to style them.  CSS frameworks  If you're using a CSS framework like TailwindCSS or UnoCSS, you can simply pass the classes you need to the component, and they will be applied to the underlying HTML element.    import { Button } from \"bits-ui\";   Click me  Data attributes  A data attribute is applied to each element rendered by Bits UI, which you can use to target the component across your entire application. Check out the API reference of the component to determine what those data attributes are.  You can then use those data attributes like so:  Define global styles  [data-button-root] {  height: 3rem;  width: 100%;  background-color: #3182ce;  color: #fff; }  Import stylesheet    import \"../app.pcss\";   let { children } = $props();   {@render children()}  Now every `` component will have the styles applied to it.  Global classes  If you prefer the class approach, you can simply apply your global classes to the component.  1. Define global styles    .button {  height: 3rem;  width: 100%;  background-color: #3182ce;  color: #fff; }  2. Apply global styles      import \"../app.pcss\";   let { children } = $props();   {@render children()}  3. Use with components      import { Button } from \"bits-ui\";   Click me  Scoped Styles  If you wish to use Svelte's scoped styles, you must use the child snippet for the various components that support it. This moves the underlying HTML element out of the Bits UI component scope and into the scope of your component.  See the $2 documentation for more information.  Style Prop  Bits UI components accept a style prop, which can either be a string or an object of CSS properties and values. These are gracefully merged with the component's internal styles to create a single style object using the $2 function.","description":"Learn how to style Bits UI components.","href":"/docs/styling"},{"title":"Transitions","content":"Svelte Transitions are one of the awesome features of Svelte. Unfortunately, they don't play very nicely with components, due to the fact that they rely on various directives like in:, out:, and transition:, which aren't supported by components.  In previous version of Bits UI, we had a workaround for this by exposing a ton of transition* props on the components that we felt were most likely to be used with transitions. However, this was a bit of a hack and limited us to only Svelte Transitions, and users who wanted to use other libraries or just CSS were left out.  With Bits UI for Svelte 5, we've completely removed this workaround and instead exposed props and snippets that allow you to use any animation or transitions library you want.  The Defaults  By default, Bits UI components handle the mounting and unmounting of specific components for you. They are wrapped in a component that ensures the component waits for transitions to finish before unmounting.  You can use any CSS transitions or animations you want with this approach, which is what we're doing in the various example components in this documentation, using $2.  Force Mounting  On each component that we conditionally render, a forceMount prop is exposed. If set to true, the component will be forced to mount in the DOM and become visible to the user. You can use this prop in conjunction with the $2 child snippet to conditionally render the component and apply Svelte Transitions or another animation library.  The child snippet exposes a prop that you can use to conditionally render the element and apply your transitions.    import { Dialog } from \"bits-ui\";  import { fly } from \"svelte/transition\";          {#snippet child({ props, open })}    {#if open}                    {/if}   {/snippet}     In the example above, we're using the forceMount prop to tell the component to forcefully mount the Dialog.Content component. We're then using the child snippet to delegate the rendering of the Dialog.Content to a div element which we can apply our props and transitions to.  We understand this isn't the prettiest syntax, but it enables us to cover every use case. If you intend to use this approach across your application, it's recommended to create a reusable component that handles this logic, like so:    import type { Snippet } from \"svelte\";  import { fly } from \"svelte/transition\";  import { Dialog, type WithoutChildrenOrChild } from \"bits-ui\";   let {   ref = $bindable(null),   children,   ...restProps  }: WithoutChildrenOrChild & {   children?: Snippet;  } = $props();     {#snippet child({ props, open })}   {#if open}         {@render children?.()}       {/if}  {/snippet}   Which can then be used alongside the other Dialog.* components:    import { Dialog } from \"bits-ui\";  import MyDialogContent from \"$lib/components/MyDialogContent.svelte\";     Open Dialog            Dialog Title    Dialog Description    Close    Other dialog content       `","description":"Learn how to use transitions with Bits UI components.","href":"/docs/transitions"}]